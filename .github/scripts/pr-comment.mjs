#!/usr/bin/env node
/**
 * PR Comment Generator for v6 Validation Reports
 *
 * Generates a formatted markdown comment for pull requests with validation results.
 *
 * Usage:
 *   node .github/scripts/pr-comment.mjs \
 *     --validation-report <path> \
 *     --coverage <path> \
 *     --output <path>
 */

import { readFileSync, writeFileSync } from 'node:fs';
import { resolve } from 'node:path';

// Parse command-line arguments
const args = process.argv.slice(2);
const getArg = (flag) => {
  const index = args.indexOf(flag);
  return index !== -1 ? args[index + 1] : null;
};

const validationReportPath = getArg('--validation-report');
const coveragePath = getArg('--coverage');
const outputPath = getArg('--output') || 'pr-comment.md';

/**
 * Read JSON file safely
 * @param {string} path - File path
 * @returns {object|null} Parsed JSON or null
 */
function readJSON(path) {
  try {
    const content = readFileSync(resolve(path), 'utf-8');
    return JSON.parse(content);
  } catch (error) {
    console.warn(`âš ï¸ Could not read ${path}: ${error.message}`);
    return null;
  }
}

/**
 * Generate status badge
 * @param {string} status - Status (PASS/FAIL)
 * @returns {string} Badge emoji
 */
function statusBadge(status) {
  return status === 'PASS' ? 'âœ…' : 'âŒ';
}

/**
 * Generate PR comment markdown
 */
function generateComment() {
  const validation = readJSON(validationReportPath);
  const coverage = readJSON(coveragePath);

  const lines = [];

  lines.push('## v6 Validation Report\n');

  if (validation) {
    const { status, results, timestamp } = validation;

    lines.push(`### ${statusBadge(status)} Overall Status: **${status}**\n`);
    lines.push('---\n');

    // Validation Summary
    lines.push('### ğŸ“‹ Validation Summary\n');
    lines.push('| Metric | Count |');
    lines.push('|--------|-------|');
    lines.push(`| âœ… Passed | ${results.passed} |`);
    lines.push(`| âŒ Failed | ${results.failed} |`);
    lines.push(`| âš ï¸ Warnings | ${results.warnings} |`);
    lines.push(`| ğŸ“Š Total | ${results.total} |\n`);

    // Passed Checks
    if (results.passed > 0) {
      lines.push('### âœ… Passed Checks\n');
      for (const check of validation.details.passed) {
        lines.push(`- ${check}`);
      }
      lines.push('');
    }

    // Failed Checks
    if (results.failed > 0) {
      lines.push('### âŒ Failed Checks\n');
      for (const check of validation.details.failed) {
        lines.push(`- ${check}`);
      }
      lines.push('');
    }

    // Warnings
    if (results.warnings > 0) {
      lines.push('### âš ï¸ Warnings\n');
      for (const warning of validation.details.warnings) {
        lines.push(`- ${warning}`);
      }
      lines.push('');
    }
  }

  // Coverage Report
  if (coverage) {
    const { total } = coverage;
    const lineCoverage = total.lines.pct;
    const coverageBadge = lineCoverage >= 80 ? 'âœ…' : 'âŒ';

    lines.push('### ğŸ“Š Test Coverage\n');
    lines.push('| Metric | Coverage |');
    lines.push('|--------|----------|');
    lines.push(`| ${coverageBadge} Lines | ${lineCoverage}% |`);
    lines.push(`| Statements | ${total.statements.pct}% |`);
    lines.push(`| Functions | ${total.functions.pct}% |`);
    lines.push(`| Branches | ${total.branches.pct}% |\n`);

    if (lineCoverage < 80) {
      lines.push(`> âš ï¸ **Warning:** Coverage is below 80% threshold (${lineCoverage}%)\n`);
    }
  }

  // Release Readiness
  lines.push('### ğŸš€ Release Readiness\n');

  if (validation && validation.status === 'PASS') {
    if (coverage && coverage.total.lines.pct >= 80) {
      lines.push('âœ… **Ready for v6 release**\n');
      lines.push('This PR meets all validation criteria and coverage requirements.\n');
    } else {
      lines.push('âš ï¸ **Not ready for v6 release**\n');
      lines.push('Coverage is below 80% threshold.\n');
    }
  } else {
    lines.push('âŒ **Not ready for v6 release**\n');
    lines.push('Some validation checks failed. Please review the failed checks above.\n');
  }

  // Footer
  lines.push('---\n');
  lines.push('*Generated by v6 validation pipeline*\n');

  if (validation?.timestamp) {
    lines.push(`*Last updated: ${new Date(validation.timestamp).toISOString()}*\n`);
  }

  return lines.join('\n');
}

// Main
try {
  const comment = generateComment();
  writeFileSync(outputPath, comment, 'utf-8');
  console.log(`âœ… PR comment generated: ${outputPath}`);
} catch (error) {
  console.error(`âŒ Failed to generate PR comment: ${error.message}`);
  process.exit(1);
}
