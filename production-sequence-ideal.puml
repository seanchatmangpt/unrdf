@startuml Production Sequence - Air-Gapped Autonomic Swarm
!theme plain
title UNRDF Production Sequence - Air-Gapped Autonomic Swarm

actor "Developer" as Dev
participant "CLI Tool" as CLI
participant "Policy Pack Manager" as PPM
participant "Knowledge Hook Manager" as KHM
participant "Transaction Manager" as TM
participant "Resolution Layer" as RL
participant "Lockchain Writer" as LW
participant "Effect Sandbox" as ES
participant "Query Optimizer" as QO
participant "RDF Store" as Store
participant "Git Repository" as Git

== Policy Pack Deployment ==
Dev -> CLI: scaffold policy "compliance-v1"
CLI -> PPM: createPolicyPackManifest()
PPM -> CLI: manifest.json
CLI -> CLI: generate hook templates
CLI -> CLI: create test files
CLI -> Dev: policy pack scaffolded

Dev -> CLI: add hook "data-validation"
CLI -> CLI: generate hook.mjs
CLI -> CLI: generate condition.rq
CLI -> CLI: generate test.mjs

== System Initialization ==
Dev -> KHM: new KnowledgeHookManager()
KHM -> PPM: new PolicyPackManager()
KHM -> TM: new TransactionManager()
TM -> RL: new ResolutionLayer()
TM -> LW: new LockchainWriter()
KHM -> QO: new QueryOptimizer()

== Policy Pack Activation ==
Dev -> KHM: loadPolicyPack("compliance-v1")
KHM -> PPM: loadAllPolicyPacks()
PPM -> PPM: scan policy-packs/ directory
PPM -> PPM: validate manifests
PPM -> KHM: policy packs loaded

KHM -> PPM: activatePolicyPack("compliance-v1")
PPM -> PPM: validate dependencies
PPM -> PPM: check compatibility
PPM -> KHM: hooks registered

== Transaction Processing ==
Dev -> KHM: apply(delta)
KHM -> TM: beginTransaction()

== Pre-Transaction Hooks ==
TM -> KHM: executePreHooks(delta)
loop for each pre-hook
    KHM -> ES: createEffectSandbox()
    ES -> ES: initialize worker/vm2
    KHM -> ES: executeEffect(hook.before, payload)
    ES -> Store: read current state
    ES -> ES: execute hook logic
    ES -> KHM: hook result
end

== Condition Evaluation ==
KHM -> QO: optimizeQuery(condition.uri, kind, graph, delta)
QO -> QO: check cache
alt cache hit
    QO -> KHM: cached plan
else cache miss
    QO -> QO: parse query
    QO -> QO: create execution plan
    QO -> QO: apply delta-aware optimization
    QO -> KHM: optimized plan
end

KHM -> QO: executeOptimizedQuery(plan, graph, delta)
QO -> Store: execute query
Store -> QO: query results
QO -> KHM: evaluation result

== Multi-Agent Resolution ==
alt multiple agents
    KHM -> RL: submitProposal(agentId, delta, options)
    RL -> RL: validate delta
    RL -> RL: detect conflicts
    RL -> RL: apply resolution strategy
    RL -> KHM: resolved delta
end

== Hook Execution ==
loop for each qualifying hook
    KHM -> ES: executeEffect(hook.run, payload)
    ES -> Store: read/write operations
    ES -> KHM: execution result
end

== Transaction Commit ==
TM -> TM: validate all results
TM -> TM: generate receipt
TM -> Store: apply delta
Store -> TM: commit confirmation

== Post-Transaction Hooks ==
TM -> KHM: executePostHooks(receipt)
loop for each post-hook
    KHM -> ES: executeEffect(hook.after, payload)
    ES -> Store: read final state
    ES -> KHM: hook result
end

== Lockchain Anchoring ==
TM -> LW: writeReceipt(receipt)
LW -> LW: hash receipt
LW -> LW: sign with private key
LW -> LW: add to batch
alt batch full
    LW -> Git: commit batch
    Git -> LW: commit hash
    LW -> Git: add git notes
    Git -> LW: notes ref
end

== Statistics & Monitoring ==
TM -> TM: update statistics
KHM -> KHM: update hook stats
QO -> QO: update cache stats
RL -> RL: update resolution stats
LW -> LW: update lockchain stats

TM -> KHM: transaction complete
KHM -> Dev: receipt + statistics

== Error Handling ==
alt hook execution fails
    ES -> KHM: execution error
    KHM -> TM: rollback transaction
    TM -> Store: revert changes
    TM -> Dev: error + rollback receipt
end

alt resolution conflict
    RL -> KHM: conflict detected
    KHM -> TM: abort transaction
    TM -> Dev: conflict error
end

alt lockchain failure
    LW -> TM: write error
    TM -> TM: log error
    TM -> Dev: warning + transaction receipt
end

@enduml

