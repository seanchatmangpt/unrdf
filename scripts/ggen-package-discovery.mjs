#!/usr/bin/env node
/**
 * @file scripts/ggen-package-discovery.mjs
 * @description Scan all UNRDF packages and generate RDF ontology instances
 *
 * This script integrates ggen with the existing 57-package monorepo by:
 * 1. Scanning packages/ directory for all package.json files
 * 2. Extracting package metadata (name, version, description, exports, dependencies)
 * 3. Determining tier classification based on package size and dependencies
 * 4. Generating RDF Turtle instances for the domain ontology
 * 5. Creating real package data in schema/domain.ttl
 *
 * Usage: node scripts/ggen-package-discovery.mjs
 */

import fs from 'fs';
import path from 'path';
import { fileURLToPath } from 'url';

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const projectRoot = path.resolve(__dirname, '..');
const packagesDir = path.join(projectRoot, 'packages');
const schemaDir = path.join(projectRoot, 'schema');

/**
 * Classify package into tier based on heuristics
 * @param {Object} pkg Package metadata
 * @returns {string} Tier name (Essential, Extended, Optional, Internal)
 */
function classifyTier(pkg) {
  const { name, dependencies = {} } = pkg;
  const depCount = Object.keys(dependencies).length;

  // Essential tier packages (core, critical foundations)
  const essentialPatterns = [
    '@unrdf/core', '@unrdf/oxigraph', '@unrdf/kgc-4d', '@unrdf/hooks',
    '@unrdf/streaming', '@unrdf/v6-core', '@unrdf/yawl'
  ];
  if (essentialPatterns.includes(name)) return 'Essential';

  // Internal tier (test/docs only)
  const internalPatterns = ['integration-tests', 'docs', 'test-utils', 'validation'];
  if (internalPatterns.some(p => name.includes(p))) return 'Internal';

  // Optional tier (performance, analytics, optional features)
  const optionalPatterns = ['benchmark', 'analytics', 'profiler', 'perf', 'cache'];
  if (optionalPatterns.some(p => name.includes(p))) return 'Optional';

  // Default to Extended (commonly used)
  return 'Extended';
}

/**
 * Extract export paths from package.json exports field
 * @param {Object} pkg Package metadata
 * @returns {string[]} Array of export paths
 */
function extractExports(pkg) {
  const { exports = {} } = pkg;
  if (typeof exports === 'string') return [exports];
  if (typeof exports === 'object') {
    return Object.keys(exports).map(key => exports[key]);
  }
  return [];
}

/**
 * Scan all packages and extract metadata
 * @returns {Object[]} Array of package metadata objects
 */
function scanPackages() {
  const packages = [];

  if (!fs.existsSync(packagesDir)) {
    console.error(`Packages directory not found: ${packagesDir}`);
    process.exit(1);
  }

  const entries = fs.readdirSync(packagesDir, { withFileTypes: true });

  for (const entry of entries) {
    if (!entry.isDirectory()) continue;

    const packagePath = path.join(packagesDir, entry.name);
    const packageJsonPath = path.join(packagePath, 'package.json');

    if (!fs.existsSync(packageJsonPath)) continue;

    try {
      const content = fs.readFileSync(packageJsonPath, 'utf-8');
      const pkg = JSON.parse(content);

      if (!pkg.name || !pkg.name.startsWith('@unrdf/')) continue;

      packages.push({
        name: pkg.name,
        version: pkg.version || '0.0.0',
        description: pkg.description || 'No description',
        exports: extractExports(pkg),
        dependencies: pkg.dependencies || {},
        directory: entry.name,
        tier: classifyTier(pkg),
        keywords: pkg.keywords || [],
        license: pkg.license || 'MIT'
      });
    } catch (error) {
      console.warn(`Warning: Failed to parse ${packageJsonPath}: ${error.message}`);
    }
  }

  return packages.sort((a, b) => a.name.localeCompare(b.name));
}

/**
 * Find internal UNRDF dependencies
 * @param {Object} pkg Package metadata
 * @param {Object[]} allPackages All packages
 * @returns {string[]} Names of dependent UNRDF packages
 */
function findUnrdfDependencies(pkg, allPackages) {
  const deps = Object.keys(pkg.dependencies || {});
  const unrdfDeps = deps.filter(d => d.startsWith('@unrdf/'));
  return unrdfDeps;
}

/**
 * Generate RDF Turtle instances for packages
 * @param {Object[]} packages Array of package metadata
 * @returns {string} Turtle RDF string
 */
function generateTurtleInstances(packages) {
  const lines = [
    '# UNRDF Packages - Auto-generated from package discovery',
    '# Generated by scripts/ggen-package-discovery.mjs',
    '# Run: node scripts/ggen-package-discovery.mjs',
    '',
    ''
  ];

  // Group packages by tier
  const byTier = {};
  for (const pkg of packages) {
    if (!byTier[pkg.tier]) byTier[pkg.tier] = [];
    byTier[pkg.tier].push(pkg);
  }

  // Generate instances for each package
  for (const pkg of packages) {
    const varName = pkg.name
      .replace('@unrdf/', '')
      .replace(/-/g, '')
      .charAt(0)
      .toUpperCase() +
      pkg.name
        .replace('@unrdf/', '')
        .replace(/-/g, '')
        .slice(1) +
      'Package';

    lines.push(`# ${pkg.name}`);
    lines.push(`unrdf:${varName} a unrdf:Package ;`);
    lines.push(`    unrdf:packageName "${pkg.name}" ;`);
    lines.push(`    unrdf:packageVersion "${pkg.version}" ;`);
    lines.push(`    unrdf:packageDescription "${pkg.description.replace(/"/g, '\\"')}" ;`);
    lines.push(`    unrdf:hasTier unrdf:${pkg.tier}Tier ;`);

    // Add dependencies
    const unrdfDeps = findUnrdfDependencies(pkg, packages);
    if (unrdfDeps.length > 0) {
      for (const dep of unrdfDeps) {
        const depVar = dep
          .replace('@unrdf/', '')
          .replace(/-/g, '')
          .charAt(0)
          .toUpperCase() +
          dep
            .replace('@unrdf/', '')
            .replace(/-/g, '')
            .slice(1) +
          'Package';
        lines.push(`    unrdf:hasDependency unrdf:${depVar} ;`);
      }
    }

    lines.push(`    rdfs:label "${pkg.name}" .`);
    lines.push('');
  }

  return lines.join('\n');
}

/**
 * Main execution
 */
function main() {
  console.log('ğŸ” Scanning UNRDF packages...');
  const packages = scanPackages();
  console.log(`âœ… Found ${packages.length} packages\n`);

  // Print summary
  const tiers = {};
  for (const pkg of packages) {
    if (!tiers[pkg.tier]) tiers[pkg.tier] = [];
    tiers[pkg.tier].push(pkg.name);
  }

  console.log('ğŸ“Š Package Summary by Tier:');
  for (const [tier, pkgs] of Object.entries(tiers)) {
    console.log(`  ${tier}: ${pkgs.length} packages`);
  }
  console.log('');

  // Generate Turtle
  const turtle = generateTurtleInstances(packages);

  // Output to file
  const outputPath = path.join(schemaDir, 'packages-discovered.ttl');
  fs.writeFileSync(outputPath, turtle, 'utf-8');

  console.log(`âœ¨ Generated RDF instances: ${outputPath}`);
  console.log(`\nğŸ“‹ Package discovery complete!`);
  console.log(`\nNext steps:`);
  console.log(`  1. Review: cat ${path.relative(projectRoot, outputPath)}`);
  console.log(`  2. Integrate: Merge contents into schema/domain.ttl`);
  console.log(`  3. Generate: ggen sync`);
}

main().catch(error => {
  console.error('âŒ Error:', error.message);
  process.exit(1);
});
