/**
 * @fileoverview Facade module generation from contracts
 * @module agent-8/facade-generator
 */

/**
 * Generate facade code for a domain
 * Facade wraps substrate and exposes legacy API interface
 *
 * @param {string} domain - Domain name
 * @param {Array<Object>} contracts - Domain contracts
 * @returns {string} Facade module code
 */
export function generateFacade(domain, contracts) {
  const operations = contracts.map(c => c.operation);

  const imports = generateImports(domain);
  const facadeClass = generateFacadeClass(domain, contracts);
  const exports = generateExports(domain);

  return `${imports}

${facadeClass}

${exports}
`;
}

/**
 * Generate imports for facade
 *
 * @param {string} domain - Domain name
 * @returns {string} Import statements
 */
function generateImports(domain) {
  return `/**
 * @fileoverview Legacy ${domain} facade
 * Generated by Agent 8 - Domain Kit Generator
 */

import { createSubstrate } from '../../substrate/${domain}-substrate.mjs';`;
}

/**
 * Generate facade class
 *
 * @param {string} domain - Domain name
 * @param {Array<Object>} contracts - Domain contracts
 * @returns {string} Facade class code
 */
function generateFacadeClass(domain, contracts) {
  const className = `${capitalize(domain)}Facade`;
  const methods = contracts.map(generateMethod).join('\n\n  ');

  return `/**
 * Legacy ${domain} facade
 * Wraps substrate and exposes legacy API
 */
class ${className} {
  constructor(config = {}) {
    this.substrate = createSubstrate(config);
    this.config = config;
  }

  ${methods}
}`;
}

/**
 * Generate facade method from contract
 *
 * @param {Object} contract - Operation contract
 * @returns {string} Method code
 */
function generateMethod(contract) {
  const { operation, params, returns } = contract;
  const paramList = params.map(p => p.name).join(', ');
  const paramDocs = params.map(p => `   * @param {${p.type}} ${p.name} - ${p.description || p.name}`).join('\n');

  return `/**
   * ${contract.description || operation}
${paramDocs}
   * @returns {${returns.type}} ${returns.description || 'Result'}
   */
  async ${operation}(${paramList}) {
    // Adapt legacy params to substrate format
    const substrateInput = {
      ${params.map(p => `${p.name}`).join(',\n      ')}
    };

    // Execute on substrate
    const result = await this.substrate.execute('${operation}', substrateInput);

    // Adapt substrate result to legacy format
    return result;
  }`;
}

/**
 * Generate exports
 *
 * @param {string} domain - Domain name
 * @returns {string} Export statements
 */
function generateExports(domain) {
  const className = `${capitalize(domain)}Facade`;

  return `
/**
 * Create ${domain} facade instance
 *
 * @param {Object} config - Configuration
 * @returns {${className}} Facade instance
 */
export function create${className}(config = {}) {
  return new ${className}(config);
}

export default ${className};`;
}

/**
 * Capitalize first letter
 *
 * @param {string} str - Input string
 * @returns {string} Capitalized string
 */
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

/**
 * Generate facade JSDoc annotations
 *
 * @param {Object} contract - Operation contract
 * @returns {string} JSDoc string
 */
export function generateJSDoc(contract) {
  const { operation, params, returns, description } = contract;

  const paramDocs = params.map(p =>
    ` * @param {${p.type}} ${p.name} - ${p.description || p.name}`
  ).join('\n');

  return `/**
 * ${description || operation}
 *
${paramDocs}
 * @returns {${returns.type}} ${returns.description || 'Result'}
 */`;
}

/**
 * Generate facade for specific operation
 *
 * @param {string} domain - Domain name
 * @param {Object} contract - Single contract
 * @returns {string} Operation facade code
 */
export function generateOperationFacade(domain, contract) {
  return generateMethod(contract);
}
