{
    "sourceFile": "test/index.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 4,
            "patches": [
                {
                    "date": 1758655166536,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758655918713,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,14 +1,1 @@\n-import { describe, expect, it } from \"vitest\";\n-import { test } from \"../src/index.mjs\";\n-\n-/**\n- * Test suite for the main package functionality\n- */\n-describe(\"packageName\", () => {\n-  /**\n-   * Test that the test function works correctly\n-   */\n-  it(\"should return 'works!' from test function\", () => {\n-    expect(test()).toBe(\"works!\");\n-  });\n-});\n+ \n\\ No newline at end of file\n"
                },
                {
                    "date": 1758656015547,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,1 +1,533 @@\n- \n\\ No newline at end of file\n+/**\n+ * @fileoverview unrdf test suite\n+ * \n+ * Comprehensive tests for the unrdf framework covering all composables,\n+ * utilities, and core functionality.\n+ * \n+ * @version 1.0.0\n+ * @author GitVan Team\n+ * @license MIT\n+ */\n+\n+import { describe, test, expect, beforeEach } from \"vitest\";\n+import { \n+  useStore, \n+  useGraph, \n+  useTurtle, \n+  useValidator, \n+  useReasoner, \n+  useCanon, \n+  useZod,\n+  RdfEngine,\n+  asNamedNode,\n+  asLiteral,\n+  asBlankNode,\n+  quadToJSON,\n+  jsonToQuad,\n+  validateIRI,\n+  validateTerm,\n+  validateQuad,\n+  pluck,\n+  indexByPredicate,\n+  getSubjectsByType,\n+  hasType,\n+  getOne,\n+  getAll,\n+  debugTurtle,\n+  debugNQuads,\n+  validateStore,\n+  validateRDFConstraints\n+} from \"../src/index.mjs\";\n+\n+describe(\"unrdf\", () => {\n+  describe(\"useStore\", () => {\n+    test(\"should create a new store\", () => {\n+      const store = useStore();\n+      expect(store).toBeDefined();\n+      expect(store.store).toBeDefined();\n+      expect(store.size).toBe(0);\n+    });\n+\n+    test(\"should add quads to store\", () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+      expect(store.size).toBe(1);\n+    });\n+\n+    test(\"should get statistics\", () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+      const stats = store.stats();\n+      expect(stats.quads).toBe(1);\n+      expect(stats.subjects).toBe(1);\n+      expect(stats.predicates).toBe(1);\n+      expect(stats.objects).toBe(1);\n+    });\n+\n+    test(\"should serialize to Turtle\", async () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+      const turtle = await store.serialize();\n+      expect(turtle).toContain(\"http://example.org/s\");\n+      expect(turtle).toContain(\"http://example.org/p\");\n+      expect(turtle).toContain(\"value\");\n+    });\n+  });\n+\n+  describe(\"useGraph\", () => {\n+    let store;\n+    let graph;\n+\n+    beforeEach(() => {\n+      store = useStore();\n+      graph = useGraph(store.store);\n+    });\n+\n+    test(\"should create a graph from store\", () => {\n+      expect(graph).toBeDefined();\n+      expect(graph.store).toBe(store.store);\n+    });\n+\n+    test(\"should execute SPARQL SELECT query\", async () => {\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const results = await graph.select(`\n+        PREFIX ex: <http://example.org/>\n+        SELECT ?s ?p ?o WHERE { ?s ?p ?o }\n+      `);\n+\n+      expect(results).toHaveLength(1);\n+      expect(results[0].s).toBe(\"http://example.org/s\");\n+      expect(results[0].p).toBe(\"http://example.org/p\");\n+      expect(results[0].o).toBe(\"value\");\n+    });\n+\n+    test(\"should execute SPARQL ASK query\", async () => {\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const result = await graph.ask(`\n+        PREFIX ex: <http://example.org/>\n+        ASK { ex:s ex:p ?o }\n+      `);\n+\n+      expect(result).toBe(true);\n+    });\n+\n+    test(\"should get statistics\", () => {\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const stats = graph.stats;\n+      expect(stats.quads).toBe(1);\n+      expect(stats.subjects).toBe(1);\n+      expect(stats.predicates).toBe(1);\n+      expect(stats.objects).toBe(1);\n+    });\n+  });\n+\n+  describe(\"useValidator\", () => {\n+    test(\"should create a validator\", () => {\n+      const validator = useValidator();\n+      expect(validator).toBeDefined();\n+      expect(validator.engine).toBeDefined();\n+    });\n+\n+    test(\"should validate store against SHACL shapes\", async () => {\n+      const validator = useValidator();\n+      const store = useStore();\n+      \n+      // Add some data\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      // Simple SHACL shapes\n+      const shapes = `\n+        @prefix sh: <http://www.w3.org/ns/shacl#> .\n+        @prefix ex: <http://example.org/> .\n+        ex:Shape a sh:NodeShape .\n+      `;\n+\n+      const report = await validator.validate(store.store, shapes);\n+      expect(report).toBeDefined();\n+      expect(report.conforms).toBeDefined();\n+      expect(report.results).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"useReasoner\", () => {\n+    test(\"should create a reasoner\", () => {\n+      const reasoner = useReasoner();\n+      expect(reasoner).toBeDefined();\n+      expect(reasoner.engine).toBeDefined();\n+    });\n+\n+    test(\"should reason over data with rules\", async () => {\n+      const reasoner = useReasoner();\n+      const store = useStore();\n+      \n+      // Add some data\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      // Simple rules\n+      const rules = `\n+        @prefix ex: <http://example.org/> .\n+        { ?s ex:p ?o } => { ?s ex:inferred ?o } .\n+      `;\n+\n+      const inferred = await reasoner.reason(store.store, rules);\n+      expect(inferred).toBeDefined();\n+      expect(inferred.store).toBeDefined();\n+    });\n+  });\n+\n+  describe(\"useCanon\", () => {\n+    test(\"should create a canon\", () => {\n+      const canon = useCanon();\n+      expect(canon).toBeDefined();\n+      expect(canon.engine).toBeDefined();\n+    });\n+\n+    test(\"should canonicalize a store\", async () => {\n+      const canon = useCanon();\n+      const store = useStore();\n+      \n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const canonical = await canon.canonicalize(store.store);\n+      expect(canonical).toBeDefined();\n+      expect(typeof canonical).toBe(\"string\");\n+    });\n+\n+    test(\"should check isomorphism\", async () => {\n+      const canon = useCanon();\n+      const store1 = useStore();\n+      const store2 = useStore();\n+      \n+      const quad1 = store1.quad(\n+        store1.namedNode(\"http://example.org/s\"),\n+        store1.namedNode(\"http://example.org/p\"),\n+        store1.literal(\"value\")\n+      );\n+      store1.add(quad1);\n+\n+      const quad2 = store2.quad(\n+        store2.namedNode(\"http://example.org/s\"),\n+        store2.namedNode(\"http://example.org/p\"),\n+        store2.literal(\"value\")\n+      );\n+      store2.add(quad2);\n+\n+      const isIsomorphic = await canon.isIsomorphic(store1.store, store2.store);\n+      expect(isIsomorphic).toBe(true);\n+    });\n+  });\n+\n+  describe(\"useZod\", () => {\n+    test(\"should create a zod validator\", () => {\n+      const zod = useZod();\n+      expect(zod).toBeDefined();\n+    });\n+\n+    test(\"should validate SPARQL results\", async () => {\n+      const zod = useZod();\n+      const results = [\n+        { id: \"http://example.org/1\", name: \"John\", age: 30 },\n+        { id: \"http://example.org/2\", name: \"Jane\", age: 25 }\n+      ];\n+\n+      const PersonSchema = z.object({\n+        id: z.string().url(),\n+        name: z.string(),\n+        age: z.number().int().min(0)\n+      });\n+\n+      const validation = await zod.validateResults(results, PersonSchema);\n+      expect(validation.validated).toHaveLength(2);\n+      expect(validation.errors).toHaveLength(0);\n+    });\n+  });\n+\n+  describe(\"RdfEngine\", () => {\n+    test(\"should create an RDF engine\", () => {\n+      const engine = new RdfEngine();\n+      expect(engine).toBeDefined();\n+      expect(engine.baseIRI).toBe(\"http://example.org/\");\n+      expect(engine.deterministic).toBe(true);\n+    });\n+\n+    test(\"should parse Turtle\", () => {\n+      const engine = new RdfEngine();\n+      const turtle = `\n+        @prefix ex: <http://example.org/> .\n+        ex:s ex:p ex:o .\n+      `;\n+      \n+      const store = engine.parseTurtle(turtle);\n+      expect(store.size).toBe(1);\n+    });\n+\n+    test(\"should serialize to Turtle\", async () => {\n+      const engine = new RdfEngine();\n+      const store = engine.createStore();\n+      const quad = engine.quad(\n+        engine.namedNode(\"http://example.org/s\"),\n+        engine.namedNode(\"http://example.org/p\"),\n+        engine.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const turtle = await engine.serializeTurtle(store);\n+      expect(turtle).toContain(\"http://example.org/s\");\n+      expect(turtle).toContain(\"http://example.org/p\");\n+      expect(turtle).toContain(\"value\");\n+    });\n+  });\n+\n+  describe(\"Term utilities\", () => {\n+    test(\"should create named nodes\", () => {\n+      const node = asNamedNode(\"http://example.org/foo\");\n+      expect(node.termType).toBe(\"NamedNode\");\n+      expect(node.value).toBe(\"http://example.org/foo\");\n+    });\n+\n+    test(\"should create literals\", () => {\n+      const lit = asLiteral(\"hello\");\n+      expect(lit.termType).toBe(\"Literal\");\n+      expect(lit.value).toBe(\"hello\");\n+    });\n+\n+    test(\"should create blank nodes\", () => {\n+      const bnode = asBlankNode();\n+      expect(bnode.termType).toBe(\"BlankNode\");\n+      expect(bnode.value).toBeDefined();\n+    });\n+\n+    test(\"should convert quad to JSON\", () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+\n+      const json = quadToJSON(quad);\n+      expect(json.subject).toBe(\"http://example.org/s\");\n+      expect(json.predicate).toBe(\"http://example.org/p\");\n+      expect(json.object).toBe(\"value\");\n+    });\n+\n+    test(\"should convert JSON to quad\", () => {\n+      const json = {\n+        subject: \"http://example.org/s\",\n+        predicate: \"http://example.org/p\",\n+        object: \"http://example.org/o\"\n+      };\n+\n+      const quad = jsonToQuad(json);\n+      expect(quad.subject.value).toBe(\"http://example.org/s\");\n+      expect(quad.predicate.value).toBe(\"http://example.org/p\");\n+      expect(quad.object.value).toBe(\"http://example.org/o\");\n+    });\n+  });\n+\n+  describe(\"Graph utilities\", () => {\n+    let store;\n+\n+    beforeEach(() => {\n+      store = useStore();\n+      const quad1 = store.quad(\n+        store.namedNode(\"http://example.org/s1\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value1\")\n+      );\n+      const quad2 = store.quad(\n+        store.namedNode(\"http://example.org/s2\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value2\")\n+      );\n+      store.add(quad1, quad2);\n+    });\n+\n+    test(\"should pluck by predicate\", () => {\n+      const quads = pluck(store.store, \"http://example.org/p\");\n+      expect(quads).toHaveLength(2);\n+    });\n+\n+    test(\"should index by predicate\", () => {\n+      const index = indexByPredicate(store.store, \"http://example.org/p\");\n+      expect(index.size).toBe(2);\n+      expect(index.get(\"http://example.org/s1\")).toContain(\"value1\");\n+      expect(index.get(\"http://example.org/s2\")).toContain(\"value2\");\n+    });\n+\n+    test(\"should get subjects by type\", () => {\n+      const typeQuad = store.quad(\n+        store.namedNode(\"http://example.org/s1\"),\n+        store.namedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"),\n+        store.namedNode(\"http://example.org/Type\")\n+      );\n+      store.add(typeQuad);\n+\n+      const subjects = getSubjectsByType(store.store, \"http://example.org/Type\");\n+      expect(subjects).toHaveLength(1);\n+      expect(subjects[0].value).toBe(\"http://example.org/s1\");\n+    });\n+\n+    test(\"should check if subject has type\", () => {\n+      const typeQuad = store.quad(\n+        store.namedNode(\"http://example.org/s1\"),\n+        store.namedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"),\n+        store.namedNode(\"http://example.org/Type\")\n+      );\n+      store.add(typeQuad);\n+\n+      const hasTypeResult = hasType(store.store, \"http://example.org/s1\", \"http://example.org/Type\");\n+      expect(hasTypeResult).toBe(true);\n+    });\n+\n+    test(\"should get one object\", () => {\n+      const value = getOne(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n+      expect(value).toBe(\"value1\");\n+    });\n+\n+    test(\"should get all objects\", () => {\n+      const values = getAll(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n+      expect(values).toHaveLength(1);\n+      expect(values[0]).toBe(\"value1\");\n+    });\n+  });\n+\n+  describe(\"Serialization utilities\", () => {\n+    test(\"should debug serialize to Turtle\", async () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const turtle = await debugTurtle(store.store);\n+      expect(turtle).toContain(\"http://example.org/s\");\n+      expect(turtle).toContain(\"http://example.org/p\");\n+      expect(turtle).toContain(\"value\");\n+    });\n+\n+    test(\"should debug serialize to N-Quads\", async () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const nquads = await debugNQuads(store.store);\n+      expect(nquads).toContain(\"http://example.org/s\");\n+      expect(nquads).toContain(\"http://example.org/p\");\n+      expect(nquads).toContain(\"value\");\n+    });\n+  });\n+\n+  describe(\"Validation utilities\", () => {\n+    test(\"should validate IRIs\", () => {\n+      expect(validateIRI(\"http://example.org/foo\")).toBe(true);\n+      expect(validateIRI(\"not-a-uri\")).toBe(false);\n+    });\n+\n+    test(\"should validate terms\", () => {\n+      const validTerm = { termType: \"NamedNode\", value: \"http://example.org/foo\" };\n+      const invalidTerm = { termType: \"Invalid\", value: \"foo\" };\n+      \n+      expect(validateTerm(validTerm)).toBe(true);\n+      expect(validateTerm(invalidTerm)).toBe(false);\n+    });\n+\n+    test(\"should validate quads\", () => {\n+      const validQuad = {\n+        subject: { termType: \"NamedNode\", value: \"http://example.org/s\" },\n+        predicate: { termType: \"NamedNode\", value: \"http://example.org/p\" },\n+        object: { termType: \"Literal\", value: \"value\" }\n+      };\n+      const invalidQuad = {\n+        subject: { termType: \"Invalid\", value: \"s\" },\n+        predicate: { termType: \"NamedNode\", value: \"http://example.org/p\" },\n+        object: { termType: \"Literal\", value: \"value\" }\n+      };\n+      \n+      expect(validateQuad(validQuad)).toBe(true);\n+      expect(validateQuad(invalidQuad)).toBe(false);\n+    });\n+\n+    test(\"should validate store\", () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const result = validateStore(store.store);\n+      expect(result.valid).toBe(true);\n+      expect(result.issues).toHaveLength(0);\n+    });\n+\n+    test(\"should validate RDF constraints\", () => {\n+      const store = useStore();\n+      const quad = store.quad(\n+        store.namedNode(\"http://example.org/s\"),\n+        store.namedNode(\"http://example.org/p\"),\n+        store.literal(\"value\")\n+      );\n+      store.add(quad);\n+\n+      const result = validateRDFConstraints(store.store);\n+      expect(result.valid).toBe(true);\n+      expect(result.violations).toHaveLength(0);\n+    });\n+  });\n+});\n"
                },
                {
                    "date": 1758656326640,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -9,8 +9,9 @@\n  * @license MIT\n  */\n \n import { describe, test, expect, beforeEach } from \"vitest\";\n+import { z } from \"zod\";\n import { \n   useStore, \n   useGraph, \n   useTurtle, \n@@ -21,21 +22,33 @@\n   RdfEngine,\n   asNamedNode,\n   asLiteral,\n   asBlankNode,\n-  quadToJSON,\n-  jsonToQuad,\n+  asString,\n+  getIRI,\n+  smartLiteral,\n+  isNamedNode,\n+  isLiteral,\n+  isBlankNode,\n+  getObjects,\n+  getSubjects,\n+  getPredicates,\n+  isA,\n+  getTypes,\n+  pluck,\n+  indexByPredicate,\n+  getProperties,\n+  hasSubject,\n+  getAllSubjects,\n+  getAllPredicates,\n+  getAllObjects,\n+  findByProperty,\n+  getFirstObject,\n+  countQuadsForSubject,\n+  getQuadsForSubject,\n   validateIRI,\n   validateTerm,\n   validateQuad,\n-  pluck,\n-  indexByPredicate,\n-  getSubjectsByType,\n-  hasType,\n-  getOne,\n-  getAll,\n-  debugTurtle,\n-  debugNQuads,\n   validateStore,\n   validateRDFConstraints\n } from \"../src/index.mjs\";\n \n@@ -339,39 +352,63 @@\n       expect(lit.value).toBe(\"hello\");\n     });\n \n     test(\"should create blank nodes\", () => {\n-      const bnode = asBlankNode();\n+      const bnode = asBlankNode(\"test123\");\n       expect(bnode.termType).toBe(\"BlankNode\");\n-      expect(bnode.value).toBeDefined();\n+      expect(bnode.value).toBe(\"test123\");\n     });\n \n-    test(\"should convert quad to JSON\", () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n+    test(\"should convert terms to strings\", () => {\n+      const node = asNamedNode(\"http://example.org/foo\");\n+      const lit = asLiteral(\"hello\");\n+      \n+      expect(asString(node)).toBe(\"http://example.org/foo\");\n+      expect(asString(lit)).toBe(\"hello\");\n+      expect(asString(\"plain string\")).toBe(\"plain string\");\n+    });\n \n-      const json = quadToJSON(quad);\n-      expect(json.subject).toBe(\"http://example.org/s\");\n-      expect(json.predicate).toBe(\"http://example.org/p\");\n-      expect(json.object).toBe(\"value\");\n+    test(\"should get IRI from terms\", () => {\n+      const node = asNamedNode(\"http://example.org/foo\");\n+      \n+      expect(getIRI(node)).toBe(\"http://example.org/foo\");\n+      expect(getIRI(\"http://example.org/bar\")).toBe(\"http://example.org/bar\");\n     });\n \n-    test(\"should convert JSON to quad\", () => {\n-      const json = {\n-        subject: \"http://example.org/s\",\n-        predicate: \"http://example.org/p\",\n-        object: \"http://example.org/o\"\n-      };\n+    test(\"should create smart literals\", () => {\n+      const stringLit = smartLiteral(\"hello\");\n+      const numberLit = smartLiteral(42);\n+      const booleanLit = smartLiteral(true);\n+      const dateLit = smartLiteral(new Date(\"2023-01-01\"));\n \n-      const quad = jsonToQuad(json);\n-      expect(quad.subject.value).toBe(\"http://example.org/s\");\n-      expect(quad.predicate.value).toBe(\"http://example.org/p\");\n-      expect(quad.object.value).toBe(\"http://example.org/o\");\n+      expect(stringLit.termType).toBe(\"Literal\");\n+      expect(stringLit.value).toBe(\"hello\");\n+      expect(stringLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#string\");\n+\n+      expect(numberLit.value).toBe(\"42\");\n+      expect(numberLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#decimal\");\n+\n+      expect(booleanLit.value).toBe(\"true\");\n+      expect(booleanLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#boolean\");\n+\n+      expect(dateLit.value).toBe(\"2023-01-01T00:00:00.000Z\");\n+      expect(dateLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#dateTime\");\n     });\n+\n+    test(\"should check term types\", () => {\n+      const node = asNamedNode(\"http://example.org/foo\");\n+      const lit = asLiteral(\"hello\");\n+      const bnode = asBlankNode(\"test\");\n+\n+      expect(isNamedNode(node)).toBe(true);\n+      expect(isNamedNode(lit)).toBe(false);\n+\n+      expect(isLiteral(lit)).toBe(true);\n+      expect(isLiteral(node)).toBe(false);\n+\n+      expect(isBlankNode(bnode)).toBe(true);\n+      expect(isBlankNode(node)).toBe(false);\n+    });\n   });\n \n   describe(\"Graph utilities\", () => {\n     let store;\n@@ -390,89 +427,118 @@\n       );\n       store.add(quad1, quad2);\n     });\n \n-    test(\"should pluck by predicate\", () => {\n-      const quads = pluck(store.store, \"http://example.org/p\");\n-      expect(quads).toHaveLength(2);\n+    test(\"should get objects for subject+predicate\", () => {\n+      const objects = getObjects(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n+      expect(objects).toHaveLength(1);\n+      expect(objects[0].value).toBe(\"value1\");\n     });\n \n-    test(\"should index by predicate\", () => {\n-      const index = indexByPredicate(store.store, \"http://example.org/p\");\n-      expect(index.size).toBe(2);\n-      expect(index.get(\"http://example.org/s1\")).toContain(\"value1\");\n-      expect(index.get(\"http://example.org/s2\")).toContain(\"value2\");\n+    test(\"should get subjects for predicate+object\", () => {\n+      const subjects = getSubjects(store.store, \"http://example.org/p\", \"value1\");\n+      expect(subjects).toHaveLength(1);\n+      expect(subjects[0].value).toBe(\"http://example.org/s1\");\n     });\n \n-    test(\"should get subjects by type\", () => {\n+    test(\"should get predicates for subject+object\", () => {\n+      const predicates = getPredicates(store.store, \"http://example.org/s1\", \"value1\");\n+      expect(predicates).toHaveLength(1);\n+      expect(predicates[0].value).toBe(\"http://example.org/p\");\n+    });\n+\n+    test(\"should check if subject has type\", () => {\n       const typeQuad = store.quad(\n         store.namedNode(\"http://example.org/s1\"),\n         store.namedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"),\n         store.namedNode(\"http://example.org/Type\")\n       );\n       store.add(typeQuad);\n \n-      const subjects = getSubjectsByType(store.store, \"http://example.org/Type\");\n-      expect(subjects).toHaveLength(1);\n-      expect(subjects[0].value).toBe(\"http://example.org/s1\");\n+      const hasTypeResult = isA(store.store, \"http://example.org/s1\", \"http://example.org/Type\");\n+      expect(hasTypeResult).toBe(true);\n     });\n \n-    test(\"should check if subject has type\", () => {\n+    test(\"should get types for subject\", () => {\n       const typeQuad = store.quad(\n         store.namedNode(\"http://example.org/s1\"),\n         store.namedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"),\n         store.namedNode(\"http://example.org/Type\")\n       );\n       store.add(typeQuad);\n \n-      const hasTypeResult = hasType(store.store, \"http://example.org/s1\", \"http://example.org/Type\");\n-      expect(hasTypeResult).toBe(true);\n+      const types = getTypes(store.store, \"http://example.org/s1\");\n+      expect(types).toHaveLength(1);\n+      expect(types[0]).toBe(\"http://example.org/Type\");\n     });\n \n-    test(\"should get one object\", () => {\n-      const value = getOne(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n-      expect(value).toBe(\"value1\");\n+    test(\"should pluck by predicate\", () => {\n+      const quads = pluck(store.store, \"http://example.org/p\");\n+      expect(quads).toHaveLength(2);\n     });\n \n+    test(\"should index by predicate\", () => {\n+      const index = indexByPredicate(store.store, \"http://example.org/p\");\n+      expect(index.size).toBe(2);\n+      expect(index.get(\"http://example.org/s1\")).toContain(\"value1\");\n+      expect(index.get(\"http://example.org/s2\")).toContain(\"value2\");\n+    });\n+\n+    test(\"should get properties for subject\", () => {\n+      const properties = getProperties(store.store, \"http://example.org/s1\");\n+      expect(properties.size).toBe(1);\n+      expect(properties.get(\"http://example.org/p\")).toContain(\"value1\");\n+    });\n+\n+    test(\"should check if subject exists\", () => {\n+      expect(hasSubject(store.store, \"http://example.org/s1\")).toBe(true);\n+      expect(hasSubject(store.store, \"http://example.org/nonexistent\")).toBe(false);\n+    });\n+\n+    test(\"should get all subjects\", () => {\n+      const subjects = getAllSubjects(store.store);\n+      expect(subjects).toHaveLength(2);\n+      expect(subjects).toContain(\"http://example.org/s1\");\n+      expect(subjects).toContain(\"http://example.org/s2\");\n+    });\n+\n+    test(\"should get all predicates\", () => {\n+      const predicates = getAllPredicates(store.store);\n+      expect(predicates).toHaveLength(1);\n+      expect(predicates[0]).toBe(\"http://example.org/p\");\n+    });\n+\n     test(\"should get all objects\", () => {\n-      const values = getAll(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n-      expect(values).toHaveLength(1);\n-      expect(values[0]).toBe(\"value1\");\n+      const objects = getAllObjects(store.store);\n+      expect(objects).toHaveLength(2);\n+      expect(objects).toContain(\"value1\");\n+      expect(objects).toContain(\"value2\");\n     });\n-  });\n \n-  describe(\"Serialization utilities\", () => {\n-    test(\"should debug serialize to Turtle\", async () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n+    test(\"should find subjects by property value\", () => {\n+      const subjects = findByProperty(store.store, \"http://example.org/p\", \"value1\");\n+      expect(subjects).toHaveLength(1);\n+      expect(subjects[0]).toBe(\"http://example.org/s1\");\n+    });\n \n-      const turtle = await debugTurtle(store.store);\n-      expect(turtle).toContain(\"http://example.org/s\");\n-      expect(turtle).toContain(\"http://example.org/p\");\n-      expect(turtle).toContain(\"value\");\n+    test(\"should get first object for subject+predicate\", () => {\n+      const value = getFirstObject(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n+      expect(value).toBe(\"value1\");\n     });\n \n-    test(\"should debug serialize to N-Quads\", async () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n+    test(\"should count quads for subject\", () => {\n+      const count = countQuadsForSubject(store.store, \"http://example.org/s1\");\n+      expect(count).toBe(1);\n+    });\n \n-      const nquads = await debugNQuads(store.store);\n-      expect(nquads).toContain(\"http://example.org/s\");\n-      expect(nquads).toContain(\"http://example.org/p\");\n-      expect(nquads).toContain(\"value\");\n+    test(\"should get quads for subject\", () => {\n+      const quads = getQuadsForSubject(store.store, \"http://example.org/s1\");\n+      expect(quads).toHaveLength(1);\n+      expect(quads[0].subject.value).toBe(\"http://example.org/s1\");\n     });\n   });\n \n+\n   describe(\"Validation utilities\", () => {\n     test(\"should validate IRIs\", () => {\n       expect(validateIRI(\"http://example.org/foo\")).toBe(true);\n       expect(validateIRI(\"not-a-uri\")).toBe(false);\n"
                },
                {
                    "date": 1758656469019,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,599 +1,1 @@\n-/**\n- * @fileoverview unrdf test suite\n- * \n- * Comprehensive tests for the unrdf framework covering all composables,\n- * utilities, and core functionality.\n- * \n- * @version 1.0.0\n- * @author GitVan Team\n- * @license MIT\n- */\n-\n-import { describe, test, expect, beforeEach } from \"vitest\";\n-import { z } from \"zod\";\n-import { \n-  useStore, \n-  useGraph, \n-  useTurtle, \n-  useValidator, \n-  useReasoner, \n-  useCanon, \n-  useZod,\n-  RdfEngine,\n-  asNamedNode,\n-  asLiteral,\n-  asBlankNode,\n-  asString,\n-  getIRI,\n-  smartLiteral,\n-  isNamedNode,\n-  isLiteral,\n-  isBlankNode,\n-  getObjects,\n-  getSubjects,\n-  getPredicates,\n-  isA,\n-  getTypes,\n-  pluck,\n-  indexByPredicate,\n-  getProperties,\n-  hasSubject,\n-  getAllSubjects,\n-  getAllPredicates,\n-  getAllObjects,\n-  findByProperty,\n-  getFirstObject,\n-  countQuadsForSubject,\n-  getQuadsForSubject,\n-  validateIRI,\n-  validateTerm,\n-  validateQuad,\n-  validateStore,\n-  validateRDFConstraints\n-} from \"../src/index.mjs\";\n-\n-describe(\"unrdf\", () => {\n-  describe(\"useStore\", () => {\n-    test(\"should create a new store\", () => {\n-      const store = useStore();\n-      expect(store).toBeDefined();\n-      expect(store.store).toBeDefined();\n-      expect(store.size).toBe(0);\n-    });\n-\n-    test(\"should add quads to store\", () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-      expect(store.size).toBe(1);\n-    });\n-\n-    test(\"should get statistics\", () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-      const stats = store.stats();\n-      expect(stats.quads).toBe(1);\n-      expect(stats.subjects).toBe(1);\n-      expect(stats.predicates).toBe(1);\n-      expect(stats.objects).toBe(1);\n-    });\n-\n-    test(\"should serialize to Turtle\", async () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-      const turtle = await store.serialize();\n-      expect(turtle).toContain(\"http://example.org/s\");\n-      expect(turtle).toContain(\"http://example.org/p\");\n-      expect(turtle).toContain(\"value\");\n-    });\n-  });\n-\n-  describe(\"useGraph\", () => {\n-    let store;\n-    let graph;\n-\n-    beforeEach(() => {\n-      store = useStore();\n-      graph = useGraph(store.store);\n-    });\n-\n-    test(\"should create a graph from store\", () => {\n-      expect(graph).toBeDefined();\n-      expect(graph.store).toBe(store.store);\n-    });\n-\n-    test(\"should execute SPARQL SELECT query\", async () => {\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const results = await graph.select(`\n-        PREFIX ex: <http://example.org/>\n-        SELECT ?s ?p ?o WHERE { ?s ?p ?o }\n-      `);\n-\n-      expect(results).toHaveLength(1);\n-      expect(results[0].s).toBe(\"http://example.org/s\");\n-      expect(results[0].p).toBe(\"http://example.org/p\");\n-      expect(results[0].o).toBe(\"value\");\n-    });\n-\n-    test(\"should execute SPARQL ASK query\", async () => {\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const result = await graph.ask(`\n-        PREFIX ex: <http://example.org/>\n-        ASK { ex:s ex:p ?o }\n-      `);\n-\n-      expect(result).toBe(true);\n-    });\n-\n-    test(\"should get statistics\", () => {\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const stats = graph.stats;\n-      expect(stats.quads).toBe(1);\n-      expect(stats.subjects).toBe(1);\n-      expect(stats.predicates).toBe(1);\n-      expect(stats.objects).toBe(1);\n-    });\n-  });\n-\n-  describe(\"useValidator\", () => {\n-    test(\"should create a validator\", () => {\n-      const validator = useValidator();\n-      expect(validator).toBeDefined();\n-      expect(validator.engine).toBeDefined();\n-    });\n-\n-    test(\"should validate store against SHACL shapes\", async () => {\n-      const validator = useValidator();\n-      const store = useStore();\n-      \n-      // Add some data\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      // Simple SHACL shapes\n-      const shapes = `\n-        @prefix sh: <http://www.w3.org/ns/shacl#> .\n-        @prefix ex: <http://example.org/> .\n-        ex:Shape a sh:NodeShape .\n-      `;\n-\n-      const report = await validator.validate(store.store, shapes);\n-      expect(report).toBeDefined();\n-      expect(report.conforms).toBeDefined();\n-      expect(report.results).toBeDefined();\n-    });\n-  });\n-\n-  describe(\"useReasoner\", () => {\n-    test(\"should create a reasoner\", () => {\n-      const reasoner = useReasoner();\n-      expect(reasoner).toBeDefined();\n-      expect(reasoner.engine).toBeDefined();\n-    });\n-\n-    test(\"should reason over data with rules\", async () => {\n-      const reasoner = useReasoner();\n-      const store = useStore();\n-      \n-      // Add some data\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      // Simple rules\n-      const rules = `\n-        @prefix ex: <http://example.org/> .\n-        { ?s ex:p ?o } => { ?s ex:inferred ?o } .\n-      `;\n-\n-      const inferred = await reasoner.reason(store.store, rules);\n-      expect(inferred).toBeDefined();\n-      expect(inferred.store).toBeDefined();\n-    });\n-  });\n-\n-  describe(\"useCanon\", () => {\n-    test(\"should create a canon\", () => {\n-      const canon = useCanon();\n-      expect(canon).toBeDefined();\n-      expect(canon.engine).toBeDefined();\n-    });\n-\n-    test(\"should canonicalize a store\", async () => {\n-      const canon = useCanon();\n-      const store = useStore();\n-      \n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const canonical = await canon.canonicalize(store.store);\n-      expect(canonical).toBeDefined();\n-      expect(typeof canonical).toBe(\"string\");\n-    });\n-\n-    test(\"should check isomorphism\", async () => {\n-      const canon = useCanon();\n-      const store1 = useStore();\n-      const store2 = useStore();\n-      \n-      const quad1 = store1.quad(\n-        store1.namedNode(\"http://example.org/s\"),\n-        store1.namedNode(\"http://example.org/p\"),\n-        store1.literal(\"value\")\n-      );\n-      store1.add(quad1);\n-\n-      const quad2 = store2.quad(\n-        store2.namedNode(\"http://example.org/s\"),\n-        store2.namedNode(\"http://example.org/p\"),\n-        store2.literal(\"value\")\n-      );\n-      store2.add(quad2);\n-\n-      const isIsomorphic = await canon.isIsomorphic(store1.store, store2.store);\n-      expect(isIsomorphic).toBe(true);\n-    });\n-  });\n-\n-  describe(\"useZod\", () => {\n-    test(\"should create a zod validator\", () => {\n-      const zod = useZod();\n-      expect(zod).toBeDefined();\n-    });\n-\n-    test(\"should validate SPARQL results\", async () => {\n-      const zod = useZod();\n-      const results = [\n-        { id: \"http://example.org/1\", name: \"John\", age: 30 },\n-        { id: \"http://example.org/2\", name: \"Jane\", age: 25 }\n-      ];\n-\n-      const PersonSchema = z.object({\n-        id: z.string().url(),\n-        name: z.string(),\n-        age: z.number().int().min(0)\n-      });\n-\n-      const validation = await zod.validateResults(results, PersonSchema);\n-      expect(validation.validated).toHaveLength(2);\n-      expect(validation.errors).toHaveLength(0);\n-    });\n-  });\n-\n-  describe(\"RdfEngine\", () => {\n-    test(\"should create an RDF engine\", () => {\n-      const engine = new RdfEngine();\n-      expect(engine).toBeDefined();\n-      expect(engine.baseIRI).toBe(\"http://example.org/\");\n-      expect(engine.deterministic).toBe(true);\n-    });\n-\n-    test(\"should parse Turtle\", () => {\n-      const engine = new RdfEngine();\n-      const turtle = `\n-        @prefix ex: <http://example.org/> .\n-        ex:s ex:p ex:o .\n-      `;\n-      \n-      const store = engine.parseTurtle(turtle);\n-      expect(store.size).toBe(1);\n-    });\n-\n-    test(\"should serialize to Turtle\", async () => {\n-      const engine = new RdfEngine();\n-      const store = engine.createStore();\n-      const quad = engine.quad(\n-        engine.namedNode(\"http://example.org/s\"),\n-        engine.namedNode(\"http://example.org/p\"),\n-        engine.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const turtle = await engine.serializeTurtle(store);\n-      expect(turtle).toContain(\"http://example.org/s\");\n-      expect(turtle).toContain(\"http://example.org/p\");\n-      expect(turtle).toContain(\"value\");\n-    });\n-  });\n-\n-  describe(\"Term utilities\", () => {\n-    test(\"should create named nodes\", () => {\n-      const node = asNamedNode(\"http://example.org/foo\");\n-      expect(node.termType).toBe(\"NamedNode\");\n-      expect(node.value).toBe(\"http://example.org/foo\");\n-    });\n-\n-    test(\"should create literals\", () => {\n-      const lit = asLiteral(\"hello\");\n-      expect(lit.termType).toBe(\"Literal\");\n-      expect(lit.value).toBe(\"hello\");\n-    });\n-\n-    test(\"should create blank nodes\", () => {\n-      const bnode = asBlankNode(\"test123\");\n-      expect(bnode.termType).toBe(\"BlankNode\");\n-      expect(bnode.value).toBe(\"test123\");\n-    });\n-\n-    test(\"should convert terms to strings\", () => {\n-      const node = asNamedNode(\"http://example.org/foo\");\n-      const lit = asLiteral(\"hello\");\n-      \n-      expect(asString(node)).toBe(\"http://example.org/foo\");\n-      expect(asString(lit)).toBe(\"hello\");\n-      expect(asString(\"plain string\")).toBe(\"plain string\");\n-    });\n-\n-    test(\"should get IRI from terms\", () => {\n-      const node = asNamedNode(\"http://example.org/foo\");\n-      \n-      expect(getIRI(node)).toBe(\"http://example.org/foo\");\n-      expect(getIRI(\"http://example.org/bar\")).toBe(\"http://example.org/bar\");\n-    });\n-\n-    test(\"should create smart literals\", () => {\n-      const stringLit = smartLiteral(\"hello\");\n-      const numberLit = smartLiteral(42);\n-      const booleanLit = smartLiteral(true);\n-      const dateLit = smartLiteral(new Date(\"2023-01-01\"));\n-\n-      expect(stringLit.termType).toBe(\"Literal\");\n-      expect(stringLit.value).toBe(\"hello\");\n-      expect(stringLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#string\");\n-\n-      expect(numberLit.value).toBe(\"42\");\n-      expect(numberLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#decimal\");\n-\n-      expect(booleanLit.value).toBe(\"true\");\n-      expect(booleanLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#boolean\");\n-\n-      expect(dateLit.value).toBe(\"2023-01-01T00:00:00.000Z\");\n-      expect(dateLit.datatype.value).toBe(\"http://www.w3.org/2001/XMLSchema#dateTime\");\n-    });\n-\n-    test(\"should check term types\", () => {\n-      const node = asNamedNode(\"http://example.org/foo\");\n-      const lit = asLiteral(\"hello\");\n-      const bnode = asBlankNode(\"test\");\n-\n-      expect(isNamedNode(node)).toBe(true);\n-      expect(isNamedNode(lit)).toBe(false);\n-\n-      expect(isLiteral(lit)).toBe(true);\n-      expect(isLiteral(node)).toBe(false);\n-\n-      expect(isBlankNode(bnode)).toBe(true);\n-      expect(isBlankNode(node)).toBe(false);\n-    });\n-  });\n-\n-  describe(\"Graph utilities\", () => {\n-    let store;\n-\n-    beforeEach(() => {\n-      store = useStore();\n-      const quad1 = store.quad(\n-        store.namedNode(\"http://example.org/s1\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value1\")\n-      );\n-      const quad2 = store.quad(\n-        store.namedNode(\"http://example.org/s2\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value2\")\n-      );\n-      store.add(quad1, quad2);\n-    });\n-\n-    test(\"should get objects for subject+predicate\", () => {\n-      const objects = getObjects(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n-      expect(objects).toHaveLength(1);\n-      expect(objects[0].value).toBe(\"value1\");\n-    });\n-\n-    test(\"should get subjects for predicate+object\", () => {\n-      const subjects = getSubjects(store.store, \"http://example.org/p\", \"value1\");\n-      expect(subjects).toHaveLength(1);\n-      expect(subjects[0].value).toBe(\"http://example.org/s1\");\n-    });\n-\n-    test(\"should get predicates for subject+object\", () => {\n-      const predicates = getPredicates(store.store, \"http://example.org/s1\", \"value1\");\n-      expect(predicates).toHaveLength(1);\n-      expect(predicates[0].value).toBe(\"http://example.org/p\");\n-    });\n-\n-    test(\"should check if subject has type\", () => {\n-      const typeQuad = store.quad(\n-        store.namedNode(\"http://example.org/s1\"),\n-        store.namedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"),\n-        store.namedNode(\"http://example.org/Type\")\n-      );\n-      store.add(typeQuad);\n-\n-      const hasTypeResult = isA(store.store, \"http://example.org/s1\", \"http://example.org/Type\");\n-      expect(hasTypeResult).toBe(true);\n-    });\n-\n-    test(\"should get types for subject\", () => {\n-      const typeQuad = store.quad(\n-        store.namedNode(\"http://example.org/s1\"),\n-        store.namedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"),\n-        store.namedNode(\"http://example.org/Type\")\n-      );\n-      store.add(typeQuad);\n-\n-      const types = getTypes(store.store, \"http://example.org/s1\");\n-      expect(types).toHaveLength(1);\n-      expect(types[0]).toBe(\"http://example.org/Type\");\n-    });\n-\n-    test(\"should pluck by predicate\", () => {\n-      const quads = pluck(store.store, \"http://example.org/p\");\n-      expect(quads).toHaveLength(2);\n-    });\n-\n-    test(\"should index by predicate\", () => {\n-      const index = indexByPredicate(store.store, \"http://example.org/p\");\n-      expect(index.size).toBe(2);\n-      expect(index.get(\"http://example.org/s1\")).toContain(\"value1\");\n-      expect(index.get(\"http://example.org/s2\")).toContain(\"value2\");\n-    });\n-\n-    test(\"should get properties for subject\", () => {\n-      const properties = getProperties(store.store, \"http://example.org/s1\");\n-      expect(properties.size).toBe(1);\n-      expect(properties.get(\"http://example.org/p\")).toContain(\"value1\");\n-    });\n-\n-    test(\"should check if subject exists\", () => {\n-      expect(hasSubject(store.store, \"http://example.org/s1\")).toBe(true);\n-      expect(hasSubject(store.store, \"http://example.org/nonexistent\")).toBe(false);\n-    });\n-\n-    test(\"should get all subjects\", () => {\n-      const subjects = getAllSubjects(store.store);\n-      expect(subjects).toHaveLength(2);\n-      expect(subjects).toContain(\"http://example.org/s1\");\n-      expect(subjects).toContain(\"http://example.org/s2\");\n-    });\n-\n-    test(\"should get all predicates\", () => {\n-      const predicates = getAllPredicates(store.store);\n-      expect(predicates).toHaveLength(1);\n-      expect(predicates[0]).toBe(\"http://example.org/p\");\n-    });\n-\n-    test(\"should get all objects\", () => {\n-      const objects = getAllObjects(store.store);\n-      expect(objects).toHaveLength(2);\n-      expect(objects).toContain(\"value1\");\n-      expect(objects).toContain(\"value2\");\n-    });\n-\n-    test(\"should find subjects by property value\", () => {\n-      const subjects = findByProperty(store.store, \"http://example.org/p\", \"value1\");\n-      expect(subjects).toHaveLength(1);\n-      expect(subjects[0]).toBe(\"http://example.org/s1\");\n-    });\n-\n-    test(\"should get first object for subject+predicate\", () => {\n-      const value = getFirstObject(store.store, \"http://example.org/s1\", \"http://example.org/p\");\n-      expect(value).toBe(\"value1\");\n-    });\n-\n-    test(\"should count quads for subject\", () => {\n-      const count = countQuadsForSubject(store.store, \"http://example.org/s1\");\n-      expect(count).toBe(1);\n-    });\n-\n-    test(\"should get quads for subject\", () => {\n-      const quads = getQuadsForSubject(store.store, \"http://example.org/s1\");\n-      expect(quads).toHaveLength(1);\n-      expect(quads[0].subject.value).toBe(\"http://example.org/s1\");\n-    });\n-  });\n-\n-\n-  describe(\"Validation utilities\", () => {\n-    test(\"should validate IRIs\", () => {\n-      expect(validateIRI(\"http://example.org/foo\")).toBe(true);\n-      expect(validateIRI(\"not-a-uri\")).toBe(false);\n-    });\n-\n-    test(\"should validate terms\", () => {\n-      const validTerm = { termType: \"NamedNode\", value: \"http://example.org/foo\" };\n-      const invalidTerm = { termType: \"Invalid\", value: \"foo\" };\n-      \n-      expect(validateTerm(validTerm)).toBe(true);\n-      expect(validateTerm(invalidTerm)).toBe(false);\n-    });\n-\n-    test(\"should validate quads\", () => {\n-      const validQuad = {\n-        subject: { termType: \"NamedNode\", value: \"http://example.org/s\" },\n-        predicate: { termType: \"NamedNode\", value: \"http://example.org/p\" },\n-        object: { termType: \"Literal\", value: \"value\" }\n-      };\n-      const invalidQuad = {\n-        subject: { termType: \"Invalid\", value: \"s\" },\n-        predicate: { termType: \"NamedNode\", value: \"http://example.org/p\" },\n-        object: { termType: \"Literal\", value: \"value\" }\n-      };\n-      \n-      expect(validateQuad(validQuad)).toBe(true);\n-      expect(validateQuad(invalidQuad)).toBe(false);\n-    });\n-\n-    test(\"should validate store\", () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const result = validateStore(store.store);\n-      expect(result.valid).toBe(true);\n-      expect(result.issues).toHaveLength(0);\n-    });\n-\n-    test(\"should validate RDF constraints\", () => {\n-      const store = useStore();\n-      const quad = store.quad(\n-        store.namedNode(\"http://example.org/s\"),\n-        store.namedNode(\"http://example.org/p\"),\n-        store.literal(\"value\")\n-      );\n-      store.add(quad);\n-\n-      const result = validateRDFConstraints(store.store);\n-      expect(result.valid).toBe(true);\n-      expect(result.violations).toHaveLength(0);\n-    });\n-  });\n-});\n+ \n\\ No newline at end of file\n"
                }
            ],
            "date": 1758655166536,
            "name": "Commit-0",
            "content": "import { describe, expect, it } from \"vitest\";\nimport { test } from \"../src/index.mjs\";\n\n/**\n * Test suite for the main package functionality\n */\ndescribe(\"packageName\", () => {\n  /**\n   * Test that the test function works correctly\n   */\n  it(\"should return 'works!' from test function\", () => {\n    expect(test()).toBe(\"works!\");\n  });\n});\n"
        }
    ]
}