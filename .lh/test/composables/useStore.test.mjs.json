{
    "sourceFile": "test/composables/useStore.test.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656505418,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656505418,
            "name": "Commit-0",
            "content": "import { describe, expect, it, beforeEach } from \"vitest\";\n\n/**\n * @fileoverview Tests for useStore composable\n * \n * Tests the core store management functionality using London School of TDD\n */\n\ndescribe(\"useStore\", () => {\n  let useStore;\n  \n  beforeEach(() => {\n    // Reset the composable for each test\n    useStore = null;\n  });\n\n  it(\"should create a new N3 store when called\", () => {\n    // Arrange - minimal setup\n    const { Store } = require(\"n3\");\n    \n    // Act - call the composable\n    useStore = () => {\n      return {\n        store: new Store(),\n        add: (quads) => quads.forEach(q => useStore.store.add(q)),\n        remove: (quads) => quads.forEach(q => useStore.store.delete(q)),\n        clear: () => {\n          // N3 Store doesn't have clear(), so we remove all quads\n          const quads = [...useStore.store];\n          for (const quad of quads) {\n            useStore.store.delete(quad);\n          }\n        },\n        stats: () => ({ quads: useStore.store.size }),\n        serialize: ({ format = \"Turtle\" }) => format\n      };\n    };\n    \n    const result = useStore();\n    \n    // Assert - verify the store is created\n    expect(result.store).toBeDefined();\n    expect(result.store.size).toBe(0);\n    expect(typeof result.add).toBe(\"function\");\n    expect(typeof result.remove).toBe(\"function\");\n    expect(typeof result.clear).toBe(\"function\");\n    expect(typeof result.stats).toBe(\"function\");\n    expect(typeof result.serialize).toBe(\"function\");\n  });\n\n  it(\"should add quads to the store\", () => {\n    // Arrange\n    const { Store, DataFactory } = require(\"n3\");\n    const { namedNode, literal, quad } = DataFactory;\n    \n    useStore = () => {\n      const store = new Store();\n      return {\n        store,\n        add: (quads) => quads.forEach(q => store.add(q)),\n        remove: (quads) => quads.forEach(q => store.delete(q)),\n        clear: () => {\n          // N3 Store doesn't have clear(), so we remove all quads\n          const quads = [...store];\n          for (const quad of quads) {\n            store.delete(quad);\n          }\n        },\n        stats: () => ({ quads: store.size }),\n        serialize: ({ format = \"Turtle\" }) => format\n      };\n    };\n    \n    const storeComposable = useStore();\n    const testQuad = quad(\n      namedNode(\"http://example.org/subject\"),\n      namedNode(\"http://example.org/predicate\"),\n      literal(\"object\")\n    );\n    \n    // Act\n    storeComposable.add([testQuad]);\n    \n    // Assert\n    expect(storeComposable.stats().quads).toBe(1);\n    expect(storeComposable.store.has(testQuad)).toBe(true);\n  });\n\n  it(\"should remove quads from the store\", () => {\n    // Arrange\n    const { Store, DataFactory } = require(\"n3\");\n    const { namedNode, literal, quad } = DataFactory;\n    \n    useStore = () => {\n      const store = new Store();\n      return {\n        store,\n        add: (quads) => quads.forEach(q => store.add(q)),\n        remove: (quads) => quads.forEach(q => store.delete(q)),\n        clear: () => {\n          // N3 Store doesn't have clear(), so we remove all quads\n          const quads = [...store];\n          for (const quad of quads) {\n            store.delete(quad);\n          }\n        },\n        stats: () => ({ quads: store.size }),\n        serialize: ({ format = \"Turtle\" }) => format\n      };\n    };\n    \n    const storeComposable = useStore();\n    const testQuad = quad(\n      namedNode(\"http://example.org/subject\"),\n      namedNode(\"http://example.org/predicate\"),\n      literal(\"object\")\n    );\n    \n    // Act\n    storeComposable.add([testQuad]);\n    expect(storeComposable.stats().quads).toBe(1);\n    \n    storeComposable.remove([testQuad]);\n    \n    // Assert\n    expect(storeComposable.stats().quads).toBe(0);\n    expect(storeComposable.store.has(testQuad)).toBe(false);\n  });\n\n  it(\"should clear all quads from the store\", () => {\n    // Arrange\n    const { Store, DataFactory } = require(\"n3\");\n    const { namedNode, literal, quad } = DataFactory;\n    \n    useStore = () => {\n      const store = new Store();\n      return {\n        store,\n        add: (quads) => quads.forEach(q => store.add(q)),\n        remove: (quads) => quads.forEach(q => store.delete(q)),\n        clear: () => {\n          // N3 Store doesn't have clear(), so we remove all quads\n          const quads = [...store];\n          for (const quad of quads) {\n            store.delete(quad);\n          }\n        },\n        stats: () => ({ quads: store.size }),\n        serialize: ({ format = \"Turtle\" }) => format\n      };\n    };\n    \n    const storeComposable = useStore();\n    const testQuads = [\n      quad(namedNode(\"http://example.org/s1\"), namedNode(\"http://example.org/p1\"), literal(\"o1\")),\n      quad(namedNode(\"http://example.org/s2\"), namedNode(\"http://example.org/p2\"), literal(\"o2\"))\n    ];\n    \n    // Act\n    storeComposable.add(testQuads);\n    expect(storeComposable.stats().quads).toBe(2);\n    \n    storeComposable.clear();\n    \n    // Assert\n    expect(storeComposable.stats().quads).toBe(0);\n  });\n});\n"
        }
    ]
}