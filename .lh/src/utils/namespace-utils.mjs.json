{
    "sourceFile": "src/utils/namespace-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758658176143,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758658176143,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview Namespace utilities - RDF vocabulary and namespace management\n * \n * These utilities provide comprehensive namespace management, vocabulary handling,\n * and prefix management for RDF operations.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { DataFactory } from \"n3\";\nimport { asNamedNode, createNamespaceId } from \"./term-utils.mjs\";\n\nconst { namedNode } = DataFactory;\n\n/**\n * Common RDF vocabularies and their namespaces\n */\nexport const COMMON_VOCABULARIES = {\n  // Core RDF vocabularies\n  RDF: \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\",\n  RDFS: \"http://www.w3.org/2000/01/rdf-schema#\",\n  OWL: \"http://www.w3.org/2002/07/owl#\",\n  XSD: \"http://www.w3.org/2001/XMLSchema#\",\n  \n  // Dublin Core\n  DC: \"http://purl.org/dc/elements/1.1/\",\n  DCTERMS: \"http://purl.org/dc/terms/\",\n  \n  // FOAF\n  FOAF: \"http://xmlns.com/foaf/0.1/\",\n  \n  // SKOS\n  SKOS: \"http://www.w3.org/2004/02/skos/core#\",\n  \n  // Schema.org\n  SCHEMA: \"https://schema.org/\",\n  \n  // PROV\n  PROV: \"http://www.w3.org/ns/prov#\",\n  \n  // SHACL\n  SHACL: \"http://www.w3.org/ns/shacl#\",\n  \n  // Time\n  TIME: \"http://www.w3.org/2006/time#\",\n  \n  // Geo\n  GEO: \"http://www.opengis.net/ont/geosparql#\",\n  WGS84: \"http://www.w3.org/2003/01/geo/wgs84_pos#\",\n  \n  // Creative Commons\n  CC: \"http://creativecommons.org/ns#\",\n  \n  // DOAP\n  DOAP: \"http://usefulinc.com/ns/doap#\",\n  \n  // VCard\n  VCARD: \"http://www.w3.org/2006/vcard/ns#\"\n};\n\n/**\n * Common prefixes for serialization\n */\nexport const COMMON_PREFIXES = {\n  rdf: COMMON_VOCABULARIES.RDF,\n  rdfs: COMMON_VOCABULARIES.RDFS,\n  owl: COMMON_VOCABULARIES.OWL,\n  xsd: COMMON_VOCABULARIES.XSD,\n  dc: COMMON_VOCABULARIES.DC,\n  dcterms: COMMON_VOCABULARIES.DCTERMS,\n  foaf: COMMON_VOCABULARIES.FOAF,\n  skos: COMMON_VOCABULARIES.SKOS,\n  schema: COMMON_VOCABULARIES.SCHEMA,\n  prov: COMMON_VOCABULARIES.PROV,\n  sh: COMMON_VOCABULARIES.SHACL,\n  time: COMMON_VOCABULARIES.TIME,\n  geo: COMMON_VOCABULARIES.GEO,\n  wgs84: COMMON_VOCABULARIES.WGS84,\n  cc: COMMON_VOCABULARIES.CC,\n  doap: COMMON_VOCABULARIES.DOAP,\n  vcard: COMMON_VOCABULARIES.VCARD\n};\n\n/**\n * Namespace manager class\n */\nexport class NamespaceManager {\n  constructor() {\n    this.namespaces = new Map();\n    this.prefixes = new Map();\n    this.reverseLookup = new Map();\n    \n    // Initialize with common vocabularies\n    this.addCommonVocabularies();\n  }\n  \n  /**\n   * Add common vocabularies to the manager\n   */\n  addCommonVocabularies() {\n    for (const [prefix, namespace] of Object.entries(COMMON_PREFIXES)) {\n      this.addNamespace(prefix, namespace);\n    }\n  }\n  \n  /**\n   * Add a namespace with a prefix\n   * @param {string} prefix - The prefix (e.g., 'foaf')\n   * @param {string} namespace - The namespace URI (e.g., 'http://xmlns.com/foaf/0.1/')\n   */\n  addNamespace(prefix, namespace) {\n    // Ensure namespace ends with # or /\n    const normalizedNamespace = namespace.endsWith('#') || namespace.endsWith('/') \n      ? namespace \n      : `${namespace}#`;\n    \n    this.namespaces.set(prefix, normalizedNamespace);\n    this.prefixes.set(normalizedNamespace, prefix);\n    this.reverseLookup.set(normalizedNamespace, prefix);\n  }\n  \n  /**\n   * Get namespace for a prefix\n   * @param {string} prefix - The prefix\n   * @returns {string|null} The namespace URI or null if not found\n   */\n  getNamespace(prefix) {\n    return this.namespaces.get(prefix) || null;\n  }\n  \n  /**\n   * Get prefix for a namespace\n   * @param {string} namespace - The namespace URI\n   * @returns {string|null} The prefix or null if not found\n   */\n  getPrefix(namespace) {\n    return this.prefixes.get(namespace) || null;\n  }\n  \n  /**\n   * Create a named node using a prefix and local name\n   * @param {string} prefix - The prefix\n   * @param {string} localName - The local name\n   * @returns {import('n3').NamedNode} The named node\n   */\n  createNamedNode(prefix, localName) {\n    const namespace = this.getNamespace(prefix);\n    if (!namespace) {\n      throw new Error(`Unknown prefix: ${prefix}`);\n    }\n    return namedNode(createNamespaceId(namespace, localName));\n  }\n  \n  /**\n   * Expand a prefixed IRI to full IRI\n   * @param {string} prefixedIRI - The prefixed IRI (e.g., 'foaf:name')\n   * @returns {string} The full IRI\n   */\n  expandIRI(prefixedIRI) {\n    const [prefix, localName] = prefixedIRI.split(':');\n    if (!localName) {\n      return prefixedIRI; // Not a prefixed IRI\n    }\n    \n    const namespace = this.getNamespace(prefix);\n    if (!namespace) {\n      throw new Error(`Unknown prefix: ${prefix}`);\n    }\n    \n    return createNamespaceId(namespace, localName);\n  }\n  \n  /**\n   * Contract a full IRI to prefixed form\n   * @param {string} fullIRI - The full IRI\n   * @returns {string} The prefixed IRI or original if no prefix found\n   */\n  contractIRI(fullIRI) {\n    for (const [namespace, prefix] of this.prefixes.entries()) {\n      if (fullIRI.startsWith(namespace)) {\n        const localName = fullIRI.substring(namespace.length);\n        return `${prefix}:${localName}`;\n      }\n    }\n    return fullIRI;\n  }\n  \n  /**\n   * Get all registered prefixes\n   * @returns {string[]} Array of prefixes\n   */\n  getPrefixes() {\n    return [...this.namespaces.keys()];\n  }\n  \n  /**\n   * Get all registered namespaces\n   * @returns {string[]} Array of namespace URIs\n   */\n  getNamespaces() {\n    return [...this.namespaces.values()];\n  }\n  \n  /**\n   * Export prefixes for serialization\n   * @returns {Object} Object with prefix mappings\n   */\n  exportPrefixes() {\n    const result = {};\n    for (const [prefix, namespace] of this.namespaces.entries()) {\n      result[prefix] = namespace;\n    }\n    return result;\n  }\n  \n  /**\n   * Import prefixes from an object\n   * @param {Object} prefixes - Object with prefix mappings\n   */\n  importPrefixes(prefixes) {\n    for (const [prefix, namespace] of Object.entries(prefixes)) {\n      this.addNamespace(prefix, namespace);\n    }\n  }\n  \n  /**\n   * Clear all namespaces\n   */\n  clear() {\n    this.namespaces.clear();\n    this.prefixes.clear();\n    this.reverseLookup.clear();\n  }\n  \n  /**\n   * Remove a namespace\n   * @param {string} prefix - The prefix to remove\n   */\n  removeNamespace(prefix) {\n    const namespace = this.namespaces.get(prefix);\n    if (namespace) {\n      this.namespaces.delete(prefix);\n      this.prefixes.delete(namespace);\n      this.reverseLookup.delete(namespace);\n    }\n  }\n}\n\n/**\n * Create a new namespace manager\n * @returns {NamespaceManager} New namespace manager instance\n */\nexport const createNamespaceManager = () => new NamespaceManager();\n\n/**\n * Get a named node using common vocabulary\n * @param {string} vocabulary - The vocabulary key (e.g., 'FOAF')\n * @param {string} localName - The local name\n * @returns {import('n3').NamedNode} The named node\n */\nexport const getVocabularyTerm = (vocabulary, localName) => {\n  const namespace = COMMON_VOCABULARIES[vocabulary.toUpperCase()];\n  if (!namespace) {\n    throw new Error(`Unknown vocabulary: ${vocabulary}`);\n  }\n  return namedNode(createNamespaceId(namespace, localName));\n};\n\n/**\n * Check if an IRI belongs to a known vocabulary\n * @param {string} iri - The IRI to check\n * @returns {string|null} The vocabulary name or null if not found\n */\nexport const getVocabularyForIRI = (iri) => {\n  for (const [vocab, namespace] of Object.entries(COMMON_VOCABULARIES)) {\n    if (iri.startsWith(namespace)) {\n      return vocab;\n    }\n  }\n  return null;\n};\n\n/**\n * Get vocabulary statistics from a store\n * @param {import('n3').Store} store - The RDF store\n * @returns {Object} Statistics about vocabulary usage\n */\nexport const getVocabularyStats = (store) => {\n  const stats = {};\n  const vocabularies = new Set();\n  \n  for (const quad of store) {\n    // Check subject\n    const subjectVocab = getVocabularyForIRI(quad.subject.value);\n    if (subjectVocab) {\n      vocabularies.add(subjectVocab);\n      stats[subjectVocab] = (stats[subjectVocab] || 0) + 1;\n    }\n    \n    // Check predicate\n    const predicateVocab = getVocabularyForIRI(quad.predicate.value);\n    if (predicateVocab) {\n      vocabularies.add(predicateVocab);\n      stats[predicateVocab] = (stats[predicateVocab] || 0) + 1;\n    }\n    \n    // Check object if it's a named node\n    if (quad.object.termType === \"NamedNode\") {\n      const objectVocab = getVocabularyForIRI(quad.object.value);\n      if (objectVocab) {\n        vocabularies.add(objectVocab);\n        stats[objectVocab] = (stats[objectVocab] || 0) + 1;\n      }\n    }\n  }\n  \n  return {\n    vocabularies: [...vocabularies],\n    usage: stats,\n    totalVocabularies: vocabularies.size\n  };\n};\n\n/**\n * Validate namespace consistency in a store\n * @param {import('n3').Store} store - The RDF store\n * @returns {Object} Validation result\n */\nexport const validateNamespaces = (store) => {\n  const issues = [];\n  const usedNamespaces = new Set();\n  const unknownNamespaces = new Set();\n  \n  for (const quad of store) {\n    const terms = [quad.subject, quad.predicate, quad.object];\n    if (quad.graph) terms.push(quad.graph);\n    \n    for (const term of terms) {\n      if (term.termType === \"NamedNode\") {\n        const iri = term.value;\n        const vocab = getVocabularyForIRI(iri);\n        \n        if (vocab) {\n          usedNamespaces.add(vocab);\n        } else {\n          // Extract namespace from IRI\n          const hashIndex = iri.lastIndexOf('#');\n          const slashIndex = iri.lastIndexOf('/');\n          const index = Math.max(hashIndex, slashIndex);\n          \n          if (index > 0) {\n            const namespace = iri.substring(0, index + 1);\n            unknownNamespaces.add(namespace);\n          }\n        }\n      }\n    }\n  }\n  \n  return {\n    valid: unknownNamespaces.size === 0,\n    usedVocabularies: [...usedNamespaces],\n    unknownNamespaces: [...unknownNamespaces],\n    issueCount: unknownNamespaces.size\n  };\n};\n\n/**\n * Generate Turtle prefix declarations\n * @param {Object} prefixes - Prefix mappings\n * @returns {string} Turtle prefix declarations\n */\nexport const generateTurtlePrefixes = (prefixes) => {\n  const lines = [];\n  for (const [prefix, namespace] of Object.entries(prefixes)) {\n    lines.push(`@prefix ${prefix}: <${namespace}> .`);\n  }\n  return lines.join('\\n') + '\\n';\n};\n\n/**\n * Generate SPARQL prefix declarations\n * @param {Object} prefixes - Prefix mappings\n * @returns {string} SPARQL prefix declarations\n */\nexport const generateSPARQLPrefixes = (prefixes) => {\n  const lines = [];\n  for (const [prefix, namespace] of Object.entries(prefixes)) {\n    lines.push(`PREFIX ${prefix}: <${namespace}>`);\n  }\n  return lines.join('\\n') + '\\n';\n};\n"
        }
    ]
}