{
    "sourceFile": "src/utils/term-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758655862893,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758655862893,
            "name": "Commit-0",
            "content": "import { DataFactory } from \"n3\";\n\nconst { namedNode, literal, blankNode } = DataFactory;\n\n/**\n * Ensure any input is a NamedNode\n * @param {string|import('n3').NamedNode} iri - IRI string or NamedNode\n * @returns {import('n3').NamedNode} NamedNode instance\n */\nexport const asNamedNode = (iri) =>\n  iri?.termType === \"NamedNode\" ? iri : namedNode(String(iri));\n\n/**\n * Ensure any input is a Literal\n * @param {string|number|boolean} value - The literal value\n * @param {string} [datatype=\"http://www.w3.org/2001/XMLSchema#string\"] - The datatype IRI\n * @returns {import('n3').Literal} Literal instance\n */\nexport const asLiteral = (value, datatype = \"http://www.w3.org/2001/XMLSchema#string\") =>\n  literal(String(value), datatype);\n\n/**\n * Ensure any input is a BlankNode\n * @param {string} [id] - Optional blank node identifier\n * @returns {import('n3').BlankNode} BlankNode instance\n */\nexport const asBlankNode = (id) => blankNode(id);\n\n/**\n * Safe string coercion from RDF terms\n * @param {import('n3').Term|string} term - RDF term or string\n * @returns {string} String representation\n */\nexport const asString = (term) =>\n  term?.termType === \"Literal\" ? term.value : term?.value || String(term);\n\n/**\n * Check if a term is a NamedNode\n * @param {import('n3').Term} term - RDF term to check\n * @returns {boolean} True if term is a NamedNode\n */\nexport const isNamedNode = (term) => term?.termType === \"NamedNode\";\n\n/**\n * Check if a term is a Literal\n * @param {import('n3').Term} term - RDF term to check\n * @returns {boolean} True if term is a Literal\n */\nexport const isLiteral = (term) => term?.termType === \"Literal\";\n\n/**\n * Check if a term is a BlankNode\n * @param {import('n3').Term} term - RDF term to check\n * @returns {boolean} True if term is a BlankNode\n */\nexport const isBlankNode = (term) => term?.termType === \"BlankNode\";\n\n/**\n * Get the IRI value from a NamedNode, or return the input if already a string\n * @param {string|import('n3').NamedNode} term - IRI string or NamedNode\n * @returns {string} IRI string\n */\nexport const getIRI = (term) => \n  term?.termType === \"NamedNode\" ? term.value : String(term);\n\n/**\n * Create a literal with appropriate datatype based on value type\n * @param {any} value - The value to convert to literal\n * @returns {import('n3').Literal} Literal with appropriate datatype\n */\nexport const smartLiteral = (value) => {\n  if (typeof value === \"boolean\") {\n    return literal(String(value), \"http://www.w3.org/2001/XMLSchema#boolean\");\n  }\n  if (typeof value === \"number\") {\n    return literal(String(value), \"http://www.w3.org/2001/XMLSchema#decimal\");\n  }\n  if (value instanceof Date) {\n    return literal(value.toISOString(), \"http://www.w3.org/2001/XMLSchema#dateTime\");\n  }\n  return asLiteral(value);\n};"
        }
    ]
}