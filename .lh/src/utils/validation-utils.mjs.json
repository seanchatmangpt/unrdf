{
    "sourceFile": "src/utils/validation-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758655862894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758655862894,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview Validation utilities - RDF validation helpers\n * \n * These utilities cover the 80/20 dark matter of RDF validation\n * that every project ends up reimplementing.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { z } from \"zod\";\nimport { asNamedNode } from \"./term-utils.mjs\";\n\n/**\n * Zod schema for validating RDF IRIs\n */\nexport const IRISchema = z.string().url();\n\n/**\n * Zod schema for validating RDF literals\n */\nexport const LiteralSchema = z.object({\n  termType: z.literal(\"Literal\"),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});\n\n/**\n * Zod schema for validating RDF named nodes\n */\nexport const NamedNodeSchema = z.object({\n  termType: z.literal(\"NamedNode\"),\n  value: z.string().url(),\n});\n\n/**\n * Zod schema for validating RDF blank nodes\n */\nexport const BlankNodeSchema = z.object({\n  termType: z.literal(\"BlankNode\"),\n  value: z.string(),\n});\n\n/**\n * Zod schema for validating RDF terms\n */\nexport const TermSchema = z.union([LiteralSchema, NamedNodeSchema, BlankNodeSchema]);\n\n/**\n * Zod schema for validating RDF quads\n */\nexport const QuadSchema = z.object({\n  subject: TermSchema,\n  predicate: NamedNodeSchema,\n  object: TermSchema,\n  graph: TermSchema.optional(),\n});\n\n/**\n * Validate an RDF IRI\n * @param {string} iri - IRI to validate\n * @returns {boolean} True if valid IRI\n * \n * @example\n * const isValid = validateIRI(\"http://example.org/foo\");\n */\nexport function validateIRI(iri) {\n  try {\n    IRISchema.parse(iri);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an RDF literal\n * @param {Object} literal - Literal to validate\n * @returns {boolean} True if valid literal\n * \n * @example\n * const isValid = validateLiteral({ termType: \"Literal\", value: \"hello\" });\n */\nexport function validateLiteral(literal) {\n  try {\n    LiteralSchema.parse(literal);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an RDF named node\n * @param {Object} namedNode - Named node to validate\n * @returns {boolean} True if valid named node\n * \n * @example\n * const isValid = validateNamedNode({ termType: \"NamedNode\", value: \"http://example.org/foo\" });\n */\nexport function validateNamedNode(namedNode) {\n  try {\n    NamedNodeSchema.parse(namedNode);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an RDF blank node\n * @param {Object} blankNode - Blank node to validate\n * @returns {boolean} True if valid blank node\n * \n * @example\n * const isValid = validateBlankNode({ termType: \"BlankNode\", value: \"_:b1\" });\n */\nexport function validateBlankNode(blankNode) {\n  try {\n    BlankNodeSchema.parse(blankNode);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an RDF term\n * @param {Object} term - Term to validate\n * @returns {boolean} True if valid term\n * \n * @example\n * const isValid = validateTerm({ termType: \"NamedNode\", value: \"http://example.org/foo\" });\n */\nexport function validateTerm(term) {\n  try {\n    TermSchema.parse(term);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an RDF quad\n * @param {Object} quad - Quad to validate\n * @returns {boolean} True if valid quad\n * \n * @example\n * const isValid = validateQuad({\n *   subject: { termType: \"NamedNode\", value: \"http://example.org/s\" },\n *   predicate: { termType: \"NamedNode\", value: \"http://example.org/p\" },\n *   object: { termType: \"Literal\", value: \"hello\" }\n * });\n */\nexport function validateQuad(quad) {\n  try {\n    QuadSchema.parse(quad);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate a Turtle string\n * @param {string} turtle - Turtle string to validate\n * @param {Object} [options] - Validation options\n * @param {string} [options.baseIRI] - Base IRI for parsing\n * @returns {Promise<boolean>} True if valid Turtle\n * \n * @example\n * const isValid = await validateTurtle(\"@prefix ex: <http://example.org/> . ex:foo a ex:Bar .\");\n */\nexport async function validateTurtle(turtle, options = {}) {\n  try {\n    const { RdfEngine } = await import(\"../engines/RdfEngine.mjs\");\n    const engine = new RdfEngine();\n    engine.parseTurtle(turtle, options);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate an N-Quads string\n * @param {string} nquads - N-Quads string to validate\n * @returns {Promise<boolean>} True if valid N-Quads\n * \n * @example\n * const isValid = await validateNQuads(\"<http://example.org/s> <http://example.org/p> <http://example.org/o> .\");\n */\nexport async function validateNQuads(nquads) {\n  try {\n    const { RdfEngine } = await import(\"../engines/RdfEngine.mjs\");\n    const engine = new RdfEngine();\n    engine.parseNQuads(nquads);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate a JSON-LD document\n * @param {Object} jsonld - JSON-LD document to validate\n * @returns {Promise<boolean>} True if valid JSON-LD\n * \n * @example\n * const isValid = await validateJSONLD({ \"@context\": {}, \"@id\": \"http://example.org/foo\" });\n */\nexport async function validateJSONLD(jsonld) {\n  try {\n    const { RdfEngine } = await import(\"../engines/RdfEngine.mjs\");\n    const engine = new RdfEngine();\n    await engine.fromJSONLD(jsonld);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate a SPARQL query string\n * @param {string} sparql - SPARQL query to validate\n * @returns {Promise<boolean>} True if valid SPARQL\n * \n * @example\n * const isValid = await validateSPARQL(\"SELECT ?s WHERE { ?s ?p ?o }\");\n */\nexport async function validateSPARQL(sparql) {\n  try {\n    const { RdfEngine } = await import(\"../engines/RdfEngine.mjs\");\n    const engine = new RdfEngine();\n    const store = engine.createStore();\n    await engine.query(store, sparql);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate a SHACL shapes document\n * @param {string} shapes - SHACL shapes as Turtle string\n * @returns {Promise<boolean>} True if valid SHACL\n * \n * @example\n * const isValid = await validateSHACL(\"@prefix sh: <http://www.w3.org/ns/shacl#> . ex:Shape a sh:NodeShape .\");\n */\nexport async function validateSHACL(shapes) {\n  try {\n    const { RdfEngine } = await import(\"../engines/RdfEngine.mjs\");\n    const engine = new RdfEngine();\n    const shapesStore = engine.parseTurtle(shapes);\n    const dataStore = engine.createStore();\n    await engine.validateShacl(dataStore, shapesStore);\n    return true;\n  } catch {\n    return false;\n  }\n}\n\n/**\n * Validate a store for common issues\n * @param {Store} store - Store to validate\n * @returns {Object} Validation result with issues\n * \n * @example\n * const result = validateStore(store);\n * if (result.valid) {\n *   console.log(\"Store is valid\");\n * } else {\n *   console.log(\"Issues found:\", result.issues);\n * }\n */\nexport function validateStore(store) {\n  const issues = [];\n  \n  // Check for empty store\n  if (store.size === 0) {\n    issues.push({ type: \"warning\", message: \"Store is empty\" });\n  }\n  \n  // Check for invalid terms\n  for (const quad of store) {\n    if (!validateTerm(quad.subject)) {\n      issues.push({ type: \"error\", message: `Invalid subject: ${quad.subject}`, quad });\n    }\n    if (!validateTerm(quad.predicate)) {\n      issues.push({ type: \"error\", message: `Invalid predicate: ${quad.predicate}`, quad });\n    }\n    if (!validateTerm(quad.object)) {\n      issues.push({ type: \"error\", message: `Invalid object: ${quad.object}`, quad });\n    }\n    if (quad.graph && !validateTerm(quad.graph)) {\n      issues.push({ type: \"error\", message: `Invalid graph: ${quad.graph}`, quad });\n    }\n  }\n  \n  // Check for duplicate quads\n  const quadStrings = new Set();\n  for (const quad of store) {\n    const quadStr = `${quad.subject.value} ${quad.predicate.value} ${quad.object.value} ${quad.graph?.value || ''}`;\n    if (quadStrings.has(quadStr)) {\n      issues.push({ type: \"warning\", message: `Duplicate quad: ${quadStr}`, quad });\n    }\n    quadStrings.add(quadStr);\n  }\n  \n  return {\n    valid: issues.length === 0,\n    issues,\n    issueCount: issues.length,\n    errorCount: issues.filter(i => i.type === \"error\").length,\n    warningCount: issues.filter(i => i.type === \"warning\").length\n  };\n}\n\n/**\n * Validate a store against basic RDF constraints\n * @param {Store} store - Store to validate\n * @returns {Object} Validation result\n * \n * @example\n * const result = validateRDFConstraints(store);\n * if (!result.valid) {\n *   console.log(\"RDF constraints violated:\", result.violations);\n * }\n */\nexport function validateRDFConstraints(store) {\n  const violations = [];\n  \n  for (const quad of store) {\n    // Check that predicate is always a named node\n    if (quad.predicate.termType !== \"NamedNode\") {\n      violations.push({\n        type: \"error\",\n        message: \"Predicate must be a named node\",\n        quad\n      });\n    }\n    \n    // Check that subject is not a literal\n    if (quad.subject.termType === \"Literal\") {\n      violations.push({\n        type: \"error\",\n        message: \"Subject cannot be a literal\",\n        quad\n      });\n    }\n    \n    // Check that object is not a predicate\n    if (quad.object.termType === \"NamedNode\" && quad.object.value === quad.predicate.value) {\n      violations.push({\n        type: \"warning\",\n        message: \"Object and predicate are the same\",\n        quad\n      });\n    }\n  }\n  \n  return {\n    valid: violations.length === 0,\n    violations,\n    violationCount: violations.length,\n    errorCount: violations.filter(v => v.type === \"error\").length,\n    warningCount: violations.filter(v => v.type === \"warning\").length\n  };\n}\n\n/**\n * Validate a store for common patterns\n * @param {Store} store - Store to validate\n * @returns {Object} Validation result\n * \n * @example\n * const result = validateCommonPatterns(store);\n * console.log(`Found ${result.patterns.length} common patterns`);\n */\nexport function validateCommonPatterns(store) {\n  const patterns = [];\n  \n  // Check for rdf:type usage\n  const typeQuads = store.getQuads(null, asNamedNode(\"http://www.w3.org/1999/02/22-rdf-syntax-ns#type\"), null, null);\n  if (typeQuads.length > 0) {\n    patterns.push({\n      type: \"info\",\n      name: \"rdf:type usage\",\n      count: typeQuads.length,\n      message: `Found ${typeQuads.length} rdf:type statements`\n    });\n  }\n  \n  // Check for rdfs:label usage\n  const labelQuads = store.getQuads(null, asNamedNode(\"http://www.w3.org/2000/01/rdf-schema#label\"), null, null);\n  if (labelQuads.length > 0) {\n    patterns.push({\n      type: \"info\",\n      name: \"rdfs:label usage\",\n      count: labelQuads.length,\n      message: `Found ${labelQuads.length} rdfs:label statements`\n    });\n  }\n  \n  // Check for blank node usage\n  const blankNodes = new Set();\n  for (const quad of store) {\n    if (quad.subject.termType === \"BlankNode\") blankNodes.add(quad.subject.value);\n    if (quad.object.termType === \"BlankNode\") blankNodes.add(quad.object.value);\n  }\n  if (blankNodes.size > 0) {\n    patterns.push({\n      type: \"info\",\n      name: \"blank node usage\",\n      count: blankNodes.size,\n      message: `Found ${blankNodes.size} unique blank nodes`\n    });\n  }\n  \n  return {\n    patterns,\n    patternCount: patterns.length\n  };\n}\n\n/**\n * Create a validation pipeline\n * @param {Array<Function>} validators - Array of validator functions\n * @returns {Object} Pipeline interface\n * \n * @example\n * const pipeline = createValidationPipeline([\n *   validateStore,\n *   validateRDFConstraints,\n *   validateCommonPatterns\n * ]);\n * \n * const result = await pipeline.execute(store);\n */\nexport function createValidationPipeline(validators) {\n  return {\n    validators,\n    \n    /**\n     * Execute the validation pipeline\n     * @param {Store} store - Store to validate\n     * @returns {Promise<Object>} Pipeline result\n     */\n    async execute(store) {\n      const results = [];\n      const allIssues = [];\n      \n      for (const validator of this.validators) {\n        try {\n          const result = await validator(store);\n          results.push(result);\n          \n          if (result.issues) {\n            allIssues.push(...result.issues);\n          }\n          if (result.violations) {\n            allIssues.push(...result.violations);\n          }\n        } catch (error) {\n          results.push({\n            valid: false,\n            error: error.message\n          });\n        }\n      }\n      \n      return {\n        results,\n        allIssues,\n        valid: allIssues.length === 0,\n        issueCount: allIssues.length,\n        errorCount: allIssues.filter(i => i.type === \"error\").length,\n        warningCount: allIssues.filter(i => i.type === \"warning\").length\n      };\n    }\n  };\n}"
        }
    ]
}