{
    "sourceFile": "src/utils/io-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758655862930,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758655862930,
            "name": "Commit-0",
            "content": "import { promises as fs } from \"node:fs\";\nimport { createReadStream, createWriteStream } from \"node:fs\";\nimport { pipeline } from \"node:stream/promises\";\nimport { Transform } from \"node:stream\";\n\n/**\n * Read Turtle file\n * @param {string} path - File path to read\n * @returns {Promise<string>} Turtle content\n */\nexport const readTurtleFile = async (path) => {\n  try {\n    return await fs.readFile(path, \"utf8\");\n  } catch (error) {\n    throw new Error(`Failed to read Turtle file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Write Turtle file\n * @param {string} path - File path to write\n * @param {string} ttl - Turtle content\n * @returns {Promise<{path: string, bytes: number}>} Write result\n */\nexport const writeTurtleFile = async (path, ttl) => {\n  try {\n    await fs.writeFile(path, ttl, \"utf8\");\n    return { path, bytes: Buffer.byteLength(ttl) };\n  } catch (error) {\n    throw new Error(`Failed to write Turtle file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Read JSON-LD file\n * @param {string} path - File path to read\n * @returns {Promise<Object|Object[]>} JSON-LD content\n */\nexport const readJSONLDFile = async (path) => {\n  try {\n    const content = await fs.readFile(path, \"utf8\");\n    return JSON.parse(content);\n  } catch (error) {\n    throw new Error(`Failed to read JSON-LD file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Write JSON-LD file\n * @param {string} path - File path to write\n * @param {Object|Object[]} obj - JSON-LD content\n * @param {number} [indent=2] - JSON indentation\n * @returns {Promise<{path: string, bytes: number}>} Write result\n */\nexport const writeJSONLDFile = async (path, obj, indent = 2) => {\n  try {\n    const json = JSON.stringify(obj, null, indent);\n    await fs.writeFile(path, json, \"utf8\");\n    return { path, bytes: Buffer.byteLength(json) };\n  } catch (error) {\n    throw new Error(`Failed to write JSON-LD file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Read N-Triples file\n * @param {string} path - File path to read\n * @returns {Promise<string>} N-Triples content\n */\nexport const readNTriplesFile = async (path) => {\n  try {\n    return await fs.readFile(path, \"utf8\");\n  } catch (error) {\n    throw new Error(`Failed to read N-Triples file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Write N-Triples file\n * @param {string} path - File path to write\n * @param {string} ntriples - N-Triples content\n * @returns {Promise<{path: string, bytes: number}>} Write result\n */\nexport const writeNTriplesFile = async (path, ntriples) => {\n  try {\n    await fs.writeFile(path, ntriples, \"utf8\");\n    return { path, bytes: Buffer.byteLength(ntriples) };\n  } catch (error) {\n    throw new Error(`Failed to write N-Triples file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Read RDF/XML file\n * @param {string} path - File path to read\n * @returns {Promise<string>} RDF/XML content\n */\nexport const readRDFXMLFile = async (path) => {\n  try {\n    return await fs.readFile(path, \"utf8\");\n  } catch (error) {\n    throw new Error(`Failed to read RDF/XML file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Write RDF/XML file\n * @param {string} path - File path to write\n * @param {string} rdfxml - RDF/XML content\n * @returns {Promise<{path: string, bytes: number}>} Write result\n */\nexport const writeRDFXMLFile = async (path, rdfxml) => {\n  try {\n    await fs.writeFile(path, rdfxml, \"utf8\");\n    return { path, bytes: Buffer.byteLength(rdfxml) };\n  } catch (error) {\n    throw new Error(`Failed to write RDF/XML file at ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Check if file exists\n * @param {string} path - File path to check\n * @returns {Promise<boolean>} True if file exists\n */\nexport const fileExists = async (path) => {\n  try {\n    await fs.access(path);\n    return true;\n  } catch {\n    return false;\n  }\n};\n\n/**\n * Get file stats\n * @param {string} path - File path\n * @returns {Promise<import('fs').Stats>} File stats\n */\nexport const getFileStats = async (path) => {\n  try {\n    return await fs.stat(path);\n  } catch (error) {\n    throw new Error(`Failed to get file stats for ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Create directory if it doesn't exist\n * @param {string} path - Directory path\n * @param {boolean} [recursive=true] - Create parent directories\n * @returns {Promise<void>}\n */\nexport const ensureDir = async (path, recursive = true) => {\n  try {\n    await fs.mkdir(path, { recursive });\n  } catch (error) {\n    if (error.code !== \"EEXIST\") {\n      throw new Error(`Failed to create directory ${path}: ${error.message}`);\n    }\n  }\n};\n\n/**\n * Read file as stream\n * @param {string} path - File path\n * @returns {import('fs').ReadStream} Read stream\n */\nexport const createFileReadStream = (path) => {\n  try {\n    return createReadStream(path, { encoding: \"utf8\" });\n  } catch (error) {\n    throw new Error(`Failed to create read stream for ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Write file as stream\n * @param {string} path - File path\n * @returns {import('fs').WriteStream} Write stream\n */\nexport const createFileWriteStream = (path) => {\n  try {\n    return createWriteStream(path, { encoding: \"utf8\" });\n  } catch (error) {\n    throw new Error(`Failed to create write stream for ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Stream file content line by line\n * @param {string} path - File path\n * @param {Function} onLine - Callback for each line\n * @returns {Promise<void>}\n */\nexport const streamFileLines = async (path, onLine) => {\n  const readStream = createFileReadStream(path);\n  let buffer = \"\";\n  \n  readStream.on(\"data\", (chunk) => {\n    buffer += chunk;\n    const lines = buffer.split(\"\\n\");\n    buffer = lines.pop() || \"\"; // Keep incomplete line in buffer\n    \n    for (const line of lines) {\n      onLine(line);\n    }\n  });\n  \n  readStream.on(\"end\", () => {\n    if (buffer) {\n      onLine(buffer);\n    }\n  });\n  \n  return new Promise((resolve, reject) => {\n    readStream.on(\"error\", reject);\n    readStream.on(\"end\", resolve);\n  });\n};\n\n/**\n * Copy file\n * @param {string} src - Source file path\n * @param {string} dest - Destination file path\n * @returns {Promise<void>}\n */\nexport const copyFile = async (src, dest) => {\n  try {\n    await fs.copyFile(src, dest);\n  } catch (error) {\n    throw new Error(`Failed to copy file from ${src} to ${dest}: ${error.message}`);\n  }\n};\n\n/**\n * Move/rename file\n * @param {string} src - Source file path\n * @param {string} dest - Destination file path\n * @returns {Promise<void>}\n */\nexport const moveFile = async (src, dest) => {\n  try {\n    await fs.rename(src, dest);\n  } catch (error) {\n    throw new Error(`Failed to move file from ${src} to ${dest}: ${error.message}`);\n  }\n};\n\n/**\n * Delete file\n * @param {string} path - File path to delete\n * @returns {Promise<void>}\n */\nexport const deleteFile = async (path) => {\n  try {\n    await fs.unlink(path);\n  } catch (error) {\n    throw new Error(`Failed to delete file ${path}: ${error.message}`);\n  }\n};\n\n/**\n * List files in directory\n * @param {string} path - Directory path\n * @param {string} [pattern] - Optional glob pattern\n * @returns {Promise<string[]>} Array of file paths\n */\nexport const listFiles = async (path, pattern) => {\n  try {\n    const files = await fs.readdir(path);\n    if (pattern) {\n      const regex = new RegExp(pattern.replace(/\\*/g, \".*\"));\n      return files.filter(file => regex.test(file));\n    }\n    return files;\n  } catch (error) {\n    throw new Error(`Failed to list files in ${path}: ${error.message}`);\n  }\n};\n\n/**\n * Get file extension\n * @param {string} path - File path\n * @returns {string} File extension (without dot)\n */\nexport const getFileExtension = (path) => {\n  const parts = path.split(\".\");\n  return parts.length > 1 ? parts.pop().toLowerCase() : \"\";\n};\n\n/**\n * Detect RDF format from file extension\n * @param {string} path - File path\n * @returns {string} RDF format name\n */\nexport const detectRDFFormat = (path) => {\n  const ext = getFileExtension(path);\n  const formatMap = {\n    \"ttl\": \"turtle\",\n    \"turtle\": \"turtle\",\n    \"nt\": \"n-triples\",\n    \"n3\": \"n3\",\n    \"rdf\": \"rdf-xml\",\n    \"xml\": \"rdf-xml\",\n    \"jsonld\": \"json-ld\",\n    \"json\": \"json-ld\"\n  };\n  return formatMap[ext] || \"turtle\";\n};\n"
        }
    ]
}