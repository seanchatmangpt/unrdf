{
    "sourceFile": "src/utils/id-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758655862894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758655862894,
            "name": "Commit-0",
            "content": "import { DataFactory } from \"n3\";\nimport { createHash, randomBytes } from \"node:crypto\";\n\nconst { blankNode, namedNode } = DataFactory;\n\n/**\n * Deterministic blank node generator\n * @param {string} [prefix=\"bn\"] - Prefix for blank node IDs\n * @returns {Function} Function that generates blank nodes\n */\nexport const makeBNodeGenerator = (prefix = \"bn\") => {\n  let i = 0;\n  return () => blankNode(`${prefix}${i++}`);\n};\n\n/**\n * Create a skolemized IRI for a blank node\n * @param {string} id - Blank node identifier\n * @param {string} [baseIRI=\"http://example.org/.well-known/genid/\"] - Base IRI for skolemization\n * @returns {string} Skolemized IRI\n */\nexport const skolemize = (id, baseIRI = \"http://example.org/.well-known/genid/\") =>\n  `${baseIRI}${id}`;\n\n/**\n * Generate a random blank node ID\n * @param {number} [length=16] - Length of random ID\n * @returns {string} Random blank node ID\n */\nexport const generateRandomBNodeId = (length = 16) => {\n  const bytes = randomBytes(Math.ceil(length / 2));\n  return bytes.toString(\"hex\").substring(0, length);\n};\n\n/**\n * Generate a deterministic blank node ID from content\n * @param {string} content - Content to hash\n * @param {number} [length=16] - Length of hash to use\n * @returns {string} Deterministic blank node ID\n */\nexport const generateDeterministicBNodeId = (content, length = 16) => {\n  const hash = createHash(\"sha256\");\n  hash.update(content);\n  return hash.digest(\"hex\").substring(0, length);\n};\n\n/**\n * Create a blank node with random ID\n * @param {number} [length=16] - Length of random ID\n * @returns {import('n3').BlankNode} Blank node with random ID\n */\nexport const createRandomBlankNode = (length = 16) => {\n  return blankNode(generateRandomBNodeId(length));\n};\n\n/**\n * Create a blank node with deterministic ID\n * @param {string} content - Content to hash for ID\n * @param {number} [length=16] - Length of hash to use\n * @returns {import('n3').BlankNode} Blank node with deterministic ID\n */\nexport const createDeterministicBlankNode = (content, length = 16) => {\n  return blankNode(generateDeterministicBNodeId(content, length));\n};\n\n/**\n * Generate a UUID v4\n * @returns {string} UUID v4 string\n */\nexport const generateUUID = () => {\n  return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c) => {\n    const r = (Math.random() * 16) | 0;\n    const v = c === \"x\" ? r : (r & 0x3) | 0x8;\n    return v.toString(16);\n  });\n};\n\n/**\n * Generate a short UUID (base36)\n * @returns {string} Short UUID string\n */\nexport const generateShortUUID = () => {\n  return Math.random().toString(36).substring(2) + Date.now().toString(36);\n};\n\n/**\n * Create a named node with UUID\n * @param {string} [baseIRI] - Base IRI for the named node\n * @returns {import('n3').NamedNode} Named node with UUID\n */\nexport const createUUIDNamedNode = (baseIRI = \"http://example.org/id/\") => {\n  return namedNode(`${baseIRI}${generateUUID()}`);\n};\n\n/**\n * Create a named node with short UUID\n * @param {string} [baseIRI] - Base IRI for the named node\n * @returns {import('n3').NamedNode} Named node with short UUID\n */\nexport const createShortUUIDNamedNode = (baseIRI = \"http://example.org/id/\") => {\n  return namedNode(`${baseIRI}${generateShortUUID()}`);\n};\n\n/**\n * Generate a timestamp-based ID\n * @param {string} [prefix=\"ts\"] - Prefix for the ID\n * @returns {string} Timestamp-based ID\n */\nexport const generateTimestampId = (prefix = \"ts\") => {\n  return `${prefix}${Date.now()}`;\n};\n\n/**\n * Generate a counter-based ID\n * @param {string} [prefix=\"id\"] - Prefix for the ID\n * @returns {Function} Function that generates sequential IDs\n */\nexport const makeCounterIdGenerator = (prefix = \"id\") => {\n  let counter = 0;\n  return () => `${prefix}${counter++}`;\n};\n\n/**\n * Create a hash-based IRI\n * @param {string} content - Content to hash\n * @param {string} [baseIRI=\"http://example.org/hash/\"] - Base IRI\n * @param {string} [algorithm=\"sha256\"] - Hash algorithm\n * @returns {string} Hash-based IRI\n */\nexport const createHashIRI = (content, baseIRI = \"http://example.org/hash/\", algorithm = \"sha256\") => {\n  const hash = createHash(algorithm);\n  hash.update(content);\n  const hashValue = hash.digest(\"hex\");\n  return `${baseIRI}${algorithm}/${hashValue}`;\n};\n\n/**\n * Create a named node with hash-based IRI\n * @param {string} content - Content to hash\n * @param {string} [baseIRI=\"http://example.org/hash/\"] - Base IRI\n * @param {string} [algorithm=\"sha256\"] - Hash algorithm\n * @returns {import('n3').NamedNode} Named node with hash-based IRI\n */\nexport const createHashNamedNode = (content, baseIRI = \"http://example.org/hash/\", algorithm = \"sha256\") => {\n  return namedNode(createHashIRI(content, baseIRI, algorithm));\n};\n\n/**\n * Generate a namespace-aware ID\n * @param {string} namespace - Namespace IRI\n * @param {string} localName - Local name\n * @returns {string} Full IRI\n */\nexport const createNamespaceId = (namespace, localName) => {\n  const cleanNamespace = namespace.endsWith(\"/\") || namespace.endsWith(\"#\") ? namespace : `${namespace}#`;\n  return `${cleanNamespace}${localName}`;\n};\n\n/**\n * Create a named node with namespace\n * @param {string} namespace - Namespace IRI\n * @param {string} localName - Local name\n * @returns {import('n3').NamedNode} Named node with namespace\n */\nexport const createNamespaceNamedNode = (namespace, localName) => {\n  return namedNode(createNamespaceId(namespace, localName));\n};\n\n/**\n * Extract local name from IRI\n * @param {string} iri - IRI to extract from\n * @returns {string} Local name\n */\nexport const extractLocalName = (iri) => {\n  const hashIndex = iri.lastIndexOf(\"#\");\n  const slashIndex = iri.lastIndexOf(\"/\");\n  const index = Math.max(hashIndex, slashIndex);\n  return index >= 0 ? iri.substring(index + 1) : iri;\n};\n\n/**\n * Extract namespace from IRI\n * @param {string} iri - IRI to extract from\n * @returns {string} Namespace\n */\nexport const extractNamespace = (iri) => {\n  const hashIndex = iri.lastIndexOf(\"#\");\n  const slashIndex = iri.lastIndexOf(\"/\");\n  const index = Math.max(hashIndex, slashIndex);\n  return index >= 0 ? iri.substring(0, index + 1) : \"\";\n};\n\n/**\n * Check if an IRI is a blank node identifier\n * @param {string} iri - IRI to check\n * @returns {boolean} True if it's a blank node identifier\n */\nexport const isBlankNodeIRI = (iri) => {\n  return iri.startsWith(\"_:\") || iri.includes(\".well-known/genid/\");\n};\n\n/**\n * Convert blank node IRI to blank node ID\n * @param {string} iri - Blank node IRI\n * @returns {string} Blank node ID\n */\nexport const iriToBlankNodeId = (iri) => {\n  if (iri.startsWith(\"_:\")) {\n    return iri.substring(2);\n  }\n  if (iri.includes(\".well-known/genid/\")) {\n    return iri.split(\".well-known/genid/\")[1];\n  }\n  return iri;\n};\n\n/**\n * Convert blank node ID to blank node IRI\n * @param {string} id - Blank node ID\n * @param {string} [baseIRI=\"http://example.org/.well-known/genid/\"] - Base IRI\n * @returns {string} Blank node IRI\n */\nexport const blankNodeIdToIRI = (id, baseIRI = \"http://example.org/.well-known/genid/\") => {\n  return `${baseIRI}${id}`;\n};\n\n/**\n * Generate a stable ID from multiple values\n * @param {...any} values - Values to combine for ID generation\n * @returns {string} Stable ID\n */\nexport const generateStableId = (...values) => {\n  const content = values.map(v => String(v)).join(\"|\");\n  return generateDeterministicBNodeId(content);\n};\n\n/**\n * Create a stable named node from multiple values\n * @param {string} baseIRI - Base IRI\n * @param {...any} values - Values to combine for ID generation\n * @returns {import('n3').NamedNode} Stable named node\n */\nexport const createStableNamedNode = (baseIRI, ...values) => {\n  const stableId = generateStableId(...values);\n  return namedNode(`${baseIRI}${stableId}`);\n};\n"
        }
    ]
}