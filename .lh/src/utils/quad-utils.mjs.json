{
    "sourceFile": "src/utils/quad-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758655862894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758655862894,
            "name": "Commit-0",
            "content": "import { DataFactory } from \"n3\";\nimport { asNamedNode, asLiteral, isNamedNode, isLiteral, isBlankNode } from \"./term-utils.mjs\";\n\nconst { quad } = DataFactory;\n\n/**\n * Convert quad → plain JSON\n * @param {import('n3').Quad} q - RDF quad to convert\n * @returns {Object} Plain JSON representation of the quad\n */\nexport const quadToJSON = (q) => ({\n  subject: q.subject.value,\n  predicate: q.predicate.value,\n  object: q.object.value,\n  graph: q.graph.termType === \"DefaultGraph\" ? null : q.graph.value,\n  // Include term types for reconstruction\n  subjectType: q.subject.termType,\n  objectType: q.object.termType,\n  graphType: q.graph.termType\n});\n\n/**\n * Convert JSON → quad\n * @param {Object} obj - JSON object with quad data\n * @param {string} obj.subject - Subject IRI\n * @param {string} obj.predicate - Predicate IRI\n * @param {string} obj.object - Object value\n * @param {string|null} [obj.graph] - Graph IRI (optional)\n * @returns {import('n3').Quad} RDF quad\n */\nexport const jsonToQuad = (obj) => {\n  const subject = asNamedNode(obj.subject);\n  const predicate = asNamedNode(obj.predicate);\n  \n  // Smart object handling - check if it looks like an IRI\n  const object = obj.object.startsWith(\"http\") || obj.object.startsWith(\"urn:\") \n    ? asNamedNode(obj.object) \n    : asLiteral(obj.object);\n  \n  const graph = obj.graph ? asNamedNode(obj.graph) : undefined;\n  \n  return quad(subject, predicate, object, graph);\n};\n\n/**\n * Convert array of quads to JSON\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @returns {Object[]} Array of JSON objects\n */\nexport const quadsToJSON = (quads) => quads.map(quadToJSON);\n\n/**\n * Convert array of JSON objects to quads\n * @param {Object[]} jsonArray - Array of JSON quad objects\n * @returns {import('n3').Quad[]} Array of RDF quads\n */\nexport const jsonToQuads = (jsonArray) => jsonArray.map(jsonToQuad);\n\n/**\n * Extract all unique subjects from quads\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @returns {string[]} Array of unique subject IRIs\n */\nexport const extractSubjects = (quads) => \n  [...new Set(quads.map(q => q.subject.value))];\n\n/**\n * Extract all unique predicates from quads\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @returns {string[]} Array of unique predicate IRIs\n */\nexport const extractPredicates = (quads) => \n  [...new Set(quads.map(q => q.predicate.value))];\n\n/**\n * Extract all unique objects from quads\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @returns {string[]} Array of unique object values\n */\nexport const extractObjects = (quads) => \n  [...new Set(quads.map(q => q.object.value))];\n\n/**\n * Filter quads by subject\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @param {string} subjectIRI - Subject IRI to filter by\n * @returns {import('n3').Quad[]} Filtered quads\n */\nexport const filterBySubject = (quads, subjectIRI) =>\n  quads.filter(q => q.subject.value === subjectIRI);\n\n/**\n * Filter quads by predicate\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @param {string} predicateIRI - Predicate IRI to filter by\n * @returns {import('n3').Quad[]} Filtered quads\n */\nexport const filterByPredicate = (quads, predicateIRI) =>\n  quads.filter(q => q.predicate.value === predicateIRI);\n\n/**\n * Filter quads by object\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @param {string} objectValue - Object value to filter by\n * @returns {import('n3').Quad[]} Filtered quads\n */\nexport const filterByObject = (quads, objectValue) =>\n  quads.filter(q => q.object.value === objectValue);\n\n/**\n * Group quads by subject\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @returns {Map<string, import('n3').Quad[]>} Map of subject IRIs to their quads\n */\nexport const groupBySubject = (quads) => {\n  const groups = new Map();\n  for (const q of quads) {\n    const subject = q.subject.value;\n    if (!groups.has(subject)) {\n      groups.set(subject, []);\n    }\n    groups.get(subject).push(q);\n  }\n  return groups;\n};\n\n/**\n * Group quads by predicate\n * @param {import('n3').Quad[]} quads - Array of RDF quads\n * @returns {Map<string, import('n3').Quad[]>} Map of predicate IRIs to their quads\n */\nexport const groupByPredicate = (quads) => {\n  const groups = new Map();\n  for (const q of quads) {\n    const predicate = q.predicate.value;\n    if (!groups.has(predicate)) {\n      groups.set(predicate, []);\n    }\n    groups.get(predicate).push(q);\n  }\n  return groups;\n};\n"
        }
    ]
}