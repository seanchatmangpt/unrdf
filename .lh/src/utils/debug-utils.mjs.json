{
    "sourceFile": "src/utils/debug-utils.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758655862894,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758655862894,
            "name": "Commit-0",
            "content": "import { inspect } from \"node:util\";\n\n/**\n * Pretty print first N quads\n * @param {import('n3').Store} store - RDF store to inspect\n * @param {number} [n=5] - Number of quads to show\n * @returns {string[]} Array of formatted quad strings\n */\nexport const previewQuads = (store, n = 5) =>\n  [...store].slice(0, n).map((q) => \n    `${q.subject.value} ${q.predicate.value} ${q.object.value}${q.graph.termType !== \"DefaultGraph\" ? ` ${q.graph.value}` : \"\"}`\n  );\n\n/**\n * Console.log Turtle for inspection\n * @param {import('n3').Store} store - RDF store to serialize\n * @param {import('n3').Parser} engine - RDF engine for serialization\n * @param {Object} [prefixes={}] - Optional prefix mappings\n * @returns {Promise<void>}\n */\nexport const dumpTurtle = async (store, engine, prefixes = {}) => {\n  try {\n    const turtle = await engine.serializeTurtle(store, { prefixes });\n    console.log(\"=== Turtle Dump ===\");\n    console.log(turtle);\n    console.log(\"==================\");\n  } catch (error) {\n    console.error(\"Failed to dump Turtle:\", error.message);\n  }\n};\n\n/**\n * Get store statistics\n * @param {import('n3').Store} store - RDF store to analyze\n * @returns {Object} Store statistics\n */\nexport const getStoreStats = (store) => {\n  const subjects = new Set();\n  const predicates = new Set();\n  const objects = new Set();\n  const graphs = new Set();\n  \n  for (const q of store) {\n    subjects.add(q.subject.value);\n    predicates.add(q.predicate.value);\n    objects.add(q.object.value);\n    if (q.graph.termType !== \"DefaultGraph\") {\n      graphs.add(q.graph.value);\n    }\n  }\n  \n  return {\n    quadCount: store.size,\n    subjectCount: subjects.size,\n    predicateCount: predicates.size,\n    objectCount: objects.size,\n    graphCount: graphs.size,\n    subjects: [...subjects],\n    predicates: [...predicates],\n    objects: [...objects],\n    graphs: [...graphs]\n  };\n};\n\n/**\n * Print store statistics to console\n * @param {import('n3').Store} store - RDF store to analyze\n * @returns {void}\n */\nexport const printStoreStats = (store) => {\n  const stats = getStoreStats(store);\n  console.log(\"=== Store Statistics ===\");\n  console.log(`Quads: ${stats.quadCount}`);\n  console.log(`Subjects: ${stats.subjectCount}`);\n  console.log(`Predicates: ${stats.predicateCount}`);\n  console.log(`Objects: ${stats.objectCount}`);\n  console.log(`Graphs: ${stats.graphCount}`);\n  console.log(\"========================\");\n};\n\n/**\n * Deep inspect any object with custom formatting\n * @param {any} obj - Object to inspect\n * @param {Object} [options={}] - Inspection options\n * @returns {string} Formatted string representation\n */\nexport const deepInspect = (obj, options = {}) => {\n  const defaultOptions = {\n    depth: 3,\n    colors: true,\n    showHidden: false,\n    maxArrayLength: 10,\n    maxStringLength: 100,\n    ...options\n  };\n  \n  return inspect(obj, defaultOptions);\n};\n\n/**\n * Log object with deep inspection\n * @param {any} obj - Object to log\n * @param {string} [label] - Optional label for the log\n * @param {Object} [options] - Inspection options\n * @returns {void}\n */\nexport const logDeep = (obj, label = \"Object\", options = {}) => {\n  console.log(`=== ${label} ===`);\n  console.log(deepInspect(obj, options));\n  console.log(\"==================\");\n};\n\n/**\n * Time a function execution\n * @param {Function} fn - Function to time\n * @param {string} [label] - Optional label for timing\n * @returns {any} Function result\n */\nexport const timeExecution = async (fn, label = \"Execution\") => {\n  const start = performance.now();\n  const result = await fn();\n  const end = performance.now();\n  console.log(`${label}: ${(end - start).toFixed(2)}ms`);\n  return result;\n};\n\n/**\n * Create a performance timer\n * @param {string} [label] - Timer label\n * @returns {Object} Timer object with start/end methods\n */\nexport const createTimer = (label = \"Timer\") => {\n  let startTime = null;\n  \n  return {\n    start: () => {\n      startTime = performance.now();\n      console.log(`${label} started`);\n    },\n    end: () => {\n      if (startTime === null) {\n        console.warn(`${label} was not started`);\n        return;\n      }\n      const endTime = performance.now();\n      const duration = endTime - startTime;\n      console.log(`${label}: ${duration.toFixed(2)}ms`);\n      startTime = null;\n      return duration;\n    }\n  };\n};\n\n/**\n * Log memory usage\n * @returns {void}\n */\nexport const logMemoryUsage = () => {\n  const usage = process.memoryUsage();\n  console.log(\"=== Memory Usage ===\");\n  console.log(`RSS: ${(usage.rss / 1024 / 1024).toFixed(2)} MB`);\n  console.log(`Heap Used: ${(usage.heapUsed / 1024 / 1024).toFixed(2)} MB`);\n  console.log(`Heap Total: ${(usage.heapTotal / 1024 / 1024).toFixed(2)} MB`);\n  console.log(`External: ${(usage.external / 1024 / 1024).toFixed(2)} MB`);\n  console.log(\"===================\");\n};\n\n/**\n * Create a debug logger with levels\n * @param {string} [name] - Logger name\n * @returns {Object} Logger object\n */\nexport const createDebugLogger = (name = \"DEBUG\") => {\n  const levels = {\n    ERROR: 0,\n    WARN: 1,\n    INFO: 2,\n    DEBUG: 3,\n    TRACE: 4\n  };\n  \n  let currentLevel = levels.INFO;\n  \n  const log = (level, message, ...args) => {\n    if (levels[level] <= currentLevel) {\n      const timestamp = new Date().toISOString();\n      console.log(`[${timestamp}] [${name}] [${level}] ${message}`, ...args);\n    }\n  };\n  \n  return {\n    setLevel: (level) => {\n      if (levels[level] !== undefined) {\n        currentLevel = levels[level];\n      }\n    },\n    error: (message, ...args) => log(\"ERROR\", message, ...args),\n    warn: (message, ...args) => log(\"WARN\", message, ...args),\n    info: (message, ...args) => log(\"INFO\", message, ...args),\n    debug: (message, ...args) => log(\"DEBUG\", message, ...args),\n    trace: (message, ...args) => log(\"TRACE\", message, ...args)\n  };\n};\n\n/**\n * Pretty print JSON with syntax highlighting\n * @param {any} obj - Object to pretty print\n * @param {number} [indent=2] - Indentation level\n * @returns {string} Pretty printed JSON\n */\nexport const prettyJSON = (obj, indent = 2) => {\n  return JSON.stringify(obj, null, indent);\n};\n\n/**\n * Log JSON with pretty printing\n * @param {any} obj - Object to log\n * @param {string} [label] - Optional label\n * @returns {void}\n */\nexport const logJSON = (obj, label = \"JSON\") => {\n  console.log(`=== ${label} ===`);\n  console.log(prettyJSON(obj));\n  console.log(\"================\");\n};\n\n/**\n * Create a progress tracker\n * @param {number} total - Total number of items\n * @param {string} [label] - Progress label\n * @returns {Object} Progress tracker\n */\nexport const createProgressTracker = (total, label = \"Progress\") => {\n  let current = 0;\n  \n  return {\n    update: (increment = 1) => {\n      current += increment;\n      const percentage = ((current / total) * 100).toFixed(1);\n      const bar = \"█\".repeat(Math.floor(percentage / 2)) + \"░\".repeat(50 - Math.floor(percentage / 2));\n      process.stdout.write(`\\r${label}: [${bar}] ${percentage}% (${current}/${total})`);\n      \n      if (current >= total) {\n        console.log(); // New line when complete\n      }\n    },\n    complete: () => {\n      current = total;\n      const bar = \"█\".repeat(50);\n      console.log(`\\r${label}: [${bar}] 100.0% (${total}/${total})`);\n    }\n  };\n};\n\n/**\n * Measure quad processing performance\n * @param {import('n3').Store} store - Store to measure\n * @param {Function} processor - Function to process quads\n * @returns {Promise<Object>} Performance metrics\n */\nexport const measureQuadProcessing = async (store, processor) => {\n  const start = performance.now();\n  const startMemory = process.memoryUsage();\n  \n  const result = await processor(store);\n  \n  const end = performance.now();\n  const endMemory = process.memoryUsage();\n  \n  return {\n    duration: end - start,\n    quadCount: store.size,\n    quadsPerSecond: (store.size / (end - start)) * 1000,\n    memoryDelta: {\n      rss: endMemory.rss - startMemory.rss,\n      heapUsed: endMemory.heapUsed - startMemory.heapUsed,\n      heapTotal: endMemory.heapTotal - startMemory.heapTotal\n    },\n    result\n  };\n};\n"
        }
    ]
}