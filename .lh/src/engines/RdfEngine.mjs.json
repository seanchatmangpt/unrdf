{
    "sourceFile": "src/engines/RdfEngine.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015526,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview Production-grade RDF engine for JavaScript\n * \n * This is the opinionated core engine that powers all unrdf operations.\n * It enforces a single path through the RDF universe:\n * - N3.Store as the only memory model\n * - Comunica as the only SPARQL engine  \n * - EYE as the only reasoner\n * - URDNA2015 as the only canonicalization\n * - SHACL as the only validator\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { Parser, Store, Writer, DataFactory } from \"n3\";\nimport { QueryEngine } from \"@comunica/query-sparql\";\nimport rdf from \"rdf-ext\";\nimport SHACLValidator from \"rdf-validate-shacl\";\nimport rdfCanonize from \"rdf-canonize\";\nimport jsonld from \"jsonld\";\nimport { n3reasoner } from \"eyereasoner\";\nimport $rdf from \"@zazuko/env\";\n\nconst { namedNode, literal, quad, blankNode, defaultGraph, variable } = DataFactory;\n\n/**\n * Production-grade RDF engine for JavaScript\n * \n * @class RdfEngine\n */\nexport class RdfEngine {\n  /**\n   * @param {Object} [options] - Engine configuration\n   * @param {string} [options.baseIRI='http://example.org/'] - Base IRI for parsing\n   * @param {boolean} [options.deterministic=true] - Enable deterministic operations\n   * @param {number} [options.timeoutMs=30000] - Default timeout for operations\n   * @param {Function} [options.onMetric] - Metrics callback function\n   * @param {Object} [options.logger=console] - Logger instance\n   */\n  constructor(options = {}) {\n    this.baseIRI = options.baseIRI || \"http://example.org/\";\n    this.deterministic = options.deterministic !== false;\n    this.timeoutMs = Number.isFinite(options.timeoutMs) ? options.timeoutMs : 30_000;\n    this.onMetric = typeof options.onMetric === \"function\" ? options.onMetric : null;\n    this.log = options.logger || console;\n    this.engine = new QueryEngine();\n    this.$rdf = $rdf;\n  }\n\n  // ============== Terms & Store ==============\n\n  /**\n   * Create a new N3.Store instance\n   * @param {Array} [quads=[]] - Initial quads\n   * @returns {Store} New N3.Store instance\n   */\n  createStore(quads = []) {\n    return new Store(quads);\n  }\n\n  /**\n   * Create a named node\n   * @param {string} value - IRI value\n   * @returns {NamedNode} Named node term\n   */\n  namedNode(value) {\n    return namedNode(value);\n  }\n\n  /**\n   * Create a literal\n   * @param {string} value - Literal value\n   * @param {string} [languageOrDatatype] - Language tag or datatype IRI\n   * @returns {Literal} Literal term\n   */\n  literal(value, languageOrDatatype) {\n    return literal(value, languageOrDatatype);\n  }\n\n  /**\n   * Create a blank node\n   * @param {string} [value] - Blank node identifier\n   * @returns {BlankNode} Blank node term\n   */\n  blankNode(value) {\n    return blankNode(value);\n  }\n\n  /**\n   * Create a quad\n   * @param {Term} s - Subject\n   * @param {Term} p - Predicate  \n   * @param {Term} o - Object\n   * @param {Term} [g] - Graph (defaults to default graph)\n   * @returns {Quad} Quad term\n   */\n  quad(s, p, o, g = defaultGraph()) {\n    return quad(s, p, o, g);\n  }\n\n  // ============== Parse & Serialize (deterministic) ==============\n\n  /**\n   * Parse Turtle into N3.Store\n   * @param {string} ttl - Turtle string\n   * @param {Object} [options] - Parse options\n   * @param {string} [options.baseIRI] - Base IRI for parsing\n   * @returns {Store} Parsed store\n   */\n  parseTurtle(ttl, options = {}) {\n    if (typeof ttl !== \"string\" || !ttl.length) {\n      throw new Error(\"parseTurtle: non-empty string required\");\n    }\n    const parser = new Parser({\n      baseIRI: options.baseIRI || this.baseIRI\n    });\n    return new Store(parser.parse(ttl));\n  }\n\n  /**\n   * Parse N-Quads into N3.Store\n   * @param {string} nq - N-Quads string\n   * @returns {Store} Parsed store\n   */\n  parseNQuads(nq) {\n    if (typeof nq !== \"string\" || !nq.length) {\n      throw new Error(\"parseNQuads: non-empty string required\");\n    }\n    const parser = new Parser({ format: \"N-Quads\" });\n    return new Store(parser.parse(nq));\n  }\n\n  /**\n   * Serialize store to Turtle\n   * @param {Store} store - N3.Store to serialize\n   * @param {Object} [options] - Serialization options\n   * @param {Object} [options.prefixes] - Prefix mappings\n   * @returns {Promise<string>} Turtle string\n   */\n  async serializeTurtle(store, options = {}) {\n    const prefixes = options.prefixes || this._extractPrefixes(store);\n    const writer = new Writer({\n      format: \"Turtle\",\n      prefixes,\n    });\n    const quads = this._maybeSort([...store]);\n    writer.addQuads(quads);\n    return new Promise((resolve, reject) => \n      writer.end((e, out) => (e ? reject(e) : resolve(out)))\n    );\n  }\n\n  /**\n   * Serialize store to N-Quads\n   * @param {Store} store - N3.Store to serialize\n   * @returns {Promise<string>} N-Quads string\n   */\n  async serializeNQuads(store) {\n    const writer = new Writer({ format: \"N-Quads\" });\n    const quads = this._maybeSort([...store]);\n    writer.addQuads(quads);\n    return new Promise((resolve, reject) => \n      writer.end((e, out) => (e ? reject(e) : resolve(out)))\n    );\n  }\n\n  // ============== Canonicalization & Isomorphism ==============\n\n  /**\n   * Canonicalize store using URDNA2015\n   * @param {Store} store - Store to canonicalize\n   * @returns {Promise<string>} Canonical N-Quads string\n   */\n  async canonicalize(store) {\n    const nquads = await this.serializeNQuads(store);\n    return rdfCanonize.canonize(nquads, {\n      algorithm: \"URDNA2015\",\n      format: \"application/n-quads\",\n    });\n  }\n\n  /**\n   * Check if two stores are isomorphic\n   * @param {Store} a - First store\n   * @param {Store} b - Second store\n   * @returns {Promise<boolean>} True if isomorphic\n   */\n  async isIsomorphic(a, b) {\n    const t0 = performance.now();\n    const [ca, cb] = await Promise.all([\n      this.canonicalize(a),\n      this.canonicalize(b),\n    ]);\n    this._metric(\"isomorphic.check\", performance.now() - t0);\n    return ca === cb;\n  }\n\n  // ============== SHACL Validation ==============\n\n  /**\n   * Validate store against SHACL shapes\n   * @param {Store} dataStore - Data store to validate\n   * @param {string|Store} shapesInput - SHACL shapes as Turtle string or Store\n   * @returns {Promise<Object>} Validation report\n   */\n  async validateShacl(dataStore, shapesInput) {\n    const shapesStore = typeof shapesInput === \"string\" \n      ? this.parseTurtle(shapesInput) \n      : shapesInput;\n    \n    const dataDataset = rdf.dataset([...dataStore]);\n    const shapesDataset = rdf.dataset([...shapesStore]);\n    const validator = new SHACLValidator(shapesDataset);\n    \n    const report = await this._withTimeout(\n      () => validator.validate(dataDataset),\n      this.timeoutMs,\n      \"shacl.validate\"\n    );\n    \n    return {\n      conforms: report.conforms,\n      results: report.results.map((r) => ({\n        focusNode: r.focusNode?.value || null,\n        path: r.path?.value || null,\n        message: r.message?.[0]?.value || null,\n        severity: r.severity?.value || null,\n        sourceShape: r.sourceShape?.value || null,\n        value: r.value?.value || null,\n      })),\n    };\n  }\n\n  /**\n   * Validate store against SHACL shapes, throw on failure\n   * @param {Store} dataStore - Data store to validate\n   * @param {string|Store} shapesInput - SHACL shapes\n   * @returns {Promise<Object>} Validation report\n   * @throws {Error} If validation fails\n   */\n  async validateShaclOrThrow(dataStore, shapesInput) {\n    const rep = await this.validateShacl(dataStore, shapesInput);\n    if (!rep.conforms) {\n      const msg = rep.results\n        .map((x) => `[${x.severity}] ${x.path} ${x.message}`)\n        .join(\" ; \");\n      throw new Error(`SHACL validation failed: ${msg}`);\n    }\n    return rep;\n  }\n\n  // ============== SPARQL Query & Update ==============\n\n  /**\n   * Execute SPARQL query with streaming, paging, and timeout\n   * @param {Store} store - Store to query\n   * @param {string} sparql - SPARQL query string\n   * @param {Object} [opts] - Query options\n   * @param {number} [opts.limit] - Result limit\n   * @param {AbortSignal} [opts.signal] - Abort signal\n   * @param {boolean} [opts.deterministic] - Enable deterministic results\n   * @returns {Promise<Object>} Query result\n   */\n  async query(store, sparql, opts = {}) {\n    if (typeof sparql !== \"string\" || !sparql.trim()) {\n      throw new Error(\"query: non-empty SPARQL required\");\n    }\n    \n    const q = sparql.trim();\n    const limit = Number.isFinite(opts.limit) ? opts.limit : Infinity;\n    const deterministic = opts.deterministic ?? this.deterministic;\n    const ctx = { sources: [store] };\n    \n    const kind = q\n      .toUpperCase()\n      .match(/\\b(SELECT|ASK|CONSTRUCT|DESCRIBE|WITH|INSERT|DELETE|LOAD|CREATE|DROP|CLEAR|MOVE|COPY|ADD)\\b/)?.[1];\n    \n    const run = async () => {\n      if (!kind) throw new Error(\"query: unknown query type\");\n      \n      // SPARQL UPDATE\n      if (/^(WITH|INSERT|DELETE|LOAD|CREATE|DROP|CLEAR|MOVE|COPY|ADD)$/i.test(kind)) {\n        await this.engine.queryVoid(q, { ...ctx, destination: store });\n        return { type: \"update\", ok: true };\n      }\n      \n      if (kind === \"ASK\") {\n        const boolean = await this.engine.queryBoolean(q, ctx);\n        return { type: \"ask\", boolean };\n      }\n      \n      if (kind === \"CONSTRUCT\" || kind === \"DESCRIBE\") {\n        const quadStream = await this.engine.queryQuads(q, ctx);\n        const out = new Store();\n        for await (const qq of quadStream) out.add(qq);\n        const quads = deterministic ? this._maybeSort([...out]) : [...out];\n        return { type: kind.toLowerCase(), store: new Store(quads), quads };\n      }\n      \n      // SELECT\n      const bindings = await this.engine.queryBindings(q, ctx);\n      const rows = [];\n      const varSet = new Set();\n      \n      for await (const b of bindings) {\n        for (const k of b.keys()) varSet.add(k.value);\n        const row = {};\n        for (const v of varSet) {\n          const term = b.get(variable(v));\n          row[v] = this._termToJSON(term);\n        }\n        rows.push(row);\n        if (rows.length >= limit) break;\n      }\n      \n      const variables = [...varSet].sort();\n      const results = deterministic \n        ? rows.sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)))\n        : rows;\n      \n      return { type: \"select\", variables, results };\n    };\n    \n    return this._withTimeout(run, this.timeoutMs, \"sparql.query\", opts.signal);\n  }\n\n  // ============== Graph Manipulation ==============\n\n  /**\n   * Get Clownface pointer over an rdf-ext dataset view of the store\n   * @param {Store} store - Store to create pointer for\n   * @returns {Clownface} Clownface pointer\n   */\n  getClownface(store) {\n    const dataset = this.$rdf.dataset();\n    for (const quad of store) {\n      dataset.add(\n        this.$rdf.quad(\n          this.$rdf.namedNode(quad.subject.value),\n          this.$rdf.namedNode(quad.predicate.value),\n          quad.object.termType === \"NamedNode\" \n            ? this.$rdf.namedNode(quad.object.value)\n            : quad.object.termType === \"Literal\"\n            ? this.$rdf.literal(\n                quad.object.value,\n                quad.object.language || quad.object.datatype\n              )\n            : this.$rdf.blankNode(quad.object.value),\n          quad.graph.termType === \"DefaultGraph\"\n            ? this.$rdf.defaultGraph()\n            : quad.graph.termType === \"NamedNode\"\n            ? this.$rdf.namedNode(quad.graph.value)\n            : this.$rdf.blankNode(quad.graph.value)\n        )\n      );\n    }\n    return this.$rdf.clownface({ dataset });\n  }\n\n  // ============== Reasoning ==============\n\n  /**\n   * N3 reasoning with timeout\n   * @param {Store} dataStore - Data store\n   * @param {Store} rulesStore - Rules store\n   * @returns {Promise<Store>} New store with inferred triples\n   */\n  async reason(dataStore, rulesStore) {\n    const run = async () => {\n      const dataN3 = await this.serializeTurtle(dataStore);\n      const rulesN3 = await this.serializeTurtle(rulesStore);\n      const out = await n3reasoner(dataN3, rulesN3);\n      return this.parseTurtle(out);\n    };\n    return this._withTimeout(run, this.timeoutMs, \"reasoning.n3\");\n  }\n\n  // ============== JSON-LD I/O ==============\n\n  /**\n   * Convert store to JSON-LD\n   * @param {Store} store - Store to convert\n   * @param {Object} [opts] - Conversion options\n   * @param {Object} [opts.context] - JSON-LD context\n   * @param {Object} [opts.frame] - JSON-LD frame\n   * @returns {Promise<Object>} JSON-LD document\n   */\n  async toJSONLD(store, opts = {}) {\n    const nquads = await this.serializeNQuads(store);\n    const doc = await jsonld.fromRDF(nquads, { format: \"application/n-quads\" });\n    \n    if (opts.frame) {\n      return jsonld.frame(doc, opts.frame, { omitGraph: false });\n    }\n    \n    const context = opts.context || {};\n    const compacted = await jsonld.compact(doc, context);\n    \n    if (!compacted[\"@context\"]) {\n      compacted[\"@context\"] = context;\n    }\n    \n    return compacted;\n  }\n\n  /**\n   * Convert JSON-LD to store\n   * @param {Object} jsonldDoc - JSON-LD document\n   * @returns {Promise<Store>} N3.Store\n   */\n  async fromJSONLD(jsonldDoc) {\n    const nquads = await jsonld.toRDF(jsonldDoc, {\n      format: \"application/n-quads\",\n    });\n    return this.parseNQuads(nquads);\n  }\n\n  // ============== Set Operations & Utilities ==============\n\n  /**\n   * Union of multiple stores\n   * @param {...Store} stores - Stores to union\n   * @returns {Store} Union store\n   */\n  union(...stores) {\n    const out = new Store();\n    for (const s of stores) {\n      for (const q of s) out.add(q);\n    }\n    return out;\n  }\n\n  /**\n   * Difference between two stores\n   * @param {Store} a - First store\n   * @param {Store} b - Second store\n   * @returns {Store} Difference store\n   */\n  difference(a, b) {\n    const out = new Store();\n    for (const q of a) {\n      if (!b.has(q)) out.add(q);\n    }\n    return out;\n  }\n\n  /**\n   * Intersection of two stores\n   * @param {Store} a - First store\n   * @param {Store} b - Second store\n   * @returns {Store} Intersection store\n   */\n  intersection(a, b) {\n    const out = new Store();\n    for (const q of a) {\n      if (b.has(q)) out.add(q);\n    }\n    return out;\n  }\n\n  /**\n   * Skolemize blank nodes\n   * @param {Store} store - Store to skolemize\n   * @param {string} [baseIRI] - Base IRI for skolemization\n   * @returns {Store} Skolemized store\n   */\n  skolemize(store, baseIRI = \"http://example.org/.well-known/genid/\") {\n    const out = new Store();\n    const map = new Map();\n    let i = 0;\n    \n    const sk = (b) => {\n      if (!map.has(b.value)) {\n        map.set(b.value, namedNode(`${baseIRI}${i++}`));\n      }\n      return map.get(b.value);\n    };\n    \n    for (const qd of store) {\n      const s = qd.subject.termType === \"BlankNode\" ? sk(qd.subject) : qd.subject;\n      const o = qd.object.termType === \"BlankNode\" ? sk(qd.object) : qd.object;\n      out.add(quad(s, qd.predicate, o, qd.graph));\n    }\n    \n    return out;\n  }\n\n  /**\n   * Get statistics about a store\n   * @param {Store} store - Store to analyze\n   * @returns {Object} Statistics object\n   */\n  getStats(store) {\n    const S = new Set(), P = new Set(), O = new Set(), G = new Set();\n    for (const q of store) {\n      S.add(q.subject.value);\n      P.add(q.predicate.value);\n      O.add(q.object.value);\n      G.add(q.graph.value);\n    }\n    return {\n      quads: store.size,\n      subjects: S.size,\n      predicates: P.size,\n      objects: O.size,\n      graphs: G.size,\n    };\n  }\n\n  // ============== Internals ==============\n\n  /**\n   * Sort quads deterministically if enabled\n   * @param {Array} quads - Quads to sort\n   * @returns {Array} Sorted quads\n   * @private\n   */\n  _maybeSort(quads) {\n    if (!this.deterministic) return quads;\n    return quads.sort((a, b) => \n      `${a.subject.value}${a.predicate.value}${a.object.value}${a.graph.value}`.localeCompare(\n        `${b.subject.value}${b.predicate.value}${b.object.value}${b.graph.value}`\n      )\n    );\n  }\n\n  /**\n   * Convert RDF term to JSON representation\n   * @param {Term} term - RDF term\n   * @returns {Object} JSON representation\n   * @private\n   */\n  _termToJSON(term) {\n    if (!term) return null;\n    const out = { termType: term.termType, value: term.value };\n    if (term.termType === \"Literal\") {\n      if (term.language) out.language = term.language;\n      if (term.datatype?.value) out.datatype = term.datatype.value;\n    }\n    return out;\n  }\n\n  /**\n   * Execute function with timeout\n   * @param {Function} fn - Function to execute\n   * @param {number} ms - Timeout in milliseconds\n   * @param {string} label - Operation label\n   * @param {AbortSignal} [externalSignal] - External abort signal\n   * @returns {Promise} Function result\n   * @private\n   */\n  async _withTimeout(fn, ms, label, externalSignal) {\n    const controller = new AbortController();\n    const timer = setTimeout(\n      () => controller.abort(new Error(`${label} timeout after ${ms}ms`)),\n      ms\n    );\n    \n    const t0 = performance.now();\n    try {\n      const res = await fn({ signal: controller.signal, externalSignal });\n      this._metric(label, performance.now() - t0);\n      return res;\n    } catch (error) {\n      this.log.error(`${label} failed:`, error.message);\n      throw error;\n    } finally {\n      clearTimeout(timer);\n    }\n  }\n\n  /**\n   * Record metric\n   * @param {string} event - Event name\n   * @param {number} durMs - Duration in milliseconds\n   * @private\n   */\n  _metric(event, durMs) {\n    if (this.onMetric) {\n      try {\n        this.onMetric({ event, durMs });\n      } catch {\n        // ignore metrics errors\n      }\n    }\n  }\n\n  /**\n   * Extract common prefixes from store\n   * @param {Store} store - Store to analyze\n   * @returns {Object} Prefix mappings\n   * @private\n   */\n  _extractPrefixes(store) {\n    const prefixes = {};\n    const uris = new Set();\n    \n    // Collect all URIs from the store\n    for (const quad of store) {\n      if (quad.subject.termType === \"NamedNode\") uris.add(quad.subject.value);\n      if (quad.predicate.termType === \"NamedNode\") uris.add(quad.predicate.value);\n      if (quad.object.termType === \"NamedNode\") uris.add(quad.object.value);\n      if (quad.graph.termType === \"NamedNode\") uris.add(quad.graph.value);\n    }\n    \n    // Extract common prefixes\n    const commonPrefixes = {\n      \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\": \"rdf\",\n      \"http://www.w3.org/2000/01/rdf-schema#\": \"rdfs\",\n      \"http://www.w3.org/2001/XMLSchema#\": \"xsd\",\n      \"http://xmlns.com/foaf/0.1/\": \"foaf\",\n      \"http://purl.org/dc/terms/\": \"dct\",\n      \"http://www.w3.org/ns/shacl#\": \"sh\",\n      \"https://gitvan.dev/ontology#\": \"gv\",\n      \"https://gitvan.dev/graph-hook#\": \"gh\",\n      \"https://gitvan.dev/op#\": \"op\",\n    };\n    \n    // Find the best prefix for each URI\n    for (const uri of uris) {\n      for (const [prefixUri, prefixName] of Object.entries(commonPrefixes)) {\n        if (uri.startsWith(prefixUri)) {\n          prefixes[prefixName] = prefixUri;\n          break;\n        }\n      }\n    }\n    \n    // Add example.org prefix if present\n    const exampleUris = Array.from(uris).filter(uri => \n      uri.startsWith(\"http://example.org/\")\n    );\n    if (exampleUris.length > 0) {\n      prefixes[\"ex\"] = \"http://example.org/\";\n    }\n    \n    return prefixes;\n  }\n}\n"
        }
    ]
}