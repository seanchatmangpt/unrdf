{
    "sourceFile": "src/composables/useReasoner.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015538,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015538,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useReasoner composable - EYE/N3 reasoning operations\n * \n * This composable provides reasoning capabilities using the EYE reasoner.\n * It enforces the \"One Reasoner Rule\" - EYE is the only reasoning engine.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { RdfEngine } from \"../engines/RdfEngine.mjs\";\nimport { useGraph } from \"./useGraph.mjs\";\n\n// Create a single, shared instance of the engine for efficiency\nconst rdfEngine = new RdfEngine();\n\n/**\n * Create a reasoner composable\n * \n * @param {Object} [options] - Reasoner options\n * @param {number} [options.timeoutMs=30000] - Reasoning timeout\n * @param {Function} [options.onMetric] - Metrics callback\n * @returns {Object} Reasoner interface\n * \n * @example\n * const reasoner = useReasoner();\n * \n * // Reason over data with rules\n * const inferred = await reasoner.reason(dataStore, rulesStore);\n * \n * // Reason with timeout\n * const reasoner = useReasoner({ timeoutMs: 60000 });\n */\nexport function useReasoner(options = {}) {\n  const {\n    timeoutMs = 30000,\n    onMetric\n  } = options;\n\n  const engine = new RdfEngine({ \n    timeoutMs,\n    onMetric \n  });\n\n  return {\n    /**\n     * The underlying RDF engine\n     * @type {RdfEngine}\n     */\n    get engine() {\n      return engine;\n    },\n\n    /**\n     * Apply reasoning rules to a data store\n     * @param {Store|Object} dataStore - Data store to reason over\n     * @param {string|Store|Object} rulesInput - Rules as Turtle string or Store\n     * @returns {Promise<Object>} New useGraph instance with inferred triples\n     * \n     * @example\n     * const inferred = await reasoner.reason(dataStore, rulesStore);\n     * console.log(`Inferred ${inferred.size} new triples`);\n     * \n     * // Use with Turtle rules\n     * const rules = `\n     *   @prefix ex: <http://example.org/> .\n     *   { ?s ex:parent ?p } => { ?s ex:ancestor ?p } .\n     * `;\n     * const inferred = await reasoner.reason(dataStore, rules);\n     */\n    async reason(dataStore, rulesInput) {\n      const dataStoreInstance = dataStore.store || dataStore;\n      const rulesStore = typeof rulesInput === \"string\" \n        ? engine.parseTurtle(rulesInput)\n        : rulesInput.store || rulesInput;\n      \n      const inferredStore = await engine.reason(dataStoreInstance, rulesStore);\n      return useGraph(inferredStore);\n    },\n\n    /**\n     * Apply multiple rule sets sequentially\n     * @param {Store|Object} dataStore - Data store to reason over\n     * @param {Array<string|Store|Object>} rulesInputs - Array of rule sets\n     * @returns {Promise<Object>} New useGraph instance with all inferred triples\n     * \n     * @example\n     * const inferred = await reasoner.reasonSequentially(dataStore, [rules1, rules2, rules3]);\n     */\n    async reasonSequentially(dataStore, rulesInputs) {\n      let currentStore = dataStore.store || dataStore;\n      \n      for (const rulesInput of rulesInputs) {\n        const rulesStore = typeof rulesInput === \"string\" \n          ? engine.parseTurtle(rulesInput)\n          : rulesInput.store || rulesInput;\n        \n        currentStore = await engine.reason(currentStore, rulesStore);\n      }\n      \n      return useGraph(currentStore);\n    },\n\n    /**\n     * Apply multiple rule sets in parallel and merge results\n     * @param {Store|Object} dataStore - Data store to reason over\n     * @param {Array<string|Store|Object>} rulesInputs - Array of rule sets\n     * @returns {Promise<Object>} New useGraph instance with merged inferred triples\n     * \n     * @example\n     * const inferred = await reasoner.reasonParallel(dataStore, [rules1, rules2, rules3]);\n     */\n    async reasonParallel(dataStore, rulesInputs) {\n      const dataStoreInstance = dataStore.store || dataStore;\n      \n      const promises = rulesInputs.map(rulesInput => {\n        const rulesStore = typeof rulesInput === \"string\" \n          ? engine.parseTurtle(rulesInput)\n          : rulesInput.store || rulesInput;\n        \n        return engine.reason(dataStoreInstance, rulesStore);\n      });\n      \n      const results = await Promise.all(promises);\n      const mergedStore = engine.union(...results);\n      \n      return useGraph(mergedStore);\n    },\n\n    /**\n     * Get the difference between original and inferred triples\n     * @param {Store|Object} originalStore - Original data store\n     * @param {Store|Object} inferredStore - Store with inferred triples\n     * @returns {Object} New useGraph instance with only new triples\n     * \n     * @example\n     * const inferred = await reasoner.reason(dataStore, rules);\n     * const newTriples = reasoner.getNewTriples(dataStore, inferred);\n     * console.log(`Found ${newTriples.size} new triples`);\n     */\n    getNewTriples(originalStore, inferredStore) {\n      const original = originalStore.store || originalStore;\n      const inferred = inferredStore.store || inferredStore;\n      const newStore = engine.difference(inferred, original);\n      return useGraph(newStore);\n    },\n\n    /**\n     * Check if reasoning would produce new triples\n     * @param {Store|Object} dataStore - Data store to reason over\n     * @param {string|Store|Object} rulesInput - Rules to apply\n     * @returns {Promise<boolean>} True if reasoning would produce new triples\n     * \n     * @example\n     * const wouldProduceNew = await reasoner.wouldProduceNewTriples(dataStore, rules);\n     * if (wouldProduceNew) {\n     *   console.log(\"Reasoning would add new knowledge\");\n     * }\n     */\n    async wouldProduceNewTriples(dataStore, rulesInput) {\n      const inferred = await this.reason(dataStore, rulesInput);\n      const newTriples = this.getNewTriples(dataStore, inferred);\n      return newTriples.size > 0;\n    },\n\n    /**\n     * Get statistics about reasoning results\n     * @param {Store|Object} originalStore - Original data store\n     * @param {Store|Object} inferredStore - Store with inferred triples\n     * @returns {Object} Reasoning statistics\n     * \n     * @example\n     * const inferred = await reasoner.reason(dataStore, rules);\n     * const stats = reasoner.getStats(dataStore, inferred);\n     * console.log(`Original: ${stats.original.quads}, Inferred: ${stats.inferred.quads}, New: ${stats.new.quads}`);\n     */\n    getStats(originalStore, inferredStore) {\n      const original = originalStore.store || originalStore;\n      const inferred = inferredStore.store || inferredStore;\n      const newStore = engine.difference(inferred, original);\n      \n      return {\n        original: engine.getStats(original),\n        inferred: engine.getStats(inferred),\n        new: engine.getStats(newStore),\n        growth: {\n          absolute: inferred.size - original.size,\n          percentage: original.size > 0 ? ((inferred.size - original.size) / original.size) * 100 : 0\n        }\n      };\n    },\n\n    /**\n     * Create a reasoning pipeline with multiple steps\n     * @param {Array<Object>} steps - Array of reasoning steps\n     * @returns {Object} Pipeline interface\n     * \n     * @example\n     * const pipeline = reasoner.createPipeline([\n     *   { name: \"transitive\", rules: transitiveRules },\n     *   { name: \"symmetric\", rules: symmetricRules },\n     *   { name: \"inverse\", rules: inverseRules }\n     * ]);\n     * \n     * const result = await pipeline.execute(dataStore);\n     */\n    createPipeline(steps) {\n      return {\n        steps,\n        \n        /**\n         * Execute the reasoning pipeline\n         * @param {Store|Object} dataStore - Data store to reason over\n         * @returns {Promise<Object>} Final useGraph instance\n         */\n        async execute(dataStore) {\n          let currentStore = dataStore.store || dataStore;\n          const results = [];\n          \n          for (const step of this.steps) {\n            const startTime = performance.now();\n            const rulesStore = typeof step.rules === \"string\" \n              ? engine.parseTurtle(step.rules)\n              : step.rules.store || step.rules;\n            \n            const beforeSize = currentStore.size;\n            currentStore = await engine.reason(currentStore, rulesStore);\n            const afterSize = currentStore.size;\n            const duration = performance.now() - startTime;\n            \n            results.push({\n              name: step.name,\n              beforeSize,\n              afterSize,\n              newTriples: afterSize - beforeSize,\n              duration\n            });\n          }\n          \n          return {\n            result: useGraph(currentStore),\n            steps: results\n          };\n        }\n      };\n    }\n  };\n}\n"
        }
    ]
}