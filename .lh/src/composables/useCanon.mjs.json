{
    "sourceFile": "src/composables/useCanon.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015526,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useCanon composable - canonicalization and isomorphism operations\n * \n * This composable provides canonicalization and isomorphism checking capabilities.\n * It enforces the \"One Canonicalization Rule\" - URDNA2015 is the only method.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { RdfEngine } from \"../engines/RdfEngine.mjs\";\n\n// Create a single, shared instance of the engine for efficiency\nconst rdfEngine = new RdfEngine();\n\n/**\n * Create a canonicalization composable\n * \n * @param {Object} [options] - Canonicalization options\n * @param {number} [options.timeoutMs=30000] - Canonicalization timeout\n * @param {Function} [options.onMetric] - Metrics callback\n * @returns {Object} Canonicalization interface\n * \n * @example\n * const canon = useCanon();\n * \n * // Canonicalize a store\n * const canonical = await canon.canonicalize(store);\n * \n * // Check if two stores are isomorphic\n * const isIsomorphic = await canon.isIsomorphic(store1, store2);\n */\nexport function useCanon(options = {}) {\n  const {\n    timeoutMs = 30000,\n    onMetric\n  } = options;\n\n  const engine = new RdfEngine({ \n    timeoutMs,\n    onMetric \n  });\n\n  return {\n    /**\n     * The underlying RDF engine\n     * @type {RdfEngine}\n     */\n    get engine() {\n      return engine;\n    },\n\n    /**\n     * Canonicalize a store using URDNA2015\n     * @param {Store|Object} store - Store to canonicalize\n     * @returns {Promise<string>} Canonical N-Quads string\n     * \n     * @example\n     * const canonical = await canon.canonicalize(store);\n     * console.log(\"Canonical form:\", canonical);\n     */\n    async canonicalize(store) {\n      const storeInstance = store.store || store;\n      return engine.canonicalize(storeInstance);\n    },\n\n    /**\n     * Check if two stores are isomorphic\n     * @param {Store|Object} store1 - First store\n     * @param {Store|Object} store2 - Second store\n     * @returns {Promise<boolean>} True if stores are isomorphic\n     * \n     * @example\n     * const isIsomorphic = await canon.isIsomorphic(store1, store2);\n     * if (isIsomorphic) {\n     *   console.log(\"Stores are logically equivalent\");\n     * }\n     */\n    async isIsomorphic(store1, store2) {\n      const s1 = store1.store || store1;\n      const s2 = store2.store || store2;\n      return engine.isIsomorphic(s1, s2);\n    },\n\n    /**\n     * Get a canonical hash of a store\n     * @param {Store|Object} store - Store to hash\n     * @returns {Promise<string>} Canonical hash string\n     * \n     * @example\n     * const hash = await canon.hash(store);\n     * console.log(\"Store hash:\", hash);\n     */\n    async hash(store) {\n      const canonical = await this.canonicalize(store);\n      // Simple hash function - in production you might want crypto.createHash\n      let hash = 0;\n      for (let i = 0; i < canonical.length; i++) {\n        const char = canonical.charCodeAt(i);\n        hash = ((hash << 5) - hash) + char;\n        hash = hash & hash; // Convert to 32-bit integer\n      }\n      return hash.toString(16);\n    },\n\n    /**\n     * Check if multiple stores are all isomorphic\n     * @param {Array<Store|Object>} stores - Array of stores to check\n     * @returns {Promise<boolean>} True if all stores are isomorphic\n     * \n     * @example\n     * const allIsomorphic = await canon.allIsomorphic([store1, store2, store3]);\n     * if (allIsomorphic) {\n     *   console.log(\"All stores are equivalent\");\n     * }\n     */\n    async allIsomorphic(stores) {\n      if (stores.length < 2) return true;\n      \n      const first = stores[0].store || stores[0];\n      for (let i = 1; i < stores.length; i++) {\n        const current = stores[i].store || stores[i];\n        if (!(await engine.isIsomorphic(first, current))) {\n          return false;\n        }\n      }\n      return true;\n    },\n\n    /**\n     * Find stores that are isomorphic to a reference store\n     * @param {Store|Object} referenceStore - Reference store\n     * @param {Array<Store|Object>} stores - Array of stores to check\n     * @returns {Promise<Array<{store: Store, index: number}>>} Array of isomorphic stores\n     * \n     * @example\n     * const isomorphic = await canon.findIsomorphic(referenceStore, [store1, store2, store3]);\n     * console.log(`Found ${isomorphic.length} isomorphic stores`);\n     */\n    async findIsomorphic(referenceStore, stores) {\n      const reference = referenceStore.store || referenceStore;\n      const results = [];\n      \n      for (let i = 0; i < stores.length; i++) {\n        const current = stores[i].store || stores[i];\n        if (await engine.isIsomorphic(reference, current)) {\n          results.push({ store: stores[i], index: i });\n        }\n      }\n      \n      return results;\n    },\n\n    /**\n     * Group stores by isomorphism\n     * @param {Array<Store|Object>} stores - Array of stores to group\n     * @returns {Promise<Array<Array<{store: Store, index: number}>>>} Groups of isomorphic stores\n     * \n     * @example\n     * const groups = await canon.groupByIsomorphism([store1, store2, store3, store4]);\n     * console.log(`Found ${groups.length} distinct groups`);\n     */\n    async groupByIsomorphism(stores) {\n      const groups = [];\n      const processed = new Set();\n      \n      for (let i = 0; i < stores.length; i++) {\n        if (processed.has(i)) continue;\n        \n        const current = stores[i].store || stores[i];\n        const group = [{ store: stores[i], index: i }];\n        processed.add(i);\n        \n        for (let j = i + 1; j < stores.length; j++) {\n          if (processed.has(j)) continue;\n          \n          const other = stores[j].store || stores[j];\n          if (await engine.isIsomorphic(current, other)) {\n            group.push({ store: stores[j], index: j });\n            processed.add(j);\n          }\n        }\n        \n        groups.push(group);\n      }\n      \n      return groups;\n    },\n\n    /**\n     * Get canonical statistics for a store\n     * @param {Store|Object} store - Store to analyze\n     * @returns {Promise<Object>} Canonical statistics\n     * \n     * @example\n     * const stats = await canon.getStats(store);\n     * console.log(`Canonical size: ${stats.canonicalSize}, Hash: ${stats.hash}`);\n     */\n    async getStats(store) {\n      const storeInstance = store.store || store;\n      const canonical = await this.canonicalize(store);\n      const hash = await this.hash(store);\n      \n      return {\n        originalSize: storeInstance.size,\n        canonicalSize: canonical.length,\n        hash,\n        canonical\n      };\n    },\n\n    /**\n     * Compare two stores and return detailed comparison\n     * @param {Store|Object} store1 - First store\n     * @param {Store|Object} store2 - Second store\n     * @returns {Promise<Object>} Detailed comparison result\n     * \n     * @example\n     * const comparison = await canon.compare(store1, store2);\n     * console.log(`Isomorphic: ${comparison.isomorphic}, Hash match: ${comparison.hashMatch}`);\n     */\n    async compare(store1, store2) {\n      const s1 = store1.store || store1;\n      const s2 = store2.store || store2;\n      \n      const [canonical1, canonical2, hash1, hash2] = await Promise.all([\n        this.canonicalize(store1),\n        this.canonicalize(store2),\n        this.hash(store1),\n        this.hash(store2)\n      ]);\n      \n      const isomorphic = canonical1 === canonical2;\n      const hashMatch = hash1 === hash2;\n      \n      return {\n        isomorphic,\n        hashMatch,\n        canonical1,\n        canonical2,\n        hash1,\n        hash2,\n        size1: s1.size,\n        size2: s2.size,\n        sizeDifference: s2.size - s1.size\n      };\n    },\n\n    /**\n     * Create a canonical store from multiple stores (union + canonicalize)\n     * @param {Array<Store|Object>} stores - Array of stores to merge\n     * @returns {Promise<Object>} New useGraph instance with canonical store\n     * \n     * @example\n     * const canonical = await canon.createCanonicalStore([store1, store2, store3]);\n     * console.log(`Canonical store has ${canonical.size} triples`);\n     */\n    async createCanonicalStore(stores) {\n      const storeInstances = stores.map(s => s.store || s);\n      const unionStore = engine.union(...storeInstances);\n      const canonical = await engine.canonicalize(unionStore);\n      const canonicalStore = engine.parseNQuads(canonical);\n      \n      return {\n        store: canonicalStore,\n        canonical,\n        hash: await this.hash(canonicalStore),\n        size: canonicalStore.size\n      };\n    }\n  };\n}\n"
        }
    ]
}