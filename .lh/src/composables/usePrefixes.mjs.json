{
    "sourceFile": "src/composables/usePrefixes.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758658176142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758658176142,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview usePrefixes composable - prefix management and CURIE operations\n * \n * This composable provides prefix management capabilities for RDF operations.\n * It enforces the \"One Prefix Rule\" - centralized prefix management.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\n/**\n * Create a prefixes composable for prefix management\n * \n * @param {Object} [initialPrefixes] - Initial prefix mappings\n * @param {Object} [options] - Prefix options\n * @param {boolean} [options.caseSensitive=false] - Case sensitive prefix matching\n * @returns {Object} Prefix management interface\n * \n * @example\n * const prefixes = usePrefixes({\n *   \"ex\": \"http://example.org/\",\n *   \"foaf\": \"http://xmlns.com/foaf/0.1/\"\n * });\n * \n * // Register new prefixes\n * prefixes.register({ \"dc\": \"http://purl.org/dc/terms/\" });\n * \n * // Expand CURIEs\n * const fullIRI = prefixes.expand(\"ex:Person\");\n * \n * // Shrink IRIs\n * const curie = prefixes.shrink(\"http://example.org/Person\");\n * \n * // List all prefixes\n * const allPrefixes = prefixes.list();\n */\nexport function usePrefixes(initialPrefixes = {}, options = {}) {\n  const { caseSensitive = false } = options;\n  \n  // Internal prefix map\n  const prefixes = new Map();\n  \n  // Initialize with provided prefixes\n  Object.entries(initialPrefixes).forEach(([prefix, uri]) => {\n    prefixes.set(prefix, uri);\n  });\n\n  return {\n    /**\n     * Register prefix mappings\n     * @param {Object} prefixMap - Object mapping prefixes to URIs\n     * @returns {Object} This composable instance\n     */\n    register(prefixMap) {\n      if (typeof prefixMap !== \"object\" || prefixMap === null) {\n        throw new Error(\"[usePrefixes] Prefix map must be an object\");\n      }\n      \n      Object.entries(prefixMap).forEach(([prefix, uri]) => {\n        if (typeof prefix !== \"string\" || typeof uri !== \"string\") {\n          throw new Error(\"[usePrefixes] Prefix and URI must be strings\");\n        }\n        \n        if (!uri.endsWith(\"/\") && !uri.endsWith(\"#\")) {\n          throw new Error(\"[usePrefixes] URI should end with '/' or '#'\");\n        }\n        \n        prefixes.set(prefix, uri);\n      });\n      \n      return this;\n    },\n\n    /**\n     * Expand a CURIE to a full IRI\n     * @param {string} curie - The CURIE to expand\n     * @returns {string} The expanded IRI\n     */\n    expand(curie) {\n      if (typeof curie !== \"string\") {\n        throw new Error(\"[usePrefixes] CURIE must be a string\");\n      }\n      \n      const colonIndex = curie.indexOf(\":\");\n      if (colonIndex === -1) {\n        // Not a CURIE, return as-is\n        return curie;\n      }\n      \n      const prefix = curie.substring(0, colonIndex);\n      const localName = curie.substring(colonIndex + 1);\n      \n      if (!prefix || !localName) {\n        throw new Error(\"[usePrefixes] Invalid CURIE format\");\n      }\n      \n      const uri = prefixes.get(prefix);\n      if (!uri) {\n        throw new Error(`[usePrefixes] Unknown prefix: ${prefix}`);\n      }\n      \n      return uri + localName;\n    },\n\n    /**\n     * Shrink a full IRI to a CURIE\n     * @param {string} iri - The IRI to shrink\n     * @returns {string} The CURIE or original IRI if no prefix matches\n     */\n    shrink(iri) {\n      if (typeof iri !== \"string\") {\n        throw new Error(\"[usePrefixes] IRI must be a string\");\n      }\n      \n      // Find the longest matching prefix\n      let bestMatch = { prefix: null, uri: null, length: 0 };\n      \n      for (const [prefix, uri] of prefixes.entries()) {\n        if (iri.startsWith(uri) && uri.length > bestMatch.length) {\n          bestMatch = { prefix, uri, length: uri.length };\n        }\n      }\n      \n      if (bestMatch.prefix) {\n        const localName = iri.substring(bestMatch.length);\n        return `${bestMatch.prefix}:${localName}`;\n      }\n      \n      return iri;\n    },\n\n    /**\n     * Get all registered prefixes\n     * @returns {Object} Object mapping prefixes to URIs\n     */\n    list() {\n      return Object.fromEntries(prefixes);\n    },\n\n    /**\n     * Check if a prefix is registered\n     * @param {string} prefix - The prefix to check\n     * @returns {boolean} True if prefix is registered\n     */\n    has(prefix) {\n      return prefixes.has(prefix);\n    },\n\n    /**\n     * Get the URI for a prefix\n     * @param {string} prefix - The prefix\n     * @returns {string|undefined} The URI or undefined if not found\n     */\n    get(prefix) {\n      return prefixes.get(prefix);\n    },\n\n    /**\n     * Remove a prefix\n     * @param {string} prefix - The prefix to remove\n     * @returns {boolean} True if prefix was removed\n     */\n    remove(prefix) {\n      return prefixes.delete(prefix);\n    },\n\n    /**\n     * Clear all prefixes\n     * @returns {Object} This composable instance\n     */\n    clear() {\n      prefixes.clear();\n      return this;\n    },\n\n    /**\n     * Get the number of registered prefixes\n     * @returns {number} Number of prefixes\n     */\n    size() {\n      return prefixes.size;\n    }\n  };\n}"
        }
    ]
}