{
    "sourceFile": "src/composables/useTerms.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758658176142,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758658176142,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useTerms composable - RDF term creation and manipulation\n * \n * This composable provides the foundation for creating RDF terms.\n * It enforces the \"One Terms Rule\" - N3 DataFactory is the only term creation method.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { DataFactory } from \"n3\";\n\nconst { namedNode, literal, blankNode, quad, defaultGraph } = DataFactory;\n\n/**\n * Create a terms composable for RDF term creation\n * \n * @param {Object} [options] - Terms options\n * @param {string} [options.baseIRI] - Base IRI for relative IRIs\n * @param {string} [options.defaultDatatype] - Default datatype for literals\n * @returns {Object} Terms creation interface\n * \n * @example\n * const terms = useTerms();\n * \n * // Create named nodes\n * const subject = terms.iri(\"http://example.org/person\");\n * \n * // Create literals\n * const name = terms.lit(\"John Doe\");\n * const age = terms.lit(30, \"http://www.w3.org/2001/XMLSchema#integer\");\n * \n * // Create blank nodes\n * const bnode = terms.bnode(\"person1\");\n * \n * // Create quads\n * const statement = terms.quad(subject, terms.iri(\"http://example.org/name\"), name);\n */\nexport function useTerms(options = {}) {\n  const {\n    baseIRI = \"http://example.org/\",\n    defaultDatatype = \"http://www.w3.org/2001/XMLSchema#string\"\n  } = options;\n\n  return {\n    /**\n     * Create a named node (IRI)\n     * @param {string} iri - The IRI string\n     * @returns {NamedNode} Named node term\n     */\n    iri(iri) {\n      if (typeof iri !== \"string\") {\n        throw new Error(\"[useTerms] IRI must be a string\");\n      }\n      \n      // Handle relative IRIs\n      if (iri.startsWith(\"#\") || iri.startsWith(\"/\")) {\n        iri = baseIRI + iri;\n      }\n      \n      return namedNode(iri);\n    },\n\n    /**\n     * Create a literal\n     * @param {string|number|boolean} value - The literal value\n     * @param {string} [datatype] - The datatype IRI\n     * @param {string} [language] - The language tag\n     * @returns {Literal} Literal term\n     */\n    lit(value, datatype, language) {\n      if (value === null || value === undefined) {\n        throw new Error(\"[useTerms] Literal value cannot be null or undefined\");\n      }\n      \n      // Convert to string if needed\n      const stringValue = String(value);\n      \n      // Handle language tags\n      if (language) {\n        return literal(stringValue, language);\n      }\n      \n      // Handle datatypes\n      if (datatype) {\n        return literal(stringValue, datatype);\n      }\n      \n      // Use default datatype\n      return literal(stringValue, defaultDatatype);\n    },\n\n    /**\n     * Create a blank node\n     * @param {string} [id] - Optional blank node ID\n     * @returns {BlankNode} Blank node term\n     */\n    bnode(id) {\n      if (id !== undefined && typeof id !== \"string\") {\n        throw new Error(\"[useTerms] Blank node ID must be a string\");\n      }\n      \n      return blankNode(id);\n    },\n\n    /**\n     * Create a quad (statement)\n     * @param {Term} subject - The subject term\n     * @param {Term} predicate - The predicate term\n     * @param {Term} object - The object term\n     * @param {Term} [graph] - The graph term (optional)\n     * @returns {Quad} Quad term\n     */\n    quad(subject, predicate, object, graph) {\n      if (!subject || !predicate || !object) {\n        throw new Error(\"[useTerms] Subject, predicate, and object are required\");\n      }\n      \n      return quad(subject, predicate, object, graph || defaultGraph());\n    },\n\n    /**\n     * Create a default graph term\n     * @returns {DefaultGraph} Default graph term\n     */\n    defaultGraph() {\n      return defaultGraph();\n    },\n\n    /**\n     * Get the base IRI\n     * @returns {string} Base IRI\n     */\n    getBaseIRI() {\n      return baseIRI;\n    },\n\n    /**\n     * Get the default datatype\n     * @returns {string} Default datatype\n     */\n    getDefaultDatatype() {\n      return defaultDatatype;\n    }\n  };\n}"
        }
    ]
}