{
    "sourceFile": "src/composables/useGraph.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015526,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useGraph composable - high-level RDF graph operations\n * \n * This composable provides the main interface for RDF operations.\n * It wraps a store with common graph operations like SPARQL queries,\n * set operations, and traversal utilities.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { RdfEngine } from \"../engines/RdfEngine.mjs\";\n\n// Create a single, shared instance of the engine for efficiency\nconst rdfEngine = new RdfEngine();\n\n/**\n * Create a graph composable for operating on an RDF store\n * \n * @param {Store} store - N3.Store instance to operate on\n * @returns {Object} Graph operations interface\n * \n * @example\n * const store = useStore();\n * const graph = useGraph(store);\n * \n * // SPARQL SELECT query\n * const results = await graph.select(`\n *   PREFIX ex: <http://example.org/>\n *   SELECT ?s ?p ?o WHERE { ?s ?p ?o }\n * `);\n * \n * // SPARQL ASK query\n * const exists = await graph.ask(`\n *   PREFIX ex: <http://example.org/>\n *   ASK { ex:subject ex:predicate ?o }\n * `);\n * \n * // Set operations\n * const otherGraph = useGraph(otherStore);\n * const union = graph.union(otherGraph);\n * const diff = graph.difference(otherGraph);\n */\nexport function useGraph(store) {\n  if (!store || typeof store.getQuads !== \"function\") {\n    throw new Error(\"[useGraph] An N3.Store instance must be provided.\");\n  }\n\n  return {\n    /**\n     * The raw N3.Store instance being operated on\n     * @type {Store}\n     */\n    get store() {\n      return store;\n    },\n\n    /**\n     * The underlying RDF engine\n     * @type {RdfEngine}\n     */\n    get engine() {\n      return rdfEngine;\n    },\n\n    /**\n     * Execute any valid SPARQL 1.1 query\n     * @param {string} sparql - SPARQL query string\n     * @param {Object} [options] - Query options\n     * @param {number} [options.limit] - Result limit\n     * @param {AbortSignal} [options.signal] - Abort signal\n     * @returns {Promise<Object>} Query result object\n     */\n    async query(sparql, options) {\n      return rdfEngine.query(store, sparql, options);\n    },\n\n    /**\n     * Execute a SPARQL SELECT query\n     * @param {string} sparql - SPARQL SELECT query string\n     * @returns {Promise<Array<Object>>} Array of result bindings\n     */\n    async select(sparql) {\n      const res = await rdfEngine.query(store, sparql);\n      if (res.type !== \"select\") {\n        throw new Error(\"Query is not a SELECT query.\");\n      }\n      return res.results;\n    },\n\n    /**\n     * Execute a SPARQL ASK query\n     * @param {string} sparql - SPARQL ASK query string\n     * @returns {Promise<boolean>} Boolean result\n     */\n    async ask(sparql) {\n      const res = await rdfEngine.query(store, sparql);\n      if (res.type !== \"ask\") {\n        throw new Error(\"Query is not an ASK query.\");\n      }\n      return res.boolean;\n    },\n\n    /**\n     * Execute a SPARQL CONSTRUCT query\n     * @param {string} sparql - SPARQL CONSTRUCT query string\n     * @returns {Promise<Store>} New store with constructed triples\n     */\n    async construct(sparql) {\n      const res = await rdfEngine.query(store, sparql);\n      if (res.type !== \"construct\") {\n        throw new Error(\"Query is not a CONSTRUCT query.\");\n      }\n      return res.store;\n    },\n\n    /**\n     * Execute a SPARQL UPDATE query\n     * @param {string} sparql - SPARQL UPDATE query string\n     * @returns {Promise<Object>} Update result\n     */\n    async update(sparql) {\n      const res = await rdfEngine.query(store, sparql);\n      if (res.type !== \"update\") {\n        throw new Error(\"Query is not an UPDATE query.\");\n      }\n      return res;\n    },\n\n    /**\n     * Validate the graph against SHACL shapes\n     * @param {string|Store} shapesInput - SHACL shapes as Turtle string or Store\n     * @returns {Promise<Object>} Validation report\n     */\n    async validate(shapesInput) {\n      return rdfEngine.validateShacl(store, shapesInput);\n    },\n\n    /**\n     * Validate the graph against SHACL shapes, throw on failure\n     * @param {string|Store} shapesInput - SHACL shapes\n     * @returns {Promise<Object>} Validation report\n     * @throws {Error} If validation fails\n     */\n    async validateOrThrow(shapesInput) {\n      return rdfEngine.validateShaclOrThrow(store, shapesInput);\n    },\n\n    /**\n     * Serialize the graph to a string\n     * @param {Object} [options] - Serialization options\n     * @param {string} [options.format='Turtle'] - Output format\n     * @param {Object} [options.prefixes] - Prefix mappings\n     * @returns {Promise<string>} Serialized string\n     */\n    async serialize(options = {}) {\n      const { format = \"Turtle\", prefixes } = options;\n      \n      if (format === \"Turtle\") {\n        return await rdfEngine.serializeTurtle(store, { prefixes });\n      }\n      if (format === \"N-Quads\") {\n        return await rdfEngine.serializeNQuads(store);\n      }\n      \n      throw new Error(`Unsupported serialization format: ${format}`);\n    },\n\n    /**\n     * Get a Clownface pointer for fluent graph traversal\n     * @returns {Clownface} Clownface pointer\n     */\n    pointer() {\n      return rdfEngine.getClownface(store);\n    },\n\n    /**\n     * Get basic statistics about the graph\n     * @type {Object}\n     */\n    get stats() {\n      return rdfEngine.getStats(store);\n    },\n\n    /**\n     * Check if this graph is isomorphic to another\n     * @param {Object|Store} otherGraph - Another useGraph instance or Store\n     * @returns {Promise<boolean>} True if isomorphic\n     */\n    async isIsomorphic(otherGraph) {\n      const otherStore = otherGraph.store || otherGraph;\n      return rdfEngine.isIsomorphic(store, otherStore);\n    },\n\n    /**\n     * Create a new graph containing the union of this graph and others\n     * @param {...Object|Store} otherGraphs - Other useGraph instances or Stores\n     * @returns {Object} New useGraph instance with union\n     */\n    union(...otherGraphs) {\n      const otherStores = otherGraphs.map(g => g.store || g);\n      const resultStore = rdfEngine.union(store, ...otherStores);\n      return useGraph(resultStore);\n    },\n\n    /**\n     * Create a new graph containing quads in this graph but not in the other\n     * @param {Object|Store} otherGraph - Another useGraph instance or Store\n     * @returns {Object} New useGraph instance with difference\n     */\n    difference(otherGraph) {\n      const otherStore = otherGraph.store || otherGraph;\n      const resultStore = rdfEngine.difference(store, otherStore);\n      return useGraph(resultStore);\n    },\n\n    /**\n     * Create a new graph containing only quads that exist in both graphs\n     * @param {Object|Store} otherGraph - Another useGraph instance or Store\n     * @returns {Object} New useGraph instance with intersection\n     */\n    intersection(otherGraph) {\n      const otherStore = otherGraph.store || otherGraph;\n      const resultStore = rdfEngine.intersection(store, otherStore);\n      return useGraph(resultStore);\n    },\n\n    /**\n     * Skolemize blank nodes in the graph\n     * @param {string} [baseIRI] - Base IRI for skolemization\n     * @returns {Object} New useGraph instance with skolemized nodes\n     */\n    skolemize(baseIRI) {\n      const resultStore = rdfEngine.skolemize(store, baseIRI);\n      return useGraph(resultStore);\n    },\n\n    /**\n     * Convert the graph to JSON-LD\n     * @param {Object} [options] - Conversion options\n     * @param {Object} [options.context] - JSON-LD context\n     * @param {Object} [options.frame] - JSON-LD frame\n     * @returns {Promise<Object>} JSON-LD document\n     */\n    async toJSONLD(options = {}) {\n      return rdfEngine.toJSONLD(store, options);\n    },\n\n    /**\n     * Get the size of the graph\n     * @returns {number} Number of quads\n     */\n    get size() {\n      return store.size;\n    }\n  };\n}\n"
        }
    ]
}