{
    "sourceFile": "src/composables/useStore.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015559,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015559,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useStore composable - canonical N3.Store operations\n * \n * This composable provides the foundation for all unrdf operations.\n * It enforces the \"One Store Rule\" - N3.Store is the only memory model.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { Store, DataFactory } from \"n3\";\nimport { RdfEngine } from \"../engines/RdfEngine.mjs\";\n\nconst { namedNode, literal, blankNode, quad, defaultGraph } = DataFactory;\n\n/**\n * Create a new store composable\n * \n * @param {Array} [initialQuads=[]] - Initial quads to add to the store\n * @param {Object} [options] - Store options\n * @param {string} [options.baseIRI] - Base IRI for the store\n * @param {boolean} [options.deterministic=true] - Enable deterministic operations\n * @returns {Object} Store composable interface\n * \n * @example\n * const store = useStore();\n * store.add(quad(namedNode('ex:subject'), namedNode('ex:predicate'), literal('value')));\n * console.log(store.stats());\n */\nexport function useStore(initialQuads = [], options = {}) {\n  const engine = new RdfEngine(options);\n  const store = new Store(initialQuads);\n\n  return {\n    /**\n     * The raw N3.Store instance\n     * @type {Store}\n     */\n    get store() {\n      return store;\n    },\n\n    /**\n     * The underlying RDF engine\n     * @type {RdfEngine}\n     */\n    get engine() {\n      return engine;\n    },\n\n    /**\n     * Add quads to the store\n     * @param {...Quad} quads - Quads to add\n     * @returns {void}\n     */\n    add(...quads) {\n      for (const q of quads) {\n        store.add(q);\n      }\n    },\n\n    /**\n     * Remove quads from the store\n     * @param {...Quad} quads - Quads to remove\n     * @returns {void}\n     */\n    remove(...quads) {\n      for (const q of quads) {\n        store.delete(q);\n      }\n    },\n\n    /**\n     * Clear all quads from the store\n     * @returns {void}\n     */\n    clear() {\n      store.removeQuads([...store]);\n    },\n\n    /**\n     * Get statistics about the store\n     * @returns {Object} Store statistics\n     */\n    stats() {\n      return engine.getStats(store);\n    },\n\n    /**\n     * Serialize the store to a string\n     * @param {Object} [options] - Serialization options\n     * @param {string} [options.format='Turtle'] - Output format\n     * @param {Object} [options.prefixes] - Prefix mappings\n     * @returns {Promise<string>} Serialized string\n     */\n    async serialize(options = {}) {\n      const { format = \"Turtle\", prefixes } = options;\n      \n      if (format === \"Turtle\") {\n        return await engine.serializeTurtle(store, { prefixes });\n      }\n      if (format === \"N-Quads\") {\n        return await engine.serializeNQuads(store);\n      }\n      \n      throw new Error(`Unsupported serialization format: ${format}`);\n    },\n\n    /**\n     * Create a named node\n     * @param {string} value - IRI value\n     * @returns {NamedNode} Named node\n     */\n    namedNode(value) {\n      return namedNode(value);\n    },\n\n    /**\n     * Create a literal\n     * @param {string} value - Literal value\n     * @param {string} [datatype] - Datatype IRI\n     * @returns {Literal} Literal\n     */\n    literal(value, datatype) {\n      return literal(value, datatype);\n    },\n\n    /**\n     * Create a blank node\n     * @param {string} [value] - Blank node identifier\n     * @returns {BlankNode} Blank node\n     */\n    blankNode(value) {\n      return blankNode(value);\n    },\n\n    /**\n     * Create a quad\n     * @param {Term} s - Subject\n     * @param {Term} p - Predicate\n     * @param {Term} o - Object\n     * @param {Term} [g] - Graph\n     * @returns {Quad} Quad\n     */\n    quad(s, p, o, g) {\n      return quad(s, p, o, g || defaultGraph());\n    },\n\n    /**\n     * Check if the store contains a specific quad\n     * @param {Quad} q - Quad to check\n     * @returns {boolean} True if quad exists\n     */\n    has(q) {\n      return store.has(q);\n    },\n\n    /**\n     * Get all quads matching a pattern\n     * @param {Term} [subject] - Subject pattern\n     * @param {Term} [predicate] - Predicate pattern\n     * @param {Term} [object] - Object pattern\n     * @param {Term} [graph] - Graph pattern\n     * @returns {Array<Quad>} Matching quads\n     */\n    getQuads(subject, predicate, object, graph) {\n      return store.getQuads(subject, predicate, object, graph);\n    },\n\n    /**\n     * Get the size of the store\n     * @returns {number} Number of quads\n     */\n    get size() {\n      return store.size;\n    },\n\n    /**\n     * Create an iterator over all quads\n     * @returns {Iterator<Quad>} Quad iterator\n     */\n    [Symbol.iterator]() {\n      return store[Symbol.iterator]();\n    }\n  };\n}\n"
        }
    ]
}