{
    "sourceFile": "src/composables/useValidator.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015526,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useValidator composable - SHACL validation operations\n * \n * This composable provides SHACL validation capabilities for RDF graphs.\n * It enforces the \"One Validator Rule\" - SHACL is the only validation method.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { RdfEngine } from \"../engines/RdfEngine.mjs\";\n\n// Create a single, shared instance of the engine for efficiency\nconst rdfEngine = new RdfEngine();\n\n/**\n * Create a SHACL validator composable\n * \n * @param {Object} [options] - Validator options\n * @param {number} [options.timeoutMs=30000] - Validation timeout\n * @param {Function} [options.onMetric] - Metrics callback\n * @returns {Object} Validator interface\n * \n * @example\n * const validator = useValidator();\n * \n * // Validate a store against SHACL shapes\n * const report = await validator.validate(dataStore, shapesStore);\n * \n * // Validate and throw on failure\n * await validator.validateOrThrow(dataStore, shapesTurtle);\n * \n * // Validate with custom timeout\n * const validator = useValidator({ timeoutMs: 60000 });\n */\nexport function useValidator(options = {}) {\n  const {\n    timeoutMs = 30000,\n    onMetric\n  } = options;\n\n  const engine = new RdfEngine({ \n    timeoutMs,\n    onMetric \n  });\n\n  return {\n    /**\n     * The underlying RDF engine\n     * @type {RdfEngine}\n     */\n    get engine() {\n      return engine;\n    },\n\n    /**\n     * Validate a data store against SHACL shapes\n     * @param {Store|Object} dataStore - Data store to validate\n     * @param {string|Store|Object} shapesInput - SHACL shapes as Turtle string or Store\n     * @returns {Promise<Object>} Validation report\n     * \n     * @example\n     * const report = await validator.validate(dataStore, shapesStore);\n     * if (report.conforms) {\n     *   console.log(\"✅ Validation passed\");\n     * } else {\n     *   console.log(\"❌ Validation failed:\", report.results);\n     * }\n     */\n    async validate(dataStore, shapesInput) {\n      const store = dataStore.store || dataStore;\n      return engine.validateShacl(store, shapesInput);\n    },\n\n    /**\n     * Validate a data store against SHACL shapes, throw on failure\n     * @param {Store|Object} dataStore - Data store to validate\n     * @param {string|Store|Object} shapesInput - SHACL shapes\n     * @returns {Promise<Object>} Validation report\n     * @throws {Error} If validation fails\n     * \n     * @example\n     * try {\n     *   await validator.validateOrThrow(dataStore, shapesStore);\n     *   console.log(\"✅ Validation passed\");\n     * } catch (error) {\n     *   console.log(\"❌ Validation failed:\", error.message);\n     * }\n     */\n    async validateOrThrow(dataStore, shapesInput) {\n      const store = dataStore.store || dataStore;\n      return engine.validateShaclOrThrow(store, shapesInput);\n    },\n\n    /**\n     * Validate multiple stores against the same shapes\n     * @param {Array<Store|Object>} dataStores - Array of data stores\n     * @param {string|Store|Object} shapesInput - SHACL shapes\n     * @returns {Promise<Array<Object>>} Array of validation reports\n     * \n     * @example\n     * const reports = await validator.validateMany([store1, store2], shapes);\n     * const allConform = reports.every(r => r.conforms);\n     */\n    async validateMany(dataStores, shapesInput) {\n      const promises = dataStores.map(store => this.validate(store, shapesInput));\n      return Promise.all(promises);\n    },\n\n    /**\n     * Validate a store against multiple shape sets\n     * @param {Store|Object} dataStore - Data store to validate\n     * @param {Array<string|Store|Object>} shapesInputs - Array of SHACL shape sets\n     * @returns {Promise<Array<Object>>} Array of validation reports\n     * \n     * @example\n     * const reports = await validator.validateAgainstMany(store, [shapes1, shapes2]);\n     * const allConform = reports.every(r => r.conforms);\n     */\n    async validateAgainstMany(dataStore, shapesInputs) {\n      const promises = shapesInputs.map(shapes => this.validate(dataStore, shapes));\n      return Promise.all(promises);\n    },\n\n    /**\n     * Get a summary of validation results\n     * @param {Object} report - Validation report\n     * @returns {Object} Summary object\n     * \n     * @example\n     * const report = await validator.validate(store, shapes);\n     * const summary = validator.summarize(report);\n     * console.log(`Conforms: ${summary.conforms}, Errors: ${summary.errorCount}`);\n     */\n    summarize(report) {\n      const errorCount = report.results.filter(r => r.severity === \"http://www.w3.org/ns/shacl#Violation\").length;\n      const warningCount = report.results.filter(r => r.severity === \"http://www.w3.org/ns/shacl#Warning\").length;\n      const infoCount = report.results.filter(r => r.severity === \"http://www.w3.org/ns/shacl#Info\").length;\n      \n      return {\n        conforms: report.conforms,\n        totalResults: report.results.length,\n        errorCount,\n        warningCount,\n        infoCount,\n        hasErrors: errorCount > 0,\n        hasWarnings: warningCount > 0,\n        hasInfo: infoCount > 0\n      };\n    },\n\n    /**\n     * Filter validation results by severity\n     * @param {Object} report - Validation report\n     * @param {string} severity - Severity level to filter by\n     * @returns {Array<Object>} Filtered results\n     * \n     * @example\n     * const report = await validator.validate(store, shapes);\n     * const errors = validator.filterBySeverity(report, \"http://www.w3.org/ns/shacl#Violation\");\n     */\n    filterBySeverity(report, severity) {\n      return report.results.filter(r => r.severity === severity);\n    },\n\n    /**\n     * Get validation results grouped by focus node\n     * @param {Object} report - Validation report\n     * @returns {Map<string, Array<Object>>} Results grouped by focus node\n     * \n     * @example\n     * const report = await validator.validate(store, shapes);\n     * const grouped = validator.groupByFocusNode(report);\n     * for (const [node, results] of grouped) {\n     *   console.log(`Node ${node} has ${results.length} violations`);\n     * }\n     */\n    groupByFocusNode(report) {\n      const grouped = new Map();\n      for (const result of report.results) {\n        const node = result.focusNode || \"unknown\";\n        if (!grouped.has(node)) {\n          grouped.set(node, []);\n        }\n        grouped.get(node).push(result);\n      }\n      return grouped;\n    },\n\n    /**\n     * Get validation results grouped by property path\n     * @param {Object} report - Validation report\n     * @returns {Map<string, Array<Object>>} Results grouped by property path\n     * \n     * @example\n     * const report = await validator.validate(store, shapes);\n     * const grouped = validator.groupByPath(report);\n     * for (const [path, results] of grouped) {\n     *   console.log(`Path ${path} has ${results.length} violations`);\n     * }\n     */\n    groupByPath(report) {\n      const grouped = new Map();\n      for (const result of report.results) {\n        const path = result.path || \"unknown\";\n        if (!grouped.has(path)) {\n          grouped.set(path, []);\n        }\n        grouped.get(path).push(result);\n      }\n      return grouped;\n    }\n  };\n}\n"
        }
    ]
}