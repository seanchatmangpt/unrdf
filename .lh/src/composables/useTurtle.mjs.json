{
    "sourceFile": "src/composables/useTurtle.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015525,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015525,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useTurtle composable - Turtle file I/O operations\n * \n * This composable provides file system operations for Turtle files.\n * It handles loading, saving, and managing .ttl files with automatic\n * parsing and serialization to/from N3.Store.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { readdir, readFile, writeFile, mkdir, stat } from \"node:fs/promises\";\nimport { join, dirname } from \"node:path\";\nimport { RdfEngine } from \"../engines/RdfEngine.mjs\";\nimport { useStore } from \"./useStore.mjs\";\n\n/**\n * Create a Turtle file system composable\n * \n * @param {string} [graphDir='./graph'] - Directory containing Turtle files\n * @param {Object} [options] - Turtle options\n * @param {string} [options.baseIRI] - Base IRI for parsing\n * @param {boolean} [options.autoLoad=true] - Automatically load all .ttl files\n * @param {boolean} [options.validateOnLoad=true] - Validate files on load\n * @returns {Promise<Object>} Turtle file system interface\n * \n * @example\n * const turtle = await useTurtle('./my-graph');\n * \n * // Load all .ttl files\n * await turtle.loadAll();\n * \n * // Save a specific graph\n * await turtle.save('my-graph', store);\n * \n * // Load a specific file\n * const store = await turtle.load('my-graph');\n */\nexport async function useTurtle(graphDir = \"./graph\", options = {}) {\n  const {\n    baseIRI = \"http://example.org/\",\n    autoLoad = true,\n    validateOnLoad = true\n  } = options;\n\n  const engine = new RdfEngine({ baseIRI });\n  \n  // Ensure directory exists\n  try {\n    await mkdir(graphDir, { recursive: true });\n  } catch (error) {\n    if (error.code !== \"EEXIST\") {\n      throw error;\n    }\n  }\n\n  const store = useStore();\n\n  return {\n    /**\n     * The underlying store instance\n     * @type {Object}\n     */\n    get store() {\n      return store;\n    },\n\n    /**\n     * The graph directory path\n     * @type {string}\n     */\n    get graphDir() {\n      return graphDir;\n    },\n\n    /**\n     * The RDF engine instance\n     * @type {RdfEngine}\n     */\n    get engine() {\n      return engine;\n    },\n\n    /**\n     * Load all .ttl files from the graph directory\n     * @param {Object} [options] - Load options\n     * @param {boolean} [options.merge=true] - Merge with existing store\n     * @param {boolean} [options.validate] - Validate files on load\n     * @returns {Promise<Object>} Load result\n     */\n    async loadAll(options = {}) {\n      const { merge = true, validate = validateOnLoad } = options;\n      \n      try {\n        const files = await readdir(graphDir);\n        const ttlFiles = files.filter(f => f.endsWith(\".ttl\"));\n        \n        if (ttlFiles.length === 0) {\n          console.log(`No .ttl files found in ${graphDir}`);\n          return { loaded: 0, files: [] };\n        }\n\n        const loadedFiles = [];\n        \n        for (const fileName of ttlFiles) {\n          try {\n            const filePath = join(graphDir, fileName);\n            const content = await readFile(filePath, \"utf8\");\n            \n            if (validate) {\n              // Basic validation - try to parse\n              engine.parseTurtle(content, { baseIRI });\n            }\n            \n            if (!merge) {\n              store.clear();\n            }\n            \n            const parsedStore = engine.parseTurtle(content, { baseIRI });\n            for (const quad of parsedStore) {\n              store.add(quad);\n            }\n            \n            loadedFiles.push(fileName);\n            console.log(`‚úÖ Loaded: ${fileName}`);\n          } catch (error) {\n            console.warn(`‚ö†Ô∏è Failed to load ${fileName}: ${error.message}`);\n          }\n        }\n        \n        console.log(`üìÅ Loaded ${loadedFiles.length} files from ${graphDir}`);\n        return { loaded: loadedFiles.length, files: loadedFiles };\n      } catch (error) {\n        if (error.code === \"ENOENT\") {\n          console.log(`üìÅ Graph directory ${graphDir} doesn't exist yet`);\n          return { loaded: 0, files: [] };\n        }\n        throw error;\n      }\n    },\n\n    /**\n     * Load a specific Turtle file\n     * @param {string} fileName - Name of the file (without .ttl extension)\n     * @param {Object} [options] - Load options\n     * @param {boolean} [options.merge=true] - Merge with existing store\n     * @param {boolean} [options.validate] - Validate file on load\n     * @returns {Promise<Store>} Loaded store\n     */\n    async load(fileName, options = {}) {\n      const { merge = true, validate = validateOnLoad } = options;\n      const filePath = join(graphDir, `${fileName}.ttl`);\n      \n      try {\n        const content = await readFile(filePath, \"utf8\");\n        \n        if (validate) {\n          engine.parseTurtle(content, { baseIRI });\n        }\n        \n        const parsedStore = engine.parseTurtle(content, { baseIRI });\n        \n        if (!merge) {\n          store.clear();\n        }\n        \n        for (const quad of parsedStore) {\n          store.add(quad);\n        }\n        \n        console.log(`‚úÖ Loaded: ${fileName}.ttl`);\n        return parsedStore;\n      } catch (error) {\n        if (error.code === \"ENOENT\") {\n          throw new Error(`File not found: ${fileName}.ttl`);\n        }\n        throw error;\n      }\n    },\n\n    /**\n     * Save the current store to a Turtle file\n     * @param {string} fileName - Name of the file (without .ttl extension)\n     * @param {Object} [options] - Save options\n     * @param {Object} [options.prefixes] - Prefix mappings\n     * @param {boolean} [options.createBackup=false] - Create backup of existing file\n     * @returns {Promise<Object>} Save result\n     */\n    async save(fileName, options = {}) {\n      const { prefixes, createBackup = false } = options;\n      const filePath = join(graphDir, `${fileName}.ttl`);\n      \n      try {\n        // Create backup if requested and file exists\n        if (createBackup) {\n          try {\n            await stat(filePath);\n            const backupPath = `${filePath}.backup`;\n            const content = await readFile(filePath, \"utf8\");\n            await writeFile(backupPath, content, \"utf8\");\n            console.log(`üìã Created backup: ${fileName}.ttl.backup`);\n          } catch (error) {\n            // File doesn't exist, no backup needed\n          }\n        }\n        \n        const turtleContent = await engine.serializeTurtle(store.store, { prefixes });\n        await writeFile(filePath, turtleContent, \"utf8\");\n        \n        const stats = await stat(filePath);\n        console.log(`üíæ Saved: ${fileName}.ttl (${stats.size} bytes)`);\n        \n        return { path: filePath, bytes: stats.size };\n      } catch (error) {\n        console.error(`‚ùå Failed to save ${fileName}.ttl:`, error.message);\n        throw error;\n      }\n    },\n\n    /**\n     * Save the current store to default.ttl\n     * @param {Object} [options] - Save options\n     * @returns {Promise<Object>} Save result\n     */\n    async saveDefault(options = {}) {\n      return this.save(\"default\", { ...options, createBackup: true });\n    },\n\n    /**\n     * Load default.ttl file\n     * @param {Object} [options] - Load options\n     * @returns {Promise<Store|null>} Loaded store or null if not found\n     */\n    async loadDefault(options = {}) {\n      try {\n        return await this.load(\"default\", options);\n      } catch (error) {\n        if (error.message.includes(\"File not found\")) {\n          console.log(`‚ÑπÔ∏è No default.ttl file found in ${graphDir}`);\n          return null;\n        }\n        throw error;\n      }\n    },\n\n    /**\n     * List all .ttl files in the graph directory\n     * @returns {Promise<Array<string>>} Array of file names\n     */\n    async listFiles() {\n      try {\n        const files = await readdir(graphDir);\n        const ttlFiles = files.filter(f => f.endsWith(\".ttl\"));\n        console.log(`üìÅ Found ${ttlFiles.length} .ttl files in ${graphDir}`);\n        return ttlFiles;\n      } catch (error) {\n        if (error.code === \"ENOENT\") {\n          return [];\n        }\n        throw error;\n      }\n    },\n\n    /**\n     * Get statistics about the current store\n     * @returns {Object} Store statistics\n     */\n    stats() {\n      return store.stats();\n    },\n\n    /**\n     * Clear the current store\n     * @returns {void}\n     */\n    clear() {\n      store.clear();\n    },\n\n    /**\n     * Parse a Turtle string into a new store\n     * @param {string} ttl - Turtle string\n     * @param {Object} [options] - Parse options\n     * @returns {Store} Parsed store\n     */\n    parse(ttl, options = {}) {\n      return engine.parseTurtle(ttl, { baseIRI, ...options });\n    },\n\n    /**\n     * Serialize the current store to Turtle\n     * @param {Object} [options] - Serialization options\n     * @param {Object} [options.prefixes] - Prefix mappings\n     * @returns {Promise<string>} Turtle string\n     */\n    async serialize(options = {}) {\n      return await engine.serializeTurtle(store.store, options);\n    }\n  };\n}\n"
        }
    ]
}