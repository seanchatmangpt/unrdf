{
    "sourceFile": "src/composables/useZod.mjs",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015526,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015526,
            "name": "Commit-0",
            "content": "/**\n * @fileoverview useZod composable - Zod validation for RDF data\n * \n * This composable provides Zod validation capabilities for RDF-derived data.\n * It bridges the gap between RDF graphs and application-level type safety.\n * \n * @version 1.0.0\n * @author GitVan Team\n * @license MIT\n */\n\nimport { z } from \"zod\";\n\n/**\n * Create a Zod validation composable\n * \n * @param {Object} [options] - Zod options\n * @param {boolean} [options.strict=true] - Enable strict validation\n * @param {Function} [options.onError] - Error callback\n * @returns {Object} Zod validation interface\n * \n * @example\n * const zod = useZod();\n * \n * // Define schema for Person\n * const PersonSchema = z.object({\n *   id: z.string().url(),\n *   name: z.string(),\n *   age: z.number().int().min(0)\n * });\n * \n * // Validate SPARQL results\n * const validated = await zod.validateResults(results, PersonSchema);\n */\nexport function useZod(options = {}) {\n  const {\n    strict = true,\n    onError\n  } = options;\n\n  return {\n    /**\n     * Validate SPARQL SELECT results against a Zod schema\n     * @param {Array<Object>} results - SPARQL SELECT results\n     * @param {z.ZodSchema} schema - Zod schema to validate against\n     * @param {Object} [options] - Validation options\n     * @param {boolean} [options.partial=false] - Use partial validation\n     * @param {boolean} [options.strict] - Override strict mode\n     * @returns {Array<Object>} Validated results\n     * \n     * @example\n     * const results = await graph.select(`\n     *   PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n     *   SELECT ?id ?name ?age WHERE {\n     *     ?id a foaf:Person ;\n     *         foaf:name ?name ;\n     *         foaf:age ?age .\n     *   }\n     * `);\n     * \n     * const PersonSchema = z.object({\n     *   id: z.string().url(),\n     *   name: z.string(),\n     *   age: z.number().int().min(0)\n     * });\n     * \n     * const validated = await zod.validateResults(results, PersonSchema);\n     */\n    async validateResults(results, schema, options = {}) {\n      const { partial = false, strict: strictOverride } = options;\n      const useStrict = strictOverride !== undefined ? strictOverride : strict;\n      \n      const validationSchema = partial ? schema.partial() : schema;\n      const validated = [];\n      const errors = [];\n      \n      for (let i = 0; i < results.length; i++) {\n        try {\n          const result = results[i];\n          const validatedResult = useStrict \n            ? validationSchema.parse(result)\n            : validationSchema.safeParse(result);\n          \n          if (useStrict) {\n            validated.push(validatedResult);\n          } else if (validatedResult.success) {\n            validated.push(validatedResult.data);\n          } else {\n            errors.push({ index: i, error: validatedResult.error, data: result });\n          }\n        } catch (error) {\n          errors.push({ index: i, error, data: results[i] });\n        }\n      }\n      \n      if (errors.length > 0 && onError) {\n        onError(errors);\n      }\n      \n      return { validated, errors };\n    },\n\n    /**\n     * Validate a single SPARQL result against a Zod schema\n     * @param {Object} result - Single SPARQL result\n     * @param {z.ZodSchema} schema - Zod schema to validate against\n     * @param {Object} [options] - Validation options\n     * @returns {Object} Validation result\n     * \n     * @example\n     * const result = results[0];\n     * const validation = await zod.validateResult(result, PersonSchema);\n     * if (validation.success) {\n     *   console.log(\"Valid:\", validation.data);\n     * } else {\n     *   console.log(\"Invalid:\", validation.error);\n     * }\n     */\n    async validateResult(result, schema, options = {}) {\n      const { strict: strictOverride } = options;\n      const useStrict = strictOverride !== undefined ? strictOverride : strict;\n      \n      try {\n        if (useStrict) {\n          const validated = schema.parse(result);\n          return { success: true, data: validated, error: null };\n        } else {\n          const validation = schema.safeParse(result);\n          return {\n            success: validation.success,\n            data: validation.success ? validation.data : null,\n            error: validation.success ? null : validation.error\n          };\n        }\n      } catch (error) {\n        return { success: false, data: null, error };\n      }\n    },\n\n    /**\n     * Validate JSON-LD data against a Zod schema\n     * @param {Object} jsonld - JSON-LD document\n     * @param {z.ZodSchema} schema - Zod schema to validate against\n     * @param {Object} [options] - Validation options\n     * @returns {Object} Validation result\n     * \n     * @example\n     * const jsonld = await graph.toJSONLD();\n     * const validation = await zod.validateJSONLD(jsonld, DocumentSchema);\n     */\n    async validateJSONLD(jsonld, schema, options = {}) {\n      return this.validateResult(jsonld, schema, options);\n    },\n\n    /**\n     * Create a Zod schema for RDF terms\n     * @param {Object} [options] - Schema options\n     * @param {boolean} [options.allowBlankNodes=true] - Allow blank nodes\n     * @param {boolean} [options.allowLiterals=true] - Allow literals\n     * @param {boolean} [options.allowNamedNodes=true] - Allow named nodes\n     * @returns {z.ZodSchema} Zod schema for RDF terms\n     * \n     * @example\n     * const TermSchema = zod.createTermSchema();\n     * const validation = await zod.validateResult(term, TermSchema);\n     */\n    createTermSchema(options = {}) {\n      const {\n        allowBlankNodes = true,\n        allowLiterals = true,\n        allowNamedNodes = true\n      } = options;\n      \n      const termTypes = [];\n      if (allowNamedNodes) termTypes.push(\"NamedNode\");\n      if (allowBlankNodes) termTypes.push(\"BlankNode\");\n      if (allowLiterals) termTypes.push(\"Literal\");\n      \n      return z.object({\n        termType: z.enum(termTypes),\n        value: z.string(),\n        language: z.string().optional(),\n        datatype: z.object({ value: z.string() }).optional()\n      });\n    },\n\n    /**\n     * Create a Zod schema for RDF quads\n     * @param {Object} [options] - Schema options\n     * @returns {z.ZodSchema} Zod schema for RDF quads\n     * \n     * @example\n     * const QuadSchema = zod.createQuadSchema();\n     * const validation = await zod.validateResult(quad, QuadSchema);\n     */\n    createQuadSchema(options = {}) {\n      const termSchema = this.createTermSchema(options);\n      \n      return z.object({\n        subject: termSchema,\n        predicate: termSchema,\n        object: termSchema,\n        graph: termSchema.optional()\n      });\n    },\n\n    /**\n     * Create a Zod schema for SPARQL SELECT results\n     * @param {Array<string>} variables - SPARQL variables\n     * @param {Object} [options] - Schema options\n     * @returns {z.ZodSchema} Zod schema for SELECT results\n     * \n     * @example\n     * const SelectSchema = zod.createSelectSchema(['id', 'name', 'age']);\n     * const validation = await zod.validateResults(results, SelectSchema);\n     */\n    createSelectSchema(variables, options = {}) {\n      const { strict = true } = options;\n      \n      const shape = {};\n      for (const variable of variables) {\n        shape[variable] = z.any(); // Can be refined based on needs\n      }\n      \n      const baseSchema = z.object(shape);\n      return strict ? baseSchema : baseSchema.partial();\n    },\n\n    /**\n     * Transform SPARQL results to match a Zod schema\n     * @param {Array<Object>} results - SPARQL SELECT results\n     * @param {z.ZodSchema} schema - Zod schema with transformations\n     * @param {Object} [options] - Transformation options\n     * @returns {Array<Object>} Transformed results\n     * \n     * @example\n     * const TransformSchema = z.object({\n     *   id: z.string().url(),\n     *   name: z.string(),\n     *   age: z.string().transform(val => parseInt(val, 10))\n     * });\n     * \n     * const transformed = await zod.transformResults(results, TransformSchema);\n     */\n    async transformResults(results, schema, options = {}) {\n      const { strict: strictOverride } = options;\n      const useStrict = strictOverride !== undefined ? strictOverride : strict;\n      \n      const transformed = [];\n      const errors = [];\n      \n      for (let i = 0; i < results.length; i++) {\n        try {\n          const result = results[i];\n          const transformedResult = useStrict \n            ? schema.parse(result)\n            : schema.safeParse(result);\n          \n          if (useStrict) {\n            transformed.push(transformedResult);\n          } else if (transformedResult.success) {\n            transformed.push(transformedResult.data);\n          } else {\n            errors.push({ index: i, error: transformedResult.error, data: result });\n          }\n        } catch (error) {\n          errors.push({ index: i, error, data: results[i] });\n        }\n      }\n      \n      if (errors.length > 0 && onError) {\n        onError(errors);\n      }\n      \n      return { transformed, errors };\n    },\n\n    /**\n     * Create a validation pipeline\n     * @param {Array<Object>} steps - Array of validation steps\n     * @returns {Object} Pipeline interface\n     * \n     * @example\n     * const pipeline = zod.createPipeline([\n     *   { name: \"basic\", schema: BasicSchema },\n     *   { name: \"advanced\", schema: AdvancedSchema },\n     *   { name: \"transform\", schema: TransformSchema }\n     * ]);\n     * \n     * const result = await pipeline.execute(results);\n     */\n    createPipeline(steps) {\n      return {\n        steps,\n        \n        /**\n         * Execute the validation pipeline\n         * @param {Array<Object>} results - Results to validate\n         * @returns {Promise<Object>} Pipeline result\n         */\n        async execute(results) {\n          let currentResults = results;\n          const stepResults = [];\n          \n          for (const step of this.steps) {\n            const startTime = performance.now();\n            const validation = await this.validateResults(currentResults, step.schema);\n            const duration = performance.now() - startTime;\n            \n            stepResults.push({\n              name: step.name,\n              inputCount: currentResults.length,\n              validCount: validation.validated.length,\n              errorCount: validation.errors.length,\n              duration\n            });\n            \n            currentResults = validation.validated;\n          }\n          \n          return {\n            results: currentResults,\n            steps: stepResults\n          };\n        }\n      };\n    },\n\n    /**\n     * Get validation statistics\n     * @param {Object} validationResult - Result from validateResults\n     * @returns {Object} Statistics object\n     * \n     * @example\n     * const validation = await zod.validateResults(results, schema);\n     * const stats = zod.getStats(validation);\n     * console.log(`Valid: ${stats.validCount}, Invalid: ${stats.invalidCount}`);\n     */\n    getStats(validationResult) {\n      const { validated, errors } = validationResult;\n      \n      return {\n        totalCount: validated.length + errors.length,\n        validCount: validated.length,\n        invalidCount: errors.length,\n        successRate: (validated.length / (validated.length + errors.length)) * 100,\n        errors: errors.map(e => ({\n          index: e.index,\n          message: e.error.message || e.error.toString()\n        }))\n      };\n    }\n  };\n}\n"
        }
    ]
}