{
    "sourceFile": "README.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1758656015527,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1758656015527,
            "name": "Commit-0",
            "content": "# unrdf\n\n**Opinionated composable framework for RDF knowledge operations**\n\nunrdf is the opinionated RDF framework for JavaScript. It makes the RDF universe accessible through a single composable surface — powered by N3.js, Comunica, SHACL, and Zod.\n\n## Philosophy\n\n**No TypeScript. Ever.** TypeScript is an illusion of safety that collapses at runtime. unrdf guarantees correctness at the only level that matters: execution.\n\n**JSDoc is the source of truth.** Documentation, type hints, and developer experience are delivered directly via JSDoc, keeping the codebase minimal and expressive.\n\n**Zod is the contract.** Runtime validation ensures that what you think your data is, and what it actually is, are always in sync.\n\n**Composables everywhere.** Every aspect of RDF — graphs, queries, validation, reasoning, serialization — is accessible through consistent composable functions.\n\n## Installation\n\n```bash\npnpm add unrdf\n```\n\n## Quick Start\n\n```javascript\nimport { useStore, useGraph, useValidator, useZod } from 'unrdf';\n\n// Create a store\nconst store = useStore();\n\n// Add some data\nconst quad = store.quad(\n  store.namedNode(\"http://example.org/Person\"),\n  store.namedNode(\"http://xmlns.com/foaf/0.1/name\"),\n  store.literal(\"John Doe\")\n);\nstore.add(quad);\n\n// Create a graph interface\nconst graph = useGraph(store.store);\n\n// Query with SPARQL\nconst results = await graph.select(`\n  PREFIX foaf: <http://xmlns.com/foaf/0.1/>\n  SELECT ?name WHERE {\n    ?person foaf:name ?name .\n  }\n`);\n\n// Validate with Zod\nconst zod = useZod();\nconst PersonSchema = z.object({\n  name: z.string()\n});\n\nconst validation = await zod.validateResults(results, PersonSchema);\nconsole.log(validation.validated); // [{ name: \"John Doe\" }]\n```\n\n## Core Composables\n\n### useStore\nThe foundation of all unrdf operations. Creates and manages N3.Store instances.\n\n```javascript\nconst store = useStore();\nstore.add(quad);\nconst stats = store.stats();\nconst turtle = await store.serialize();\n```\n\n### useGraph\nHigh-level RDF operations including SPARQL queries and set operations.\n\n```javascript\nconst graph = useGraph(store.store);\nconst results = await graph.select(\"SELECT ?s ?p ?o WHERE { ?s ?p ?o }\");\nconst exists = await graph.ask(\"ASK WHERE { ?s a ex:Person }\");\n```\n\n### useValidator\nSHACL validation for RDF graphs.\n\n```javascript\nconst validator = useValidator();\nconst report = await validator.validate(dataStore, shapesStore);\nawait validator.validateOrThrow(dataStore, shapesStore);\n```\n\n### useReasoner\nEYE-based reasoning over RDF data.\n\n```javascript\nconst reasoner = useReasoner();\nconst inferred = await reasoner.reason(dataStore, rulesStore);\n```\n\n### useCanon\nCanonicalization and isomorphism checking using URDNA2015.\n\n```javascript\nconst canon = useCanon();\nconst canonical = await canon.canonicalize(store);\nconst isIsomorphic = await canon.isIsomorphic(store1, store2);\n```\n\n### useZod\nRuntime validation for RDF-derived data.\n\n```javascript\nconst zod = useZod();\nconst validation = await zod.validateResults(sparqlResults, schema);\n```\n\n### useTurtle\nFile system operations for Turtle files.\n\n```javascript\nconst turtle = await useTurtle('./graph');\nawait turtle.loadAll();\nawait turtle.save('my-graph', store);\n```\n\n## Utilities\n\nunrdf includes comprehensive utility functions that cover the 80/20 \"dark matter\" of RDF operations:\n\n### Term Utilities\n```javascript\nimport { asNamedNode, asLiteral, asBlankNode, quadToJSON, jsonToQuad } from 'unrdf';\n\nconst node = asNamedNode(\"http://example.org/foo\");\nconst lit = asLiteral(\"hello\");\nconst bnode = asBlankNode();\nconst json = quadToJSON(quad);\nconst quad = jsonToQuad(json);\n```\n\n### Graph Utilities\n```javascript\nimport { pluck, indexByPredicate, getSubjectsByType, hasType, getOne, getAll } from 'unrdf';\n\nconst labels = pluck(store, \"http://www.w3.org/2000/01/rdf-schema#label\");\nconst labelMap = indexByPredicate(store, \"http://www.w3.org/2000/01/rdf-schema#label\");\nconst persons = getSubjectsByType(store, \"http://xmlns.com/foaf/0.1/Person\");\nconst isPerson = hasType(store, \"http://example.org/foo\", \"http://xmlns.com/foaf/0.1/Person\");\nconst name = getOne(store, \"http://example.org/foo\", \"http://xmlns.com/foaf/0.1/name\");\nconst names = getAll(store, \"http://example.org/foo\", \"http://xmlns.com/foaf/0.1/name\");\n```\n\n### Serialization Utilities\n```javascript\nimport { debugTurtle, debugNQuads, debugJSONLD } from 'unrdf';\n\nconst turtle = await debugTurtle(store);\nconst nquads = await debugNQuads(store);\nconst jsonld = await debugJSONLD(store);\n```\n\n### Validation Utilities\n```javascript\nimport { validateIRI, validateTerm, validateQuad, validateStore } from 'unrdf';\n\nconst isValidIRI = validateIRI(\"http://example.org/foo\");\nconst isValidTerm = validateTerm(term);\nconst isValidQuad = validateQuad(quad);\nconst result = validateStore(store);\n```\n\n## Opinionated Design\n\nunrdf enforces a single, opinionated path through the RDF universe:\n\n- **One Store**: N3.Store is the only memory model\n- **One Query Engine**: Comunica is the only SPARQL engine\n- **One Validator**: SHACL is the only validation method\n- **One Reasoner**: EYE is the only reasoning engine\n- **One Canonicalization**: URDNA2015 is the only canonicalization method\n- **One Serialization**: Turtle and N-Quads are the primary formats\n- **One Validation**: Zod is the only runtime validation\n\nThis eliminates choice paralysis and ensures consistency across all RDF operations.\n\n## Why unrdf?\n\nThe RDF ecosystem has matured into a diverse set of libraries, but this diversity has created fragmentation. A typical project may mix N3 for parsing, Comunica for SPARQL, rdf-ext for datasets, rdf-validate-shacl for constraints, and eyereasoner for inference. Each library is useful in isolation, but together they form a patchwork of styles, APIs, and stores.\n\nunrdf addresses this by enforcing a single opinionated path. The framework selects a canonical implementation for each layer and wraps them in a composable API pattern. The result is not a new ontology language or reasoner but a reduction of cognitive overhead for practitioners.\n\n## License\n\nMIT\n\n## Contributing\n\nThis project follows the opinionated design philosophy. Contributions should align with the single-path approach and maintain the composable API pattern."
        }
    ]
}