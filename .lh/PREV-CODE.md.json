{
    "sourceFile": "PREV-CODE.md",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1758655185221,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1758655233597,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -1,4 +1,6 @@\n+{ \"name\": \"gitvan\", \"version\": \"2.0.1\", \"description\": \"Git-native development automation platform with AI-powered workflows\", \"type\": \"module\", \"main\": \"dist/cli.mjs\", \"bin\": { \"gitvan\": \"dist/gitvan.mjs\" }, \"exports\": { \".\": { \"import\": \"./dist/cli.mjs\", \"types\": \"./dist/types/index.d.ts\" }, \"./define\": { \"import\": \"./dist/define.mjs\", \"types\": \"./dist/types/index.d.ts\" }, \"./composables\": { \"import\": \"./dist/composables/index.mjs\", \"types\": \"./dist/types/index.d.ts\" }, \"./daemon\": { \"import\": \"./dist/runtime/daemon.mjs\", \"types\": \"./dist/types/index.d.ts\" }, \"./runtime\": { \"import\": \"./dist/runtime/config.mjs\", \"types\": \"./dist/types/index.d.ts\" }, \"./types\": \"./dist/types/index.d.ts\" }, \"files\": [ \"dist/\", \"templates/\", \"packs/\", \"README.md\", \"LICENSE\" ], \"keywords\": [ \"git\", \"automation\", \"development\", \"cli\", \"templates\", \"jobs\", \"hooks\", \"ai\", \"workflow\", \"cicd\", \"devops\", \"remote-packs\", \"giget\", \"unplugin\", \"build-tools\" ], \"author\": \"GitVan Team\", \"license\": \"MIT\", \"homepage\": \"https://github.com/seanchatmangpt/gitvan\", \"repository\": { \"type\": \"git\", \"url\": \"https://github.com/seanchatmangpt/gitvan.git\" }, \"bugs\": { \"url\": \"https://github.com/seanchatmangpt/gitvan/issues\" }, \"dependencies\": { \"@babel/parser\": \"^7.28.4\", \"@babel/traverse\": \"^7.28.4\", \"@comunica/query-sparql\": \"^4.4.0\", \"@rdfjs/types\": \"^2.0.1\", \"@zazuko/env\": \"^3.0.1\", \"ai\": \"^5.0.47\", \"c12\": \"^3.3.0\", \"cacache\": \"^20.0.1\", \"citty\": \"^0.1.6\", \"consola\": \"^3.4.2\", \"defu\": \"^6.1.4\", \"eyereasoner\": \"^18.20.0\", \"fuse.js\": \"^7.1.0\", \"giget\": \"^1.2.1\", \"gray-matter\": \"^4.0.3\", \"hookable\": \"^5.5.3\", \"inflection\": \"^3.0.2\", \"isomorphic-git\": \"^1.33.1\", \"js-yaml\": \"^4.1.0\", \"json5\": \"^2.2.3\", \"jsonld\": \"^8.3.3\", \"klona\": \"^2.0.6\", \"lru-cache\": \"^11.2.1\", \"memfs\": \"^4.43.0\", \"minimatch\": \"^10.0.3\", \"msw\": \"^2.11.3\", \"n3\": \"^1.26.0\", \"node-cron\": \"^4.2.1\", \"nunjucks\": \"^3.2.4\", \"ollama-ai-provider-v2\": \"^1.3.1\", \"p-queue\": \"^8.1.1\", \"pathe\": \"^2.0.3\", \"prompts\": \"^2.4.2\", \"rdf-canonize\": \"^4.0.1\", \"rdf-ext\": \"^2.6.0\", \"rdf-validate-shacl\": \"^0.6.5\", \"semver\": \"^7.7.2\", \"tinyglobby\": \"^0.2.15\", \"toml\": \"^3.0.0\", \"unctx\": \"^2.4.1\", \"unrouting\": \"^0.0.1\", \"zod\": \"^4.1.9\" }, \"devDependencies\": { \"@cucumber/cucumber\": \"^12.2.0\", \"@cucumber/gherkin\": \"^35.1.0\", \"@cucumber/messages\": \"^29.0.1\", \"@types/node\": \"^20.19.15\", \"@types/nunjucks\": \"^3.2.6\", \"@vitest/runner\": \"^3.2.4\", \"eslint\": \"^9.35.0\", \"eslint-config-unjs\": \"^0.5.0\", \"unbuild\": \"^3.6.1\", \"vitest\": \"^1.0.0\" }, \"engines\": { \"node\": \">=18.0.0\" }, \"scripts\": { \"build\": \"gitvan build\", \"dev\": \"gitvan daemon\", \"test\": \"vitest\", \"test:watch\": \"vitest --watch\", \"test:coverage\": \"vitest --coverage\", \"test:bdd\": \"vitest run --config vitest.bdd.config.mjs\", \"test:bdd:watch\": \"vitest --watch --config vitest.bdd.config.mjs\", \"test:bdd:runner\": \"node tests/bdd/runner.mjs\", \"test:workflow:bdd\": \"node tests/bdd/workflow-cli-runner.mjs\", \"test:citty:bdd\": \"node tests/bdd/citty-cli-runner.mjs\", \"test:citty-utils\": \"vitest run tests/citty-test-utils/ --config vitest.citty-test-utils.config.mjs\", \"test:citty-utils:unit\": \"vitest run tests/citty-test-utils/unit/ --config vitest.citty-test-utils.config.mjs\", \"test:citty-utils:integration\": \"vitest run tests/citty-test-utils/integration/ --config vitest.citty-test-utils.config.mjs\", \"test:citty-utils:bdd\": \"vitest run tests/citty-test-utils/bdd/ --config vitest.citty-test-utils.config.mjs\", \"test:citty-utils:performance\": \"vitest run tests/citty-test-utils/performance/ --config vitest.citty-test-utils.config.mjs\", \"test:citty-utils:coverage\": \"vitest run tests/citty-test-utils/ --config vitest.citty-test-utils.config.mjs --coverage\", \"test:citty-utils:watch\": \"vitest --watch tests/citty-test-utils/ --config vitest.citty-test-utils.config.mjs\", \"test:scenarios\": \"vitest run tests/e2e/gitvan-scenarios.test.mjs\", \"test:scenarios:watch\": \"vitest --watch tests/e2e/gitvan-scenarios.test.mjs\", \"test:scenarios:local\": \"vitest run tests/e2e/gitvan-scenarios-local.test.mjs\", \"test:scenarios:local:watch\": \"vitest --watch tests/e2e/gitvan-scenarios-local.test.mjs\", \"demo:workflow:jtbd\": \"node demo-workflow-cli-jtbd-bdd.mjs\", \"demo:citty:bdd\": \"node demo-citty-cli-bdd.mjs\", \"lint\": \"eslint .\", \"lint:fix\": \"eslint . --fix\", \"types\": \"echo 'TypeScript definitions only'\", \"prepublishOnly\": \"pnpm run build\", \"test:hooks\": \"vitest tests/hooks/\", \"test:workflows\": \"vitest tests/workflows/\", \"hooks\": \"gitvan hooks\", \"hooks:list\": \"gitvan hooks list\", \"hooks:evaluate\": \"gitvan hooks evaluate\", \"workflows\": \"gitvan workflow\", \"workflows:list\": \"gitvan workflow list\", \"workflows:run\": \"gitvan workflow run\", \"setup\": \"gitvan setup\", \"save\": \"gitvan save\" }, \"publishConfig\": { \"access\": \"public\" }, \"pnpm\": { \"peerDependencyRules\": { \"allowedVersions\": { \"@rdfjs/types\": \"*\" } } } }\n+\n /** * @fileoverview GitVan v2 — Turtle/RDF Composable * * This module provides Turtle/RDF file loading, parsing, and querying capabilities * within the GitVan context. It handles loading .ttl files from directories, * parsing them into N3 stores, and providing methods to query and extract * knowledge hooks and RDF data. * * Key Features: * - Turtle (.ttl) file loading and parsing * - N3 store integration for RDF operations * - Knowledge hook extraction from RDF data * - SPARQL query execution * - Namespace management for RDF vocabularies * - RDF list traversal utilities * * @version 2.0.0 * @author GitVan Team * @license Apache-2.0 */ import { readdir, readFile } from \"node:fs/promises\"; import { join } from \"node:path\"; import N3 from \"n3\"; import { useGitVan, tryUseGitVan } from \"../core/context.mjs\"; import { loadOptions } from \"../config/loader.mjs\"; import { createPersistenceHelper } from \"../utils/persistence-helper.mjs\"; // Namespace constants for RDF vocabularies const RDF = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"; const DCT = \"http://purl.org/dc/terms/\"; const GH = \"https://gitvan.dev/graph-hook#\"; const GV = \"https://gitvan.dev/ontology#\"; const OP = \"https://gitvan.dev/op#\"; // Helper to convert an RDF term to a plain string const asStr = (term) => term?.termType === \"Literal\" ? term.value : term?.value; // Helper to traverse and read an RDF list const readList = (store, head) => { if (!head) return []; const out = []; let current = head; while (current && current.value !== RDF + \"nil\") { out.push(store.getObjects(current, RDF + \"first\", null)[0]); current = store.getObjects(current, RDF + \"rest\", null)[0]; } return out; }; /** * Bind context and resolve graph configuration * Integrates with GitVan config system for robust graph path resolution */ async function bindContext(opts = {}) { let ctx; try { ctx = useGitVan(); } catch { ctx = tryUseGitVan?.() || null; } const root = (ctx && ctx.cwd) || process.cwd(); // Load configuration using GitVan config system const config = await loadOptions({ rootDir: root }); // Resolve graph directory with precedence: opts > config > defaults const graphDir = opts.graphDir || join(root, config.graph.dir); // Merge URI roots with precedence: opts > config > defaults const uriRoots = { ...config.graph.uriRoots, ...opts.uriRoots, }; // Add graph:// prefix if not present if (!uriRoots[\"graph://\"]) { uriRoots[\"graph://\"] = ${graphDir}/; } return { root, graphDir, uriRoots, config }; } /** * Turtle/RDF operations composable * * Provides Turtle file loading, parsing, and querying capabilities within the GitVan context. * This function loads all .ttl files from a directory, parses them into an N3 store, * and provides methods to query the RDF data and extract knowledge hooks. * * @async * @function useTurtle * @param {Object} [options={}] - Turtle options * @param {string} [options.graphDir] - Directory containing Turtle files * @returns {Promise<Object>} Turtle operations interface * @returns {Function} returns.loadFiles - Load Turtle files from directory * @returns {Function} returns.getHooks - Get knowledge hooks from loaded data * @returns {Function} returns.query - Query the loaded RDF store * @returns {Function} returns.store - Access to the N3 store * @returns {Function} returns.parser - Access to the N3 parser * * @example *\n javascript\n  * const turtle = await useTurtle({ graphDir: './knowledge' });\n  *\n"
                }
            ],
            "date": 1758655185221,
            "name": "Commit-0",
            "content": "/** * @fileoverview GitVan v2 — Turtle/RDF Composable * * This module provides Turtle/RDF file loading, parsing, and querying capabilities * within the GitVan context. It handles loading .ttl files from directories, * parsing them into N3 stores, and providing methods to query and extract * knowledge hooks and RDF data. * * Key Features: * - Turtle (.ttl) file loading and parsing * - N3 store integration for RDF operations * - Knowledge hook extraction from RDF data * - SPARQL query execution * - Namespace management for RDF vocabularies * - RDF list traversal utilities * * @version 2.0.0 * @author GitVan Team * @license Apache-2.0 */ import { readdir, readFile } from \"node:fs/promises\"; import { join } from \"node:path\"; import N3 from \"n3\"; import { useGitVan, tryUseGitVan } from \"../core/context.mjs\"; import { loadOptions } from \"../config/loader.mjs\"; import { createPersistenceHelper } from \"../utils/persistence-helper.mjs\"; // Namespace constants for RDF vocabularies const RDF = \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\"; const DCT = \"http://purl.org/dc/terms/\"; const GH = \"https://gitvan.dev/graph-hook#\"; const GV = \"https://gitvan.dev/ontology#\"; const OP = \"https://gitvan.dev/op#\"; // Helper to convert an RDF term to a plain string const asStr = (term) => term?.termType === \"Literal\" ? term.value : term?.value; // Helper to traverse and read an RDF list const readList = (store, head) => { if (!head) return []; const out = []; let current = head; while (current && current.value !== RDF + \"nil\") { out.push(store.getObjects(current, RDF + \"first\", null)[0]); current = store.getObjects(current, RDF + \"rest\", null)[0]; } return out; }; /** * Bind context and resolve graph configuration * Integrates with GitVan config system for robust graph path resolution */ async function bindContext(opts = {}) { let ctx; try { ctx = useGitVan(); } catch { ctx = tryUseGitVan?.() || null; } const root = (ctx && ctx.cwd) || process.cwd(); // Load configuration using GitVan config system const config = await loadOptions({ rootDir: root }); // Resolve graph directory with precedence: opts > config > defaults const graphDir = opts.graphDir || join(root, config.graph.dir); // Merge URI roots with precedence: opts > config > defaults const uriRoots = { ...config.graph.uriRoots, ...opts.uriRoots, }; // Add graph:// prefix if not present if (!uriRoots[\"graph://\"]) { uriRoots[\"graph://\"] = ${graphDir}/; } return { root, graphDir, uriRoots, config }; } /** * Turtle/RDF operations composable * * Provides Turtle file loading, parsing, and querying capabilities within the GitVan context. * This function loads all .ttl files from a directory, parses them into an N3 store, * and provides methods to query the RDF data and extract knowledge hooks. * * @async * @function useTurtle * @param {Object} [options={}] - Turtle options * @param {string} [options.graphDir] - Directory containing Turtle files * @returns {Promise<Object>} Turtle operations interface * @returns {Function} returns.loadFiles - Load Turtle files from directory * @returns {Function} returns.getHooks - Get knowledge hooks from loaded data * @returns {Function} returns.query - Query the loaded RDF store * @returns {Function} returns.store - Access to the N3 store * @returns {Function} returns.parser - Access to the N3 parser * * @example *\njavascript\n * const turtle = await useTurtle({ graphDir: './knowledge' });\n *\n * // Load files\n * await turtle.loadFiles();\n *\n * // Get knowledge hooks\n * const hooks = turtle.getHooks();\n *\n * // Query RDF data\n * const results = turtle.query(`\n *   PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n *   SELECT ?s ?p ?o WHERE { ?s ?p ?o }\n * `);\n *\n*/ export async function useTurtle(options = {}) { const { root, graphDir, uriRoots, config } = await bindContext(options); // Create persistence helper for this instance const persistence = createPersistenceHelper({ logger: options.logger || console, atomicWrites: options.atomicWrites !== false, rdfEngine: options.rdfEngine, }); // --- Internal loader --- const load = async () => { try { const fileNames = (await readdir(graphDir)).filter((f) => f.endsWith(\".ttl\") ); const files = await Promise.all( fileNames.map(async (name) => ({ name, content: await readFile(join(graphDir, name), \"utf8\"), })) ); const store = new N3.Store(); const parser = new N3.Parser(); for (const file of files) { try { store.addQuads(parser.parse(file.content)); } catch (error) { // Skip malformed turtle files gracefully console.warn( Warning: Failed to parse turtle file ${file.name}: ${error.message} ); } } return { store, files }; } catch (error) { // If directory doesn't exist or can't be read, return empty store if (error.code === \"ENOENT\") { console.log( Graph directory ${graphDir} doesn't exist yet, starting with empty store ); return { store: new N3.Store(), files: [] }; } throw error; } }; const { store, files } = await load(); // --- Public API --- return { /** The raw N3.Store instance. */ store, /** An array of the raw file contents that were loaded. */ files, /** Configuration used by this instance. */ config: { root, graphDir, uriRoots, ...config.graph, }, /** Helper to traverse and read an RDF list */ readList(head) { return readList(store, head); }, /** Checks if a subject has a specific rdf:type. */ isA(subject, type) { return store.countQuads(subject, RDF + \"type\", type, null) > 0; }, /** Gets a single object for a given subject and predicate. */ getOne(subject, predicate) { return store.getObjects(subject, predicate, null)[0]; }, /** Gets all objects for a given subject and predicate. */ getAll(subject, predicate) { return store.getObjects(subject, predicate, null); }, /** Finds all defined Knowledge Hooks in the graph. */ getHooks() { const hooks = store.getSubjects(RDF + \"type\", GH + \"Hook\", null); return hooks.map((hookNode) => { const id = hookNode.value; const title = asStr(this.getOne(hookNode, DCT + \"title\")) || id; const pred = this.getOne(hookNode, GH + \"hasPredicate\"); const pipelinesList = this.getOne(hookNode, GH + \"orderedPipelines\"); const pipelines = pipelinesList ? readList(store, pipelinesList) : []; return { node: hookNode, id, title, pred, pipelines }; }); }, /** Gets the steps for a given pipeline node. */ getPipelineSteps(pipelineNode) { const listHead = this.getOne(pipelineNode, OP + \"steps\"); return readList(store, listHead); }, /** Resolves a URI (like graph://) to its file content. */ async resolveText(maybeUri) { if (typeof maybeUri !== \"string\") return maybeUri; // Check for URI prefixes first const prefix = Object.keys(uriRoots).find((p) => maybeUri.startsWith(p)); if (prefix) { const path = join(uriRoots[prefix], maybeUri.slice(prefix.length)); return readFile(path, \"utf8\"); } // If it's an absolute path or looks like a file path, try to read it directly if (maybeUri.startsWith(\"/\") || maybeUri.includes(\"/\")) { try { return await readFile(maybeUri, \"utf8\"); } catch (error) { // If file doesn't exist, return the original string return maybeUri; } } return maybeUri; }, /** Extracts SPARQL query text from a query node in the graph. */ async getQueryText(queryNode) { const inlineText = this.getOne(queryNode, GV + \"text\"); if (inlineText) return asStr(inlineText); const path = this.getOne(queryNode, GV + \"path\"); if (path) return this.resolveText(asStr(path)); return \"\"; }, /** Extracts template text from a template node in the graph. */ async getTemplateText(templateNode) { // This logic is identical to getQueryText, can be merged later if desired const inlineText = this.getOne(templateNode, GV + \"text\"); if (inlineText) return asStr(inlineText); const path = this.getOne(templateNode, GV + \"path\"); if (path) return this.resolveText(asStr(path)); return \"\"; }, /** Gets the graph directory path. */ getGraphDir() { return graphDir; }, /** Gets the URI roots mapping. */ getUriRoots() { return { ...uriRoots }; }, /** Checks if auto-loading is enabled. */ isAutoLoadEnabled() { return config.graph.autoLoad; }, /** Checks if validation on load is enabled. */ isValidationEnabled() { return config.graph.validateOnLoad; }, // ============== Persistence Methods ============== /** * Save the current store to a Turtle file * @param {string} fileName - Name of the file to save (without .ttl extension) * @param {object} options - Save options * @returns {Promise<{path: string, bytes: number}>} Save result */ async saveGraph(fileName, options = {}) { const { validate = true, createBackup = false, prefixes } = options; const filePath = join(graphDir, ${fileName}.ttl); try { const turtleContent = await persistence.serializeStore(store, { prefixes, }); const result = await persistence.writeTurtleFile( filePath, turtleContent, { validate, createBackup, } ); console.log( ✅ Graph saved to: ${result.path} (${result.bytes} bytes) ); return result; } catch (error) { console.error(❌ Failed to save graph to ${fileName}:, error.message); throw error; } }, /** * Load a Turtle file into the current store * @param {string} fileName - Name of the file to load (without .ttl extension) * @param {object} options - Load options * @returns {Promise<{path: string, quads: number}>} Load result */ async loadGraph(fileName, options = {}) { const { validate = true, merge = true } = options; const filePath = join(graphDir, ${fileName}.ttl); try { const turtleContent = await persistence.readTurtleFile(filePath, { validate, }); if (!turtleContent) { throw new Error(File not found: ${fileName}.ttl); } const loadedStore = persistence.parseTurtle(turtleContent, { baseIRI: options.baseIRI || config.graph.baseIRI, }); if (merge) { // Merge with existing store for (const quad of loadedStore) { store.add(quad); } } else { // Replace existing store store.removeQuads([...store]); for (const quad of loadedStore) { store.add(quad); } } const quads = store.size; console.log(✅ Graph loaded from: ${filePath} (${quads} quads)); return { path: filePath, quads }; } catch (error) { console.error( ❌ Failed to load graph from ${fileName}:, error.message ); throw error; } }, /** * Save the current store to the default.ttl file * @param {object} options - Save options * @returns {Promise<{path: string, bytes: number}>} Save result */ async saveDefaultGraph(options = {}) { const { validate = true, createBackup = true, prefixes } = options; try { const turtleContent = await persistence.serializeStore(store, { prefixes, }); const result = await persistence.writeDefaultGraph( graphDir, turtleContent, { validate, createBackup, } ); console.log( ✅ Default graph saved to: ${result.path} (${result.bytes} bytes) ); return result; } catch (error) { console.error(❌ Failed to save default graph:, error.message); throw error; } }, /** * Load the default.ttl file into the current store * @param {object} options - Load options * @returns {Promise<{path: string, quads: number}|null>} Load result or null if not found */ async loadDefaultGraph(options = {}) { const { validate = true, merge = true } = options; try { const turtleContent = await persistence.readDefaultGraph(graphDir, { validate, }); if (!turtleContent) { console.log(ℹ️ No default.ttl file found in ${graphDir}); return null; } const loadedStore = persistence.parseTurtle(turtleContent, { baseIRI: options.baseIRI || config.graph.baseIRI, }); if (merge) { // Merge with existing store for (const quad of loadedStore) { store.add(quad); } } else { // Replace existing store store.removeQuads([...store]); for (const quad of loadedStore) { store.add(quad); } } const quads = store.size; const defaultPath = join(graphDir, \"default.ttl\"); console.log( ✅ Default graph loaded from: ${defaultPath} (${quads} quads) ); return { path: defaultPath, quads }; } catch (error) { console.error(❌ Failed to load default graph:, error.message); throw error; } }, /** * Initialize default graph with template content if it doesn't exist * @param {object} options - Initialization options * @returns {Promise<{path: string, bytes: number, created: boolean}>} Initialization result */ async initializeDefaultGraph(options = {}) { const { templatePath, validate = true } = options; try { // Check if default.ttl already exists const defaultPath = join(graphDir, \"default.ttl\"); const exists = await persistence.fileExists(defaultPath); if (exists) { console.log(ℹ️ Default graph already exists: ${defaultPath}); const stats = await persistence.getFileStats(defaultPath); return { path: defaultPath, bytes: stats.size, created: false }; } // Create default.ttl from template let templateContent; if (templatePath) { templateContent = await readFile(templatePath, \"utf8\"); } else { // Use built-in default template templateContent = # GitVan Default Graph @prefix rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#> . @prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#> . @prefix xsd: <http://www.w3.org/2001/XMLSchema#> . @prefix dct: <http://purl.org/dc/terms/> . @prefix gv: <https://gitvan.dev/ontology#> . <https://gitvan.dev/project/> a gv:Project ; dct:title \"GitVan Project\" ; dct:description \"A GitVan-powered development automation project\" ; dct:created \"${new Date().toISOString()}\"^^xsd:dateTime ; gv:version \"1.0.0\" ; gv:status gv:Active . <https://gitvan.dev/graph/default/> a gv:Graph ; dct:title \"Default Graph\" ; dct:description \"Default graph location for GitVan operations\" ; gv:graphType gv:DefaultGraph ; gv:baseIRI \"https://gitvan.dev/graph/default/\" ; gv:persistenceEnabled true ; gv:autoSave true .; } const result = await persistence.writeDefaultGraph( graphDir, templateContent, { validate, } ); console.log( ✅ Default graph initialized: ${result.path} (${result.bytes} bytes) ); return { ...result, created: true }; } catch (error) { console.error(❌ Failed to initialize default graph:, error.message); throw error; } }, /** * Get list of available Turtle files in the graph directory * @returns {Promise<string[]>} Array of Turtle file names */ async listGraphFiles() { try { const files = await persistence.listTurtleFiles(graphDir); console.log(📁 Found ${files.length} Turtle files in ${graphDir}); return files; } catch (error) { console.error(❌ Failed to list graph files:, error.message); throw error; } }, /** * Get statistics about the current store * @returns {object} Store statistics */ getStoreStats() { return persistence.rdfEngine.getStats(store); }, /** * Get the persistence helper instance * @returns {PersistenceHelper} Persistence helper */ getPersistenceHelper() { return persistence; }, }; } // src/composables/graph.mjs // Provides a high-level, ergonomic API to operate on an in-memory RDF graph (N3 Store). import { RdfEngine } from \"../engines/RdfEngine.mjs\"; // Create a single, shared instance of the engine for efficiency. // The engine itself is stateless; its methods operate on the store you provide. const rdfEngine = new RdfEngine(); /** * Creates an operational interface for a given RDF graph store. * This is the primary composable for performing SPARQL queries, SHACL validation, * set operations, and other graph manipulations. * * @param {import('n3').Store} store - An N3.Store instance, typically loaded via useTurtle. * @returns {object} An API object for operating on the graph. */ export function useGraph(store) { if (!store || typeof store.getQuads !== \"function\") { throw new Error(\"[useGraph] An N3.Store instance must be provided.\"); } const self = { /** * The raw N3.Store instance being operated on. * @type {import('n3').Store} */ get store() { return store; }, /** * Provides direct access to the underlying RdfEngine singleton. * Useful for advanced or low-level operations not exposed on this composable. * @type {RdfEngine} */ get engine() { return rdfEngine; }, /** * Executes any valid SPARQL 1.1 query (SELECT, ASK, CONSTRUCT, DESCRIBE, UPDATE). * @param {string} sparql - The SPARQL query string. * @param {object} [options] - Options for the query engine. * @returns {Promise<object>} A result object with a type and other properties. */ query(sparql, options) { return rdfEngine.query(store, sparql, options); }, /** * A convenience method for SPARQL SELECT queries. * @param {string} sparql - The SPARQL SELECT query string. * @returns {Promise<Array<object>>} An array of result bindings. */ async select(sparql) { const res = await rdfEngine.query(store, sparql); if (res.type !== \"select\") throw new Error(\"Query is not a SELECT query.\"); return res.results; }, /** * A convenience method for SPARQL ASK queries. * @param {string} sparql - The SPARQL ASK query string. * @returns {Promise<boolean>} The boolean result of the query. */ async ask(sparql) { const res = await rdfEngine.query(store, sparql); if (res.type !== \"ask\") throw new Error(\"Query is not an ASK query.\"); return res.boolean; }, /** * Validates the graph against a set of SHACL shapes. * @param {string|import('n3').Store} shapesInput - The SHACL shapes as a Turtle string or an N3.Store. * @returns {Promise<object>} A validation report with conforms and results. */ validate(shapesInput) { return rdfEngine.validateShacl(store, shapesInput); }, /** * Serializes the graph to a string in the specified format. * @param {{format: 'Turtle'|'N-Quads', prefixes?: object}} options * @returns {Promise<string>} */ async serialize({ format = \"Turtle\", prefixes = {} }) { if (format === \"Turtle\") { return await rdfEngine.serializeTurtle(store, { prefixes }); } if (format === \"N-Quads\") { return await rdfEngine.serializeNQuads(store); } throw new Error(Unsupported serialization format: ${format}); }, /** * Returns a Clownface instance for fluent, chainable graph traversal and manipulation. * @returns {import('@zazuko/env').Clownface} */ pointer() { return rdfEngine.getClownface(store); }, /** * Basic statistics about the graph (quads, subjects, etc.). * @type {{quads: number, subjects: number, predicates: number, objects: number, graphs: number}} */ get stats() { return rdfEngine.getStats(store); }, /** * Checks if the graph is logically equivalent (isomorphic) to another graph. * @param {object} otherGraph - Another useGraph instance or a raw N3.Store. * @returns {Promise<boolean>} */ isIsomorphic(otherGraph) { const otherStore = otherGraph.store || otherGraph; return rdfEngine.isIsomorphic(store, otherStore); }, /** * Returns a new graph instance containing the union of this graph and others. * @param {...object} otherGraphs - Other useGraph instances or raw N3.Stores. * @returns {object} A new useGraph instance with the resulting graph. */ union(...otherGraphs) { const otherStores = otherGraphs.map((g) => g.store || g); const resultStore = rdfEngine.union(store, ...otherStores); return useGraph(resultStore); }, /** * Returns a new graph instance containing quads that are in this graph but not in the other. * @param {object} otherGraph - Another useGraph instance or a raw N3.Store. * @returns {object} A new useGraph instance with the resulting graph. */ difference(otherGraph) { const otherStore = otherGraph.store || otherGraph; const resultStore = rdfEngine.difference(store, otherStore); return useGraph(resultStore); }, /** * Returns a new graph instance containing only the quads that exist in both graphs. * @param {object} otherGraph - Another useGraph instance or a raw N3.Store. * @returns {object} A new useGraph instance with the resulting graph. */ intersection(otherGraph) { const otherStore = otherGraph.store || otherGraph; const resultStore = rdfEngine.intersection(store, otherStore); return useGraph(resultStore); }, }; return self; } // src/engines/RdfEngine.mjs // Production-grade RDF engine for JavaScript. import { Parser, Store, Writer, DataFactory } from \"n3\"; import { QueryEngine } from \"@comunica/query-sparql\"; import rdf from \"rdf-ext\"; import SHACLValidator from \"rdf-validate-shacl\"; import rdfCanonize from \"rdf-canonize\"; import jsonld from \"jsonld\"; import { n3reasoner } from \"eyereasoner\"; import $rdf from \"@zazuko/env\"; const { namedNode, literal, quad, blankNode, defaultGraph, variable } = DataFactory; export class RdfEngine { /** * @param {object} [options] * @param {string} [options.baseIRI='http://example.org/'] * @param {boolean} [options.deterministic=true] * @param {number} [options.timeoutMs=30000] * @param {(m:{event:string;data?:any;durMs?:number})=>void} [options.onMetric] * @param {{debug:Function,info:Function,warn:Function,error:Function}} [options.logger=console] */ constructor(options = {}) { this.baseIRI = options.baseIRI || \"http://example.org/\"; this.deterministic = options.deterministic !== false; this.timeoutMs = Number.isFinite(options.timeoutMs) ? options.timeoutMs : 30_000; this.onMetric = typeof options.onMetric === \"function\" ? options.onMetric : null; this.log = options.logger || console; this.engine = new QueryEngine(); // Use @zazuko/env which comes bundled with clownface this.$rdf = $rdf; } // ============== Terms & Store ============== createStore(quads = []) { return new Store(quads); } namedNode(value) { return namedNode(value); } literal(value, languageOrDatatype) { return literal(value, languageOrDatatype); } blankNode(value) { return blankNode(value); } quad(s, p, o, g = defaultGraph()) { return quad(s, p, o, g); } // ============== Parse & Serialize (deterministic) ============== parseTurtle(ttl, options = {}) { if (typeof ttl !== \"string\" || !ttl.length) throw new Error(\"parseTurtle: non-empty string required\"); const parser = new Parser({ baseIRI: options.baseIRI || this.baseIRI }); return new Store(parser.parse(ttl)); } parseNQuads(nq) { if (typeof nq !== \"string\" || !nq.length) throw new Error(\"parseNQuads: non-empty string required\"); const parser = new Parser({ format: \"N-Quads\" }); return new Store(parser.parse(nq)); } async serializeTurtle(store, options = {}) { // Extract prefixes from the store if not provided const prefixes = options.prefixes || this._extractPrefixes(store); const writer = new Writer({ format: \"Turtle\", prefixes, }); const quads = this._maybeSort([...store]); writer.addQuads(quads); return new Promise((resolve, reject) => writer.end((e, out) => (e ? reject(e) : resolve(out))) ); } async serializeNQuads(store) { const writer = new Writer({ format: \"N-Quads\" }); const quads = this._maybeSort([...store]); writer.addQuads(quads); return new Promise((resolve, reject) => writer.end((e, out) => (e ? reject(e) : resolve(out))) ); } // ============== Canonicalization & Isomorphism ============== async canonicalize(store) { const nquads = await this.serializeNQuads(store); return rdfCanonize.canonize(nquads, { algorithm: \"URDNA2015\", format: \"application/n-quads\", }); } async isIsomorphic(a, b) { const t0 = performance.now(); const [ca, cb] = await Promise.all([ this.canonicalize(a), this.canonicalize(b), ]); this._metric(\"isomorphic.check\", performance.now() - t0); return ca === cb; } // ============== SHACL Validation ============== async validateShacl(dataStore, shapesInput) { const shapesStore = typeof shapesInput === \"string\" ? this.parseTurtle(shapesInput) : shapesInput; const dataDataset = rdf.dataset([...dataStore]); const shapesDataset = rdf.dataset([...shapesStore]); const validator = new SHACLValidator(shapesDataset); const report = await this._withTimeout( () => validator.validate(dataDataset), this.timeoutMs, \"shacl.validate\" ); return { conforms: report.conforms, results: report.results.map((r) => ({ focusNode: r.focusNode?.value || null, path: r.path?.value || null, message: r.message?.[0]?.value || null, severity: r.severity?.value || null, sourceShape: r.sourceShape?.value || null, value: r.value?.value || null, })), }; } async validateShaclOrThrow(dataStore, shapesInput) { const rep = await this.validateShacl(dataStore, shapesInput); if (!rep.conforms) { const msg = rep.results .map((x) => [${x.severity}] ${x.path} ${x.message}) .join(\" ; \"); throw new Error(SHACL validation failed: ${msg}); } return rep; } // ============== SPARQL Query & Update ============== /** * Query with streaming, paging, and timeout. * @param {Store} store * @param {string} sparql * @param {{limit?:number,signal?:AbortSignal,deterministic?:boolean}} [opts] */ async query(store, sparql, opts = {}) { if (typeof sparql !== \"string\" || !sparql.trim()) throw new Error(\"query: non-empty SPARQL required\"); const q = sparql.trim(); const limit = Number.isFinite(opts.limit) ? opts.limit : Infinity; const deterministic = opts.deterministic ?? this.deterministic; const ctx = { sources: [store] }; const kind = q .toUpperCase() .match( /\\b(SELECT|ASK|CONSTRUCT|DESCRIBE|WITH|INSERT|DELETE|LOAD|CREATE|DROP|CLEAR|MOVE|COPY|ADD)\\b/ )?.[1]; const run = async () => { if (!kind) throw new Error(\"query: unknown query type\"); // SPARQL UPDATE if ( /^(WITH|INSERT|DELETE|LOAD|CREATE|DROP|CLEAR|MOVE|COPY|ADD)$/i.test( kind ) ) { await this.engine.queryVoid(q, { ...ctx, destination: store }); return { type: \"update\", ok: true }; } if (kind === \"ASK\") { const boolean = await this.engine.queryBoolean(q, ctx); return { type: \"ask\", boolean }; } if (kind === \"CONSTRUCT\" || kind === \"DESCRIBE\") { const quadStream = await this.engine.queryQuads(q, ctx); const out = new Store(); for await (const qq of quadStream) out.add(qq); const quads = deterministic ? this._maybeSort([...out]) : [...out]; return { type: kind.toLowerCase(), store: new Store(quads), quads }; } // SELECT const bindings = await this.engine.queryBindings(q, ctx); const rows = []; const varSet = new Set(); for await (const b of bindings) { for (const k of b.keys()) varSet.add(k.value); const row = {}; for (const v of varSet) { const term = b.get(variable(v)); row[v] = this._termToJSON(term); } rows.push(row); if (rows.length >= limit) break; } const variables = [...varSet].sort(); const results = deterministic ? rows.sort((a, b) => JSON.stringify(a).localeCompare(JSON.stringify(b)) ) : rows; return { type: \"select\", variables, results }; }; return this._withTimeout(run, this.timeoutMs, \"sparql.query\", opts.signal); } // ============== Graph Manipulation ============== /** Clownface pointer over an rdf-ext dataset view of the store. */ getClownface(store) { // Convert N3 Store to RDF/JS dataset const dataset = this.$rdf.dataset(); for (const quad of store) { dataset.add( this.$rdf.quad( this.$rdf.namedNode(quad.subject.value), this.$rdf.namedNode(quad.predicate.value), quad.object.termType === \"NamedNode\" ? this.$rdf.namedNode(quad.object.value) : quad.object.termType === \"Literal\" ? this.$rdf.literal( quad.object.value, quad.object.language || quad.object.datatype ) : this.$rdf.blankNode(quad.object.value), quad.graph.termType === \"DefaultGraph\" ? this.$rdf.defaultGraph() : quad.graph.termType === \"NamedNode\" ? this.$rdf.namedNode(quad.graph.value) : this.$rdf.blankNode(quad.graph.value) ) ); } return this.$rdf.clownface({ dataset }); } // ============== Reasoning ============== /** * N3 reasoning with timeout. Returns a new store. * @param {Store} dataStore * @param {Store} rulesStore */ async reason(dataStore, rulesStore) { const run = async () => { const dataN3 = await this.serializeTurtle(dataStore); const rulesN3 = await this.serializeTurtle(rulesStore); const out = await n3reasoner(dataN3, rulesN3); return this.parseTurtle(out); }; return this._withTimeout(run, this.timeoutMs, \"reasoning.n3\"); } // ============== JSON-LD I/O ============== /** * Store -> JSON-LD (compact or framed). * @param {Store} store * @param {{context?:object, frame?:object}} [opts] */ async toJSONLD(store, opts = {}) { const nquads = await this.serializeNQuads(store); const doc = await jsonld.fromRDF(nquads, { format: \"application/n-quads\" }); if (opts.frame) return jsonld.frame(doc, opts.frame, { omitGraph: false }); const context = opts.context || {}; const compacted = await jsonld.compact(doc, context); // Ensure @context is present if (!compacted[\"@context\"]) { compacted[\"@context\"] = context; } return compacted; } /** * JSON-LD -> Store. * @param {object} jsonldDoc */ async fromJSONLD(jsonldDoc) { const nquads = await jsonld.toRDF(jsonldDoc, { format: \"application/n-quads\", }); return this.parseNQuads(nquads); } // ============== Set Ops & Utilities ============== union(...stores) { const out = new Store(); for (const s of stores) for (const q of s) out.add(q); return out; } difference(a, b) { const out = new Store(); for (const q of a) if (!b.has(q)) out.add(q); return out; } intersection(a, b) { const out = new Store(); for (const q of a) if (b.has(q)) out.add(q); return out; } /** * Skolemize bnodes. Stable per run. Increments only on first-seen bnode. * @param {Store} store * @param {string} [baseIRI='http://example.org/.well-known/genid/'] */ skolemize(store, baseIRI = \"http://example.org/.well-known/genid/\") { const out = new Store(); const map = new Map(); let i = 0; const sk = (b) => { if (!map.has(b.value)) map.set(b.value, namedNode(${baseIRI}${i++})); return map.get(b.value); }; for (const qd of store) { const s = qd.subject.termType === \"BlankNode\" ? sk(qd.subject) : qd.subject; const o = qd.object.termType === \"BlankNode\" ? sk(qd.object) : qd.object; out.add(quad(s, qd.predicate, o, qd.graph)); } return out; } getStats(store) { const S = new Set(), P = new Set(), O = new Set(), G = new Set(); for (const q of store) { S.add(q.subject.value); P.add(q.predicate.value); O.add(q.object.value); G.add(q.graph.value); } return { quads: store.size, subjects: S.size, predicates: P.size, objects: O.size, graphs: G.size, }; } // ============== Internals ============== _maybeSort(quads) { if (!this.deterministic) return quads; return quads.sort((a, b) => ${a.subject.value}${a.predicate.value}${a.object.value}${a.graph.value}.localeCompare( ${b.subject.value}${b.predicate.value}${b.object.value}${b.graph.value} ) ); } _termToJSON(term) { if (!term) return null; const out = { termType: term.termType, value: term.value }; if (term.termType === \"Literal\") { if (term.language) out.language = term.language; if (term.datatype?.value) out.datatype = term.datatype.value; } return out; } async _withTimeout(fn, ms, label, externalSignal) { const controller = new AbortController(); const timer = setTimeout( () => controller.abort(new Error(${label} timeout after ${ms}ms)), ms ); const t0 = performance.now(); try { const res = await fn({ signal: controller.signal, externalSignal }); this._metric(label, performance.now() - t0); return res; } catch (error) { this.log.error(${label} failed:, error.message); throw error; } finally { clearTimeout(timer); } } _metric(event, durMs) { if (this.onMetric) { try { this.onMetric({ event, durMs }); } catch { /* ignore metrics errors */ } } } _extractPrefixes(store) { const prefixes = {}; const uris = new Set(); // Collect all URIs from the store for (const quad of store) { if (quad.subject.termType === \"NamedNode\") uris.add(quad.subject.value); if (quad.predicate.termType === \"NamedNode\") uris.add(quad.predicate.value); if (quad.object.termType === \"NamedNode\") uris.add(quad.object.value); if (quad.graph.termType === \"NamedNode\") uris.add(quad.graph.value); } // Extract common prefixes const commonPrefixes = { \"http://www.w3.org/1999/02/22-rdf-syntax-ns#\": \"rdf\", \"http://www.w3.org/2000/01/rdf-schema#\": \"rdfs\", \"http://www.w3.org/2001/XMLSchema#\": \"xsd\", \"http://xmlns.com/foaf/0.1/\": \"foaf\", \"http://purl.org/dc/terms/\": \"dct\", \"http://www.w3.org/ns/shacl#\": \"sh\", \"https://gitvan.dev/ontology#\": \"gv\", \"https://gitvan.dev/graph-hook#\": \"gh\", \"https://gitvan.dev/op#\": \"op\", }; // Find the best prefix for each URI for (const uri of uris) { for (const [prefixUri, prefixName] of Object.entries(commonPrefixes)) { if (uri.startsWith(prefixUri)) { prefixes[prefixName] = prefixUri; break; } } } // Add example.org prefix if present const exampleUris = Array.from(uris).filter((uri) => uri.startsWith(\"http://example.org/\") ); if (exampleUris.length > 0) { prefixes[\"ex\"] = \"http://example.org/\"; } return prefixes; } }"
        }
    ]
}