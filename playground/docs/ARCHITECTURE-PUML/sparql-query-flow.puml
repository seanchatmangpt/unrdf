@startuml sparql-query-flow
!theme plain
title SPARQL Query Flow - Ontology Querying Process

skinparam backgroundColor #FFFFFF
skinparam activityArrowThickness 2
skinparam roundcorner 10

start

partition "Query Resolution" {
    if (Query in args?) then (yes)
        :Use inline query;
    elseif (--file specified?) then (yes)
        :Load query from file;
        if (File exists?) then (yes)
            :Read query content;
        else (no)
            #pink:E_FILE_NOT_FOUND;
            stop
        endif
    else (no)
        #pink:E_NO_QUERY;
        stop
    endif
}

partition "Syntax Validation" {
    :Parse SPARQL query;

    if (Valid syntax?) then (yes)
        :Extract query type;
        note right
            Types:
            - SELECT
            - ASK
            - CONSTRUCT
            - DESCRIBE
        end note
    else (no)
        #pink:E_SYNTAX_ERROR|
        Line: X
        Column: Y;
        stop
    endif

    :Check for prohibited operations;

    if (Safe query?) then (yes)
        :Query approved;
    else (no)
        #pink:E_PROHIBITED_OPERATION|
        DELETE/INSERT not allowed;
        stop
    endif
}

partition "Ontology Loading" {
    :Resolve ontology path from config;

    if (Ontology file exists?) then (yes)
        :Load Turtle file;
    else (no)
        #pink:E_ONTOLOGY_NOT_FOUND;
        stop
    endif

    :Parse Turtle to triples;

    if (Parse success?) then (yes)
        :Build in-memory store;
    else (no)
        #pink:E_PARSE_ERROR;
        stop
    endif

    :Process owl:imports (recursive);
}

partition "Query Execution" {
    :Analyze query complexity;

    if (Potential cartesian?) then (yes)
        #yellow:Warning: Large result set possible;
    endif

    :Execute query against store;

    :Apply LIMIT from args;

    if (Timeout?) then (yes)
        #pink:E_QUERY_TIMEOUT;
        stop
    else (no)
        :Collect result bindings;
    endif
}

partition "Result Formatting" {
    switch (--format)
    case ( table )
        :Format as ASCII table|
        Column headers
        Separator line
        Data rows;
    case ( json )
        :Format as JSON|
        {
          "head": {"vars": [...]},
          "results": {"bindings": [...]}
        };
    case ( csv )
        :Format as CSV|
        header,row
        value1,value2;
    endswitch

    if (Results truncated?) then (yes)
        :Add truncation notice;
    endif
}

:Return formatted results;

stop

@enduml
