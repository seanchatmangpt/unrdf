/**
 * @fileoverview Bash Completions Generator
 *
 * @description
 * Generates bash completion scripts for the playground CLI.
 * Supports command completion, subcommand completion, argument completion,
 * and dynamic completion from domain data.
 *
 * @module cli/completions/bash
 * @version 1.0.0
 * @license MIT
 */

/**
 * @typedef {Object} CommandDef
 * @property {string} name - Command name
 * @property {string} description - Command description
 * @property {Array<string>} subcommands - Subcommand names
 * @property {Object<string, ArgDef>} args - Argument definitions
 */

/**
 * @typedef {Object} ArgDef
 * @property {string} type - Argument type
 * @property {string} description - Argument description
 * @property {Array<string>} [choices] - Valid choices
 * @property {boolean} [required] - Whether required
 */

/**
 * CLI command structure for completions
 * @type {Object<string, CommandDef>}
 */
const CLI_STRUCTURE = {
  papers: {
    name: 'papers',
    description: 'Manage research papers',
    subcommands: ['generate', 'list', 'validate'],
    args: {
      generate: {
        '--family': { choices: ['imrad', 'dsr', 'argument', 'contribution', 'IMRaD', 'DSR', 'Argument', 'Contribution'] },
        '--title': { type: 'string', description: 'Paper title' },
        '--author': { type: 'string', description: 'Author name' },
        '--affiliation': { type: 'string', description: 'Author affiliation' },
        '--abstract': { type: 'string', description: 'Paper abstract' },
        '--output': { type: 'file', description: 'Output file path' },
        '--format': { choices: ['json', 'latex', 'yaml'] }
      },
      list: {
        '--verbose': { type: 'boolean' },
        '--format': { choices: ['json', 'yaml', 'table'] }
      },
      validate: {
        '--strict': { type: 'boolean' },
        '--format': { choices: ['json', 'table'] }
      }
    }
  },
  thesis: {
    name: 'thesis',
    description: 'Manage thesis documents',
    subcommands: ['generate', 'list', 'schedule'],
    args: {
      generate: {
        '--type': { choices: ['masters', 'phd', 'doctoral', 'Masters', 'PhD', 'Doctoral'] },
        '--title': { type: 'string', description: 'Thesis title' },
        '--author': { type: 'string', description: 'Author name' },
        '--advisor': { type: 'string', description: 'Advisor name' },
        '--institution': { type: 'string', description: 'Institution name' },
        '--department': { type: 'string', description: 'Department name' },
        '--output': { type: 'file', description: 'Output file path' },
        '--format': { choices: ['json', 'latex', 'yaml'] }
      },
      list: {
        '--verbose': { type: 'boolean' },
        '--format': { choices: ['json', 'yaml', 'table'] }
      },
      schedule: {
        '--milestone': { type: 'string' },
        '--date': { type: 'string' }
      }
    }
  },
  config: {
    name: 'config',
    description: 'Manage CLI configuration',
    subcommands: ['list', 'get', 'set', 'reset'],
    args: {
      get: {
        'key': { type: 'positional', description: 'Config key' }
      },
      set: {
        'key': { type: 'positional', description: 'Config key' },
        'value': { type: 'positional', description: 'Config value' }
      },
      reset: {
        '--all': { type: 'boolean' }
      }
    }
  },
  meta: {
    name: 'meta',
    description: 'Metadata and introspection',
    subcommands: ['sparql', 'schema', 'version', 'completions'],
    args: {
      sparql: {
        'query': { type: 'positional', description: 'SPARQL query' },
        '--format': { choices: ['json', 'table', 'csv'] },
        '--file': { type: 'file', description: 'Query file' }
      },
      schema: {
        '--format': { choices: ['json', 'yaml', 'turtle'] }
      },
      completions: {
        '--shell': { choices: ['bash', 'zsh', 'fish', 'powershell'] },
        '--output': { type: 'file', description: 'Output file' }
      }
    }
  }
};

/**
 * Global CLI arguments
 */
const GLOBAL_ARGS = [
  '-q', '--quiet',
  '-v', '--verbose',
  '-f', '--format',
  '-o', '--output',
  '-c', '--config',
  '-h', '--help',
  '--version'
];

/**
 * Generate bash completion script
 * @param {Object} [options] - Generation options
 * @param {string} [options.cliName] - CLI command name
 * @param {Object} [options.commands] - Command structure override
 * @param {boolean} [options.includeDynamic] - Include dynamic completions
 * @returns {string} Bash completion script
 */
export function generateBashCompletions(options = {}) {
  const {
    cliName = 'playground',
    commands = CLI_STRUCTURE,
    includeDynamic = true
  } = options;

  const commandNames = Object.keys(commands);
  const globalArgsStr = GLOBAL_ARGS.join(' ');

  let script = `#!/bin/bash
# Bash completion for ${cliName} CLI
# Generated by papers-thesis-cli completions generator
#
# Installation:
#   1. Copy to /usr/local/etc/bash_completion.d/${cliName}
#   2. Or source directly: source /path/to/${cliName}-completion.bash
#   3. Or add to ~/.bashrc: source /path/to/${cliName}-completion.bash

_${cliName}_completions() {
    local cur prev words cword split
    _init_completion -s || return

    # Get command context
    local cmd=""
    local subcmd=""
    local i=1

    while [[ $i -lt $cword ]]; do
        case "\${words[$i]}" in
            ${commandNames.join('|')})
                cmd="\${words[$i]}"
                ;;
            *)
                if [[ -n "$cmd" && -z "$subcmd" && ! "\${words[$i]}" =~ ^- ]]; then
                    subcmd="\${words[$i]}"
                fi
                ;;
        esac
        ((i++))
    done

    # Complete based on context
    case "$prev" in
        # Global options that take arguments
        -f|--format)
            COMPREPLY=($(compgen -W "json json-pretty yaml table latex csv" -- "$cur"))
            return
            ;;
        -o|--output)
            _filedir
            return
            ;;
        -c|--config)
            _filedir '@(json|yaml|yml|mjs|js)'
            return
            ;;
`;

  // Generate command-specific completions
  for (const [cmdName, cmdDef] of Object.entries(commands)) {
    script += `
        # ${cmdName} command completions
        ${cmdName})
            COMPREPLY=($(compgen -W "${cmdDef.subcommands.join(' ')}" -- "$cur"))
            return
            ;;
`;

    // Generate subcommand argument completions
    for (const [subcmdName, subcmdArgs] of Object.entries(cmdDef.args)) {
      for (const [argName, argDef] of Object.entries(subcmdArgs)) {
        if (argDef.choices) {
          script += `        ${argName})
            if [[ "$cmd" == "${cmdName}" ]]; then
                COMPREPLY=($(compgen -W "${argDef.choices.join(' ')}" -- "$cur"))
                return
            fi
            ;;
`;
        } else if (argDef.type === 'file') {
          script += `        ${argName})
            if [[ "$cmd" == "${cmdName}" ]]; then
                _filedir
                return
            fi
            ;;
`;
        }
      }
    }
  }

  script += `    esac

    # Main command completion logic
    if [[ -z "$cmd" ]]; then
        # No command yet, complete commands and global options
        COMPREPLY=($(compgen -W "${commandNames.join(' ')} ${globalArgsStr}" -- "$cur"))
    elif [[ -z "$subcmd" && "$cur" != -* ]]; then
        # Have command, complete subcommands
        case "$cmd" in
`;

  for (const [cmdName, cmdDef] of Object.entries(commands)) {
    script += `            ${cmdName})
                COMPREPLY=($(compgen -W "${cmdDef.subcommands.join(' ')}" -- "$cur"))
                ;;
`;
  }

  script += `        esac
    else
        # Have subcommand, complete arguments
        local opts=""
        case "$cmd:$subcmd" in
`;

  for (const [cmdName, cmdDef] of Object.entries(commands)) {
    for (const [subcmdName, subcmdArgs] of Object.entries(cmdDef.args)) {
      const argNames = Object.keys(subcmdArgs).filter(a => a.startsWith('-'));
      if (argNames.length > 0) {
        script += `            ${cmdName}:${subcmdName})
                opts="${argNames.join(' ')} ${globalArgsStr}"
                ;;
`;
      }
    }
  }

  script += `        esac

        if [[ "$cur" == -* ]]; then
            COMPREPLY=($(compgen -W "$opts" -- "$cur"))
        else
            # File completion for positional arguments
            _filedir
        fi
    fi
}

# Register completion function
complete -F _${cliName}_completions ${cliName}
`;

  // Add dynamic completions section if requested
  if (includeDynamic) {
    script += `
# Dynamic completions (optional)
# These functions can be customized to load completions from domain data

_${cliName}_complete_papers() {
    # Load available papers from knowledge graph or cache
    # Example: local papers=$($cliName papers list --format=names 2>/dev/null)
    # COMPREPLY=($(compgen -W "$papers" -- "$1"))
    :
}

_${cliName}_complete_thesis() {
    # Load available thesis documents from knowledge graph or cache
    :
}

_${cliName}_complete_templates() {
    # Load available templates
    local templates="imrad dsr argument contribution masters phd doctoral"
    COMPREPLY=($(compgen -W "$templates" -- "$1"))
}
`;
  }

  return script;
}

/**
 * Generate completion for a specific command
 * @param {string} command - Command name
 * @param {Object} [options] - Options
 * @returns {string} Bash completion snippet
 */
export function generateCommandCompletion(command, options = {}) {
  const cmdDef = CLI_STRUCTURE[command];
  if (!cmdDef) {
    throw new Error(`Unknown command: ${command}`);
  }

  return `# Completion for ${command} command
_playground_${command}() {
    local cur prev
    cur="\${COMP_WORDS[COMP_CWORD]}"
    prev="\${COMP_WORDS[COMP_CWORD-1]}"

    case "$prev" in
        ${command})
            COMPREPLY=($(compgen -W "${cmdDef.subcommands.join(' ')}" -- "$cur"))
            ;;
        *)
            COMPREPLY=($(compgen -f -- "$cur"))
            ;;
    esac
}
`;
}

/**
 * Get installation instructions for bash completions
 * @param {string} [outputPath] - Path where completions are saved
 * @returns {string} Installation instructions
 */
export function getBashInstallInstructions(outputPath = 'playground-completion.bash') {
  return `
Bash Completion Installation
============================

Option 1: System-wide installation (requires sudo)
  sudo cp ${outputPath} /usr/local/etc/bash_completion.d/playground

Option 2: User installation
  mkdir -p ~/.bash_completion.d
  cp ${outputPath} ~/.bash_completion.d/
  echo 'source ~/.bash_completion.d/playground-completion.bash' >> ~/.bashrc

Option 3: Direct sourcing
  source ${outputPath}

After installation, restart your terminal or run:
  source ~/.bashrc
`.trim();
}

export default generateBashCompletions;
