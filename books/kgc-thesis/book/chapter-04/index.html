<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Chapter 4: Knowledge Hooks - Predicate Algebra - Knowledge Geometry Calculus: From Field Theory to the Autonomic Enterprise</title>


        <!-- Custom HTML head -->

        <meta name="description" content="A mathematical framework for autonomic knowledge graph systems that transforms static RDF into self-governing, reactive, and cryptographically verifiable substrates">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "ayu";
            window.path_to_searchindex_js = "../searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>‚Üê</kbd> or <kbd>‚Üí</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Knowledge Geometry Calculus: From Field Theory to the Autonomic Enterprise</h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/gitvan/unrdf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="chapter-4-knowledge-hooks--predicate-algebra-and-formal-semantics"><a class="header" href="#chapter-4-knowledge-hooks--predicate-algebra-and-formal-semantics">Chapter 4: Knowledge Hooks ‚Äî Predicate Algebra and Formal Semantics</a></h1>
<h2 id="abstract"><a class="header" href="#abstract">Abstract</a></h2>
<p>This chapter formalizes Knowledge Hooks as a compositional predicate algebra over RDF graph bindings. We provide executable lambda calculus, denotational semantics, complexity bounds, and cryptographic provenance guarantees with formal proofs.</p>
<h2 id="table-of-contents"><a class="header" href="#table-of-contents">Table of Contents</a></h2>
<ol>
<li><a href="#1-predicate-algebra-foundations">Predicate Algebra Foundations</a></li>
<li><a href="#2-denotational-semantics">Denotational Semantics</a></li>
<li><a href="#3-predicate-type-system">Predicate Type System</a></li>
<li><a href="#4-complexity-analysis">Complexity Analysis</a></li>
<li><a href="#5-receipt-provenance">Receipt Provenance</a></li>
<li><a href="#6-algebraic-laws">Algebraic Laws</a></li>
</ol>
<hr />
<h2 id="1-predicate-algebra-foundations"><a class="header" href="#1-predicate-algebra-foundations">1. Predicate Algebra Foundations</a></h2>
<h3 id="11-core-type-definitions"><a class="header" href="#11-core-type-definitions">1.1 Core Type Definitions</a></h3>
<p><strong>Definition 1.1</strong> (Binding Type)</p>
<pre><code>Binding ‚â° Var ‚Üí Value
Bindings ‚â° Set[Binding]
</code></pre>
<p><strong>Definition 1.2</strong> (Predicate Type)</p>
<pre><code>Œ† ‚â° Bindings ‚Üí Bool

With monoid structure:
  Œµ_Œ† : Œ†              // Identity: Œªb. ‚ä§
  ‚àò_Œ† : Œ† ‚Üí Œ† ‚Üí Œ†     // Composition: conjunction
</code></pre>
<p><strong>Definition 1.3</strong> (Effect Type)</p>
<pre><code>Effect ‚â° Graph ‚Üí Graph ‚äé Error
Œµ : Effect              // No-op effect: Œªg. g
</code></pre>
<p><strong>Definition 1.4</strong> (Hook Type)</p>
<pre><code>Hook ‚â° {
  query : SPARQL,
  predicates : [Œ†],
  combinator : [Bool] ‚Üí Bool,
  effect : Effect
}
</code></pre>
<h3 id="12-predicate-algebra-operations"><a class="header" href="#12-predicate-algebra-operations">1.2 Predicate Algebra Operations</a></h3>
<p><strong>Definition 1.5</strong> (Conjunction)</p>
<pre><code>(œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) : Œ†
(œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) = Œªb. œÄ‚ÇÅ(b) ‚àß œÄ‚ÇÇ(b)
</code></pre>
<p><strong>Definition 1.6</strong> (Disjunction)</p>
<pre><code>(œÄ‚ÇÅ ‚à® œÄ‚ÇÇ) : Œ†
(œÄ‚ÇÅ ‚à® œÄ‚ÇÇ) = Œªb. œÄ‚ÇÅ(b) ‚à® œÄ‚ÇÇ(b)
</code></pre>
<p><strong>Definition 1.7</strong> (Negation)</p>
<pre><code>(¬¨œÄ) : Œ†
(¬¨œÄ) = Œªb. ¬¨œÄ(b)
</code></pre>
<p><strong>Definition 1.8</strong> (Threshold Combinator)</p>
<pre><code>threshold‚Çñ : [Œ†] ‚Üí Œ†
threshold‚Çñ(œÄ‚ÇÅ, ..., œÄ‚Çô) = Œªb. (|{i | œÄ·µ¢(b) = ‚ä§}|) ‚â• k
</code></pre>
<h3 id="13-monoid-laws"><a class="header" href="#13-monoid-laws">1.3 Monoid Laws</a></h3>
<p><strong>Theorem 1.1</strong> (Œ† forms a monoid under ‚àß)</p>
<pre><code>(Œ†, ‚àß, Œµ_Œ†) is a monoid with:
  1. Identity:      œÄ ‚àß Œµ_Œ† = Œµ_Œ† ‚àß œÄ = œÄ
  2. Associativity: (œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) ‚àß œÄ‚ÇÉ = œÄ‚ÇÅ ‚àß (œÄ‚ÇÇ ‚àß œÄ‚ÇÉ)
  3. Commutativity: œÄ‚ÇÅ ‚àß œÄ‚ÇÇ = œÄ‚ÇÇ ‚àß œÄ‚ÇÅ
</code></pre>
<p><strong>Proof</strong>: By Œª-calculus reduction</p>
<pre><code>(œÄ‚ÇÅ ‚àß œÄ‚ÇÇ)(b)
  = (Œªb. œÄ‚ÇÅ(b) ‚àß œÄ‚ÇÇ(b))(b)
  ‚Üí œÄ‚ÇÅ(b) ‚àß œÄ‚ÇÇ(b)           [Œ≤-reduction]
  = œÄ‚ÇÇ(b) ‚àß œÄ‚ÇÅ(b)           [‚àß-commutativity]
  = (œÄ‚ÇÇ ‚àß œÄ‚ÇÅ)(b)
</code></pre>
<p>‚àé</p>
<hr />
<h2 id="2-denotational-semantics"><a class="header" href="#2-denotational-semantics">2. Denotational Semantics</a></h2>
<h3 id="21-semantic-domains"><a class="header" href="#21-semantic-domains">2.1 Semantic Domains</a></h3>
<p><strong>Definition 2.1</strong> (Boolean Domain)</p>
<pre><code>ùîπ = {‚ä§, ‚ä•}
‚ü¶_‚üß_ùîπ : Œ† ‚Üí (Bindings ‚Üí ùîπ)
</code></pre>
<p><strong>Definition 2.2</strong> (Graph Domain)</p>
<pre><code>ùîæ = Set[Triple]
Triple = (Subject √ó Predicate √ó Object)
</code></pre>
<p><strong>Definition 2.3</strong> (Effect Domain)</p>
<pre><code>‚Ñ∞ = ùîæ ‚Üí (ùîæ ‚äé Error)
Error = {TimeoutError, ValidationError, RuntimeError, ...}
</code></pre>
<h3 id="22-compositional-evaluation"><a class="header" href="#22-compositional-evaluation">2.2 Compositional Evaluation</a></h3>
<p><strong>Definition 2.4</strong> (Predicate Denotation)</p>
<pre><code>‚ü¶œÄ‚üß : Bindings ‚Üí ùîπ

Compositional rules:
  ‚ü¶œÄ‚ÇÅ ‚àß œÄ‚ÇÇ‚üß(b) = ‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß_ùîπ ‚ü¶œÄ‚ÇÇ‚üß(b)
  ‚ü¶œÄ‚ÇÅ ‚à® œÄ‚ÇÇ‚üß(b) = ‚ü¶œÄ‚ÇÅ‚üß(b) ‚à®_ùîπ ‚ü¶œÄ‚ÇÇ‚üß(b)
  ‚ü¶¬¨œÄ‚üß(b)      = ¬¨_ùîπ ‚ü¶œÄ‚üß(b)
  ‚ü¶Œµ_Œ†‚üß(b)     = ‚ä§
</code></pre>
<p><strong>Definition 2.5</strong> (Effect Denotation)</p>
<pre><code>‚ü¶Œµ‚üß : ùîæ ‚Üí (ùîæ ‚äé Error)

Effect composition:
  ‚ü¶Œµ‚ÇÅ ; Œµ‚ÇÇ‚üß(g) = match ‚ü¶Œµ‚ÇÅ‚üß(g) with
    | Left(err)  ‚Üí Left(err)
    | Right(g')  ‚Üí ‚ü¶Œµ‚ÇÇ‚üß(g')
</code></pre>
<p><strong>Theorem 2.1</strong> (Compositionality)</p>
<pre><code>‚àÄœÄ‚ÇÅ, œÄ‚ÇÇ : Œ†, b : Bindings.
  ‚ü¶œÄ‚ÇÅ ‚àß œÄ‚ÇÇ‚üß(b) = ‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß ‚ü¶œÄ‚ÇÇ‚üß(b)
</code></pre>
<p><strong>Proof</strong>: Direct from Definition 2.4 ‚àé</p>
<hr />
<h2 id="3-predicate-type-system"><a class="header" href="#3-predicate-type-system">3. Predicate Type System</a></h2>
<h3 id="31-ask-predicates"><a class="header" href="#31-ask-predicates">3.1 ASK Predicates</a></h3>
<p><strong>Type Signature</strong>:</p>
<pre><code>œÄ‚Çê‚Çõ‚Çñ : SPARQL ‚Üí Option[Bool] ‚Üí Œ†
</code></pre>
<p><strong>Lambda Definition</strong>:</p>
<pre><code>œÄ‚Çê‚Çõ‚Çñ(Q, expected) = Œªb : Bindings.
  let result = ‚ü¶Q‚üß(G) in          // Execute ASK query
  match expected with
    | None         ‚Üí result
    | Some(exp)    ‚Üí result = exp
</code></pre>
<p><strong>Denotational Semantics</strong>:</p>
<pre><code>‚ü¶œÄ‚Çê‚Çõ‚Çñ(Q, expected)‚üß : Bindings ‚Üí ùîπ

‚ü¶œÄ‚Çê‚Çõ‚Çñ(Q, None)‚üß(b) = ASK(Q, G)
‚ü¶œÄ‚Çê‚Çõ‚Çñ(Q, Some(v))‚üß(b) = ASK(Q, G) = v
</code></pre>
<p><strong>Selectivity Analysis</strong>:</p>
<pre><code>selectivity(œÄ‚Çê‚Çõ‚Çñ) = |{b ‚àà B | ‚ü¶œÄ‚Çê‚Çõ‚Çñ‚üß(b) = ‚ä§}| / |B|

Optimization:
  If selectivity &lt; 0.1, prefer indexed lookups
  If selectivity &gt; 0.9, skip evaluation (always true)
</code></pre>
<h3 id="32-shacl-predicates"><a class="header" href="#32-shacl-predicates">3.2 SHACL Predicates</a></h3>
<p><strong>Type Signature</strong>:</p>
<pre><code>œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó : Shapes ‚Üí Mode ‚Üí Strict ‚Üí Œ†

where
  Shapes = Set[Shape]
  Mode   = Conforms | Violates
  Strict = Bool
</code></pre>
<p><strong>Lambda Definition</strong>:</p>
<pre><code>œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó(S, mode, strict) = Œªb : Bindings.
  let report = validate(G, S) in
  let violations = {v ‚àà report | severity(v) ‚â• threshold} in
  match mode with
    | Conforms  ‚Üí |violations| = 0
    | Violates  ‚Üí |violations| &gt; 0 ‚àß (strict ‚üπ fail_fast)
</code></pre>
<p><strong>Denotational Semantics</strong>:</p>
<pre><code>‚ü¶œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó(S, Conforms, _)‚üß(b) = conforms(G, S)
‚ü¶œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó(S, Violates, strict)‚üß(b) = ¬¨conforms(G, S) ‚àß (strict ‚üπ ‚ä•)
</code></pre>
<p><strong>Pruning Strategy</strong>:</p>
<pre><code>Early termination:
  For Conforms mode: stop on first violation
  For Violates mode: stop when k violations found
</code></pre>
<h3 id="33-delta-predicates"><a class="header" href="#33-delta-predicates">3.3 DELTA Predicates</a></h3>
<p><strong>Type Signature</strong>:</p>
<pre><code>œÄ·¥Ö‚Çë‚Çó‚Çú‚Çê : Bindings ‚Üí Baseline ‚Üí Keys ‚Üí ChangeMode ‚Üí Threshold ‚Üí Œ†

where
  Baseline   = Map[Key, Hash]
  ChangeMode = Any | Increase | Decrease
  Threshold  = ‚Ñù
</code></pre>
<p><strong>Lambda Definition</strong>:</p>
<pre><code>œÄ·¥Ö‚Çë‚Çó‚Çú‚Çê(B, B_prev, K, change, Œ¥) = Œªb : Bindings.
  let key = project(b, K) in
  let h_curr = H‚ÇÇ‚ÇÖ‚ÇÜ(canonical(b)) in
  let h_prev = lookup(B_prev, key) in
  match h_prev with
    | None    ‚Üí false
    | Some(h) ‚Üí
        let diff = |h_curr - h| / h in
        match change with
          | Any       ‚Üí h_curr ‚â† h
          | Increase  ‚Üí diff &gt; Œ¥
          | Decrease  ‚Üí diff &lt; -Œ¥
</code></pre>
<p><strong>Hash Function Properties</strong>:</p>
<pre><code>H‚ÇÇ‚ÇÖ‚ÇÜ : Binding ‚Üí {0,1}¬≤‚Åµ‚Å∂

Properties:
  1. Deterministic: H(b) = H(b')  ‚ü∫  b = b'
  2. Pre-image resistance: ‚àÄh. hard to find b s.t. H(b) = h
  3. Collision resistance: hard to find b ‚â† b' s.t. H(b) = H(b')
</code></pre>
<p><strong>Canonical Form</strong>:</p>
<pre><code>canonical : Binding ‚Üí String
canonical(b) = sort([(k, v) | (k, v) ‚àà b])
</code></pre>
<h3 id="34-threshold-predicates"><a class="header" href="#34-threshold-predicates">3.4 THRESHOLD Predicates</a></h3>
<p><strong>Type Signature</strong>:</p>
<pre><code>œÄ‚Çú‚Çï·µ£ : Bindings ‚Üí Var ‚Üí Op ‚Üí Value ‚Üí Option[Agg] ‚Üí Œ†

where
  Op  = LT | LE | EQ | GE | GT
  Agg = Sum | Avg | Count | Max | Min
</code></pre>
<p><strong>Lambda Definition</strong>:</p>
<pre><code>œÄ‚Çú‚Çï·µ£(B, var, op, Œ∏, agg) = Œªb : Bindings.
  let values = {b[var] | b ‚àà B ‚àß isNumeric(b[var])} in
  let v = match agg with
    | None        ‚Üí ‚àÉv ‚àà values
    | Some(Sum)   ‚Üí Œ£ values
    | Some(Avg)   ‚Üí (Œ£ values) / |values|
    | Some(Count) ‚Üí |values|
    | Some(Max)   ‚Üí max(values)
    | Some(Min)   ‚Üí min(values)
  in
  compare(v, op, Œ∏)
</code></pre>
<p><strong>Comparison Semantics</strong>:</p>
<pre><code>compare : Value ‚Üí Op ‚Üí Value ‚Üí Bool

compare(v, LT, Œ∏) = v &lt; Œ∏
compare(v, LE, Œ∏) = v ‚â§ Œ∏
compare(v, EQ, Œ∏) = v = Œ∏
compare(v, GE, Œ∏) = v ‚â• Œ∏
compare(v, GT, Œ∏) = v &gt; Œ∏
</code></pre>
<h3 id="35-count-predicates"><a class="header" href="#35-count-predicates">3.5 COUNT Predicates</a></h3>
<p><strong>Type Signature</strong>:</p>
<pre><code>œÄ·¥Ñ‚Çí·¥ú‚Çô‚Çú : Bindings ‚Üí Op ‚Üí ‚Ñï ‚Üí Œ†
</code></pre>
<p><strong>Lambda Definition</strong>:</p>
<pre><code>œÄ·¥Ñ‚Çí·¥ú‚Çô‚Çú(B, op, n) = Œªb : Bindings.
  compare(|B|, op, n)
</code></pre>
<p><strong>Denotational Semantics</strong>:</p>
<pre><code>‚ü¶œÄ·¥Ñ‚Çí·¥ú‚Çô‚Çú(B, op, n)‚üß(b) = compare(|B|, op, n)
</code></pre>
<h3 id="36-window-predicates"><a class="header" href="#36-window-predicates">3.6 WINDOW Predicates</a></h3>
<p><strong>Type Signature</strong>:</p>
<pre><code>œÄ·¥°…™…¥·¥Ö‚Çí·¥° : Bindings ‚Üí Var ‚Üí Duration ‚Üí Agg ‚Üí Comparison ‚Üí Œ†

where
  Duration   = Milliseconds
  Comparison = {op: Op, value: Value}
</code></pre>
<p><strong>Lambda Definition</strong>:</p>
<pre><code>œÄ·¥°…™…¥·¥Ö‚Çí·¥°(B, var, size, agg, cmp) = Œªb : Bindings.
  let t_now = now() in
  let window = {b ‚àà B | t_now - size ‚â§ b.timestamp &lt; t_now} in
  let values = {b[var] | b ‚àà window} in
  let result = aggregate(values, agg) in
  compare(result, cmp.op, cmp.value)
</code></pre>
<p><strong>Tumbling Window</strong>:</p>
<pre><code>Window(t‚ÇÄ, Œît) = {b ‚àà B | t‚ÇÄ ‚â§ b.timestamp &lt; t‚ÇÄ + Œît}

Non-overlapping:
  Window(t‚ÇÄ, Œît) ‚à© Window(t‚ÇÄ + Œît, Œît) = ‚àÖ
</code></pre>
<hr />
<h2 id="4-complexity-analysis"><a class="header" href="#4-complexity-analysis">4. Complexity Analysis</a></h2>
<h3 id="41-time-complexity-bounds"><a class="header" href="#41-time-complexity-bounds">4.1 Time Complexity Bounds</a></h3>
<p><strong>Theorem 4.1</strong> (ASK Predicate Complexity)</p>
<pre><code>T(œÄ‚Çê‚Çõ‚Çñ) = O(|G|)

With SPARQL optimizations:
  - Index-based: O(log |G|)
  - Selectivity-pruned: O(s¬∑|G|) where s = selectivity
</code></pre>
<p><strong>Proof</strong>:
ASK query requires full graph scan in worst case. With B-tree indexing on triple patterns, lookup reduces to O(log |G|). Selectivity pruning reduces effective graph size to s¬∑|G|. ‚àé</p>
<p><strong>Theorem 4.2</strong> (SHACL Predicate Complexity)</p>
<pre><code>T(œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó) = O(|S| √ó |G|)

With pruning:
  - Early termination: O(k¬∑|G|) where k = violations threshold
  - Shape caching: O(|S| + |G|) amortized
</code></pre>
<p><strong>Proof</strong>:
Each shape S_i validates against entire graph G, yielding |S| √ó |G| operations. Early termination stops after k violations, reducing to k¬∑|G|. Shape caching stores validation results for reuse. ‚àé</p>
<p><strong>Theorem 4.3</strong> (DELTA Predicate Complexity)</p>
<pre><code>T(œÄ·¥Ö‚Çë‚Çó‚Çú‚Çê) = O(|B| log |B|)

Hash table implementation:
  - Lookup: O(1) expected, O(log |B|) worst case
  - Hash computation: O(|b|) per binding
  - Total: O(|B| √ó |b| + |B| log |B|)
</code></pre>
<p><strong>Proof</strong>:
For each binding b ‚àà B:</p>
<ol>
<li>Project to key: O(|K|)</li>
<li>Hash computation: O(|b|)</li>
<li>Hash table lookup: O(1) expected
Total: O(|B| √ó (|K| + |b|)) = O(|B| log |B|) ‚àé</li>
</ol>
<p><strong>Theorem 4.4</strong> (THRESHOLD Predicate Complexity)</p>
<pre><code>T(œÄ‚Çú‚Çï·µ£) = O(|B|)

Aggregation analysis:
  - Sum/Count: O(|B|)
  - Avg: O(|B|)
  - Max/Min: O(|B|) with linear scan, O(|B| log |B|) for sorted
</code></pre>
<p><strong>Theorem 4.5</strong> (COUNT Predicate Complexity)</p>
<pre><code>T(œÄ·¥Ñ‚Çí·¥ú‚Çô‚Çú) = O(1)

Cardinality is pre-computed during binding evaluation.
</code></pre>
<p><strong>Theorem 4.6</strong> (WINDOW Predicate Complexity)</p>
<pre><code>T(œÄ·¥°…™…¥·¥Ö‚Çí·¥°) = O(|B|)

With time-based indexing:
  - Range query: O(log |B| + k) where k = window size
  - Aggregation: O(k)
  - Total: O(log |B| + k)
</code></pre>
<h3 id="42-space-complexity"><a class="header" href="#42-space-complexity">4.2 Space Complexity</a></h3>
<p><strong>Theorem 4.7</strong> (Space Bounds)</p>
<pre><code>S(œÄ‚Çê‚Çõ‚Çñ)     = O(1)              // Boolean result
S(œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó)   = O(|violations|)  // Validation report
S(œÄ·¥Ö‚Çë‚Çó‚Çú‚Çê)   = O(|B_prev|)      // Baseline storage
S(œÄ‚Çú‚Çï·µ£)     = O(|values|)      // Numeric values
S(œÄ·¥Ñ‚Çí·¥ú‚Çô‚Çú)   = O(1)              // Cardinality
S(œÄ·¥°…™…¥·¥Ö‚Çí·¥°)  = O(k)              // Window buffer
</code></pre>
<hr />
<h2 id="5-receipt-provenance"><a class="header" href="#5-receipt-provenance">5. Receipt Provenance</a></h2>
<h3 id="51-cryptographic-commitment-scheme"><a class="header" href="#51-cryptographic-commitment-scheme">5.1 Cryptographic Commitment Scheme</a></h3>
<p><strong>Definition 5.1</strong> (Receipt Type)</p>
<pre><code>Receipt ‚â° {
  id          : IRI,
  fired       : Bool,
  predicates  : [PredicateResult],
  durations   : Metrics,
  provenance  : Provenance,
  timestamp   : Timestamp,
  actor       : IRI
}
</code></pre>
<p><strong>Definition 5.2</strong> (Provenance Type)</p>
<pre><code>Provenance ‚â° {
  hook_hash      : Hash,
  query_hash     : Hash,
  graph_hash     : Hash,
  baseline_hash  : Hash,
  receipt_hash   : Hash
}

where Hash = {0,1}¬≤‚Åµ‚Å∂
</code></pre>
<p><strong>Definition 5.3</strong> (Hash Commitment)</p>
<pre><code>commit : Receipt ‚Üí Hash
commit(R) = H‚ÇÇ‚ÇÖ‚ÇÜ(canonical(R))

Properties:
  1. Binding: commit(R) uniquely identifies R
  2. Hiding: R cannot be derived from commit(R)
  3. Collision-resistant: hard to find R ‚â† R' with commit(R) = commit(R')
</code></pre>
<h3 id="52-digital-signature-scheme"><a class="header" href="#52-digital-signature-scheme">5.2 Digital Signature Scheme</a></h3>
<p><strong>Definition 5.4</strong> (Signature Type)</p>
<pre><code>Signature ‚â° {
  receipt_hash : Hash,
  signature    : {0,1}·µè,
  public_key   : {0,1}‚Åø,
  algorithm    : SignatureAlgorithm
}

where
  SignatureAlgorithm = Ed25519 | ECDSA | RSA
</code></pre>
<p><strong>Definition 5.5</strong> (Signing Function)</p>
<pre><code>sign : Receipt ‚Üí PrivateKey ‚Üí Signature
sign(R, sk) = {
  receipt_hash: commit(R),
  signature:    Sign_sk(commit(R)),
  public_key:   derive_pk(sk),
  algorithm:    Ed25519
}
</code></pre>
<p><strong>Definition 5.6</strong> (Verification Function)</p>
<pre><code>verify : Receipt ‚Üí Signature ‚Üí Bool
verify(R, œÉ) =
  Verify_pk(commit(R), œÉ.signature)
  ‚àß commit(R) = œÉ.receipt_hash
</code></pre>
<p><strong>Theorem 5.1</strong> (Non-Repudiation)</p>
<pre><code>‚àÄR : Receipt, sk : PrivateKey.
  let œÉ = sign(R, sk) in
  verify(R, œÉ) = ‚ä§
  ‚àß ‚àÄR' ‚â† R. verify(R', œÉ) = ‚ä•
</code></pre>
<p><strong>Proof</strong>: By Ed25519 correctness and collision resistance of H‚ÇÇ‚ÇÖ‚ÇÜ</p>
<pre><code>verify(R, sign(R, sk))
  = Verify_pk(commit(R), Sign_sk(commit(R)))
  = ‚ä§                                          [Ed25519 correctness]

verify(R', sign(R, sk)) where R' ‚â† R
  = Verify_pk(commit(R'), Sign_sk(commit(R)))
  = ‚ä•                                          [commit(R) ‚â† commit(R')]
</code></pre>
<p>‚àé</p>
<h3 id="53-tamper-evidence"><a class="header" href="#53-tamper-evidence">5.3 Tamper-Evidence</a></h3>
<p><strong>Definition 5.7</strong> (Merkle Tree for Receipt Chain)</p>
<pre><code>MerkleTree ‚â° Tree[Hash]

root : MerkleTree ‚Üí Hash
root(Leaf(h))         = h
root(Branch(l, r))    = H‚ÇÇ‚ÇÖ‚ÇÜ(root(l) ‚à• root(r))

Receipt chain:
  receipts = [R‚ÇÅ, R‚ÇÇ, ..., R‚Çô]
  tree     = build_merkle([commit(R‚ÇÅ), ..., commit(R‚Çô)])
  root_hash = root(tree)
</code></pre>
<p><strong>Theorem 5.2</strong> (Tamper Detection)</p>
<pre><code>‚àÄi. modify(receipts[i]) ‚üπ root(tree) changes
</code></pre>
<p><strong>Proof</strong>:
Modifying R_i changes commit(R_i), which propagates up the Merkle tree, changing root hash. ‚àé</p>
<hr />
<h2 id="6-algebraic-laws"><a class="header" href="#6-algebraic-laws">6. Algebraic Laws</a></h2>
<h3 id="61-boolean-algebra"><a class="header" href="#61-boolean-algebra">6.1 Boolean Algebra</a></h3>
<p><strong>Theorem 6.1</strong> (Distributivity)</p>
<pre><code>œÄ‚ÇÅ ‚àß (œÄ‚ÇÇ ‚à® œÄ‚ÇÉ) = (œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) ‚à® (œÄ‚ÇÅ ‚àß œÄ‚ÇÉ)
</code></pre>
<p><strong>Proof</strong>:</p>
<pre><code>‚ü¶œÄ‚ÇÅ ‚àß (œÄ‚ÇÇ ‚à® œÄ‚ÇÉ)‚üß(b)
  = ‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß ‚ü¶œÄ‚ÇÇ ‚à® œÄ‚ÇÉ‚üß(b)
  = ‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß (‚ü¶œÄ‚ÇÇ‚üß(b) ‚à® ‚ü¶œÄ‚ÇÉ‚üß(b))
  = (‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß ‚ü¶œÄ‚ÇÇ‚üß(b)) ‚à® (‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß ‚ü¶œÄ‚ÇÉ‚üß(b))   [Boolean distributivity]
  = ‚ü¶(œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) ‚à® (œÄ‚ÇÅ ‚àß œÄ‚ÇÉ)‚üß(b)
</code></pre>
<p>‚àé</p>
<p><strong>Theorem 6.2</strong> (De Morgan's Laws)</p>
<pre><code>¬¨(œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) = (¬¨œÄ‚ÇÅ) ‚à® (¬¨œÄ‚ÇÇ)
¬¨(œÄ‚ÇÅ ‚à® œÄ‚ÇÇ) = (¬¨œÄ‚ÇÅ) ‚àß (¬¨œÄ‚ÇÇ)
</code></pre>
<p><strong>Proof</strong>: By Œª-reduction</p>
<pre><code>‚ü¶¬¨(œÄ‚ÇÅ ‚àß œÄ‚ÇÇ)‚üß(b)
  = ¬¨(‚ü¶œÄ‚ÇÅ‚üß(b) ‚àß ‚ü¶œÄ‚ÇÇ‚üß(b))
  = (¬¨‚ü¶œÄ‚ÇÅ‚üß(b)) ‚à® (¬¨‚ü¶œÄ‚ÇÇ‚üß(b))        [De Morgan]
  = ‚ü¶(¬¨œÄ‚ÇÅ) ‚à® (¬¨œÄ‚ÇÇ)‚üß(b)
</code></pre>
<p>‚àé</p>
<h3 id="62-combinator-laws"><a class="header" href="#62-combinator-laws">6.2 Combinator Laws</a></h3>
<p><strong>Theorem 6.3</strong> (Threshold Monotonicity)</p>
<pre><code>k‚ÇÅ ‚â§ k‚ÇÇ ‚üπ threshold‚Çñ‚ÇÇ(œÄ‚ÇÅ, ..., œÄ‚Çô) ‚üπ threshold‚Çñ‚ÇÅ(œÄ‚ÇÅ, ..., œÄ‚Çô)
</code></pre>
<p><strong>Proof</strong>:</p>
<pre><code>If |{i | œÄ·µ¢(b) = ‚ä§}| ‚â• k‚ÇÇ, then |{i | œÄ·µ¢(b) = ‚ä§}| ‚â• k‚ÇÅ since k‚ÇÅ ‚â§ k‚ÇÇ
</code></pre>
<p>‚àé</p>
<p><strong>Theorem 6.4</strong> (Threshold Equivalences)</p>
<pre><code>threshold‚ÇÄ(œÄ‚ÇÅ, ..., œÄ‚Çô) ‚â° ‚ä§
threshold‚ÇÅ(œÄ‚ÇÅ, ..., œÄ‚Çô) ‚â° œÄ‚ÇÅ ‚à® ... ‚à® œÄ‚Çô
threshold‚Çô(œÄ‚ÇÅ, ..., œÄ‚Çô) ‚â° œÄ‚ÇÅ ‚àß ... ‚àß œÄ‚Çô
</code></pre>
<p><strong>Proof</strong>: By cardinality analysis</p>
<pre><code>threshold‚ÇÄ: always satisfied (0 predicates needed)
threshold‚ÇÅ: at least one predicate true (disjunction)
threshold‚Çô: all n predicates true (conjunction)
</code></pre>
<p>‚àé</p>
<h3 id="63-effect-algebra"><a class="header" href="#63-effect-algebra">6.3 Effect Algebra</a></h3>
<p><strong>Theorem 6.5</strong> (Effect Composition Associativity)</p>
<pre><code>(Œµ‚ÇÅ ; Œµ‚ÇÇ) ; Œµ‚ÇÉ = Œµ‚ÇÅ ; (Œµ‚ÇÇ ; Œµ‚ÇÉ)
</code></pre>
<p><strong>Proof</strong>: By monadic bind associativity in (ùîæ ‚äé Error) ‚àé</p>
<p><strong>Theorem 6.6</strong> (Effect Identity)</p>
<pre><code>Œµ ; Œµ_id = Œµ_id ; Œµ = Œµ
where Œµ_id = Œªg. Right(g)
</code></pre>
<p><strong>Proof</strong>:</p>
<pre><code>‚ü¶Œµ ; Œµ_id‚üß(g)
  = match ‚ü¶Œµ‚üß(g) with
    | Left(e)   ‚Üí Left(e)
    | Right(g') ‚Üí ‚ü¶Œµ_id‚üß(g')
  = match ‚ü¶Œµ‚üß(g) with
    | Left(e)   ‚Üí Left(e)
    | Right(g') ‚Üí Right(g')
  = ‚ü¶Œµ‚üß(g)
</code></pre>
<p>‚àé</p>
<hr />
<h2 id="7-executable-lambda-calculus"><a class="header" href="#7-executable-lambda-calculus">7. Executable Lambda Calculus</a></h2>
<h3 id="71-implementation-in-Œª-calculus"><a class="header" href="#71-implementation-in-Œª-calculus">7.1 Implementation in Œª-Calculus</a></h3>
<p><strong>ASK Predicate (Church Encoding)</strong>:</p>
<pre><code>œÄ‚Çê‚Çõ‚Çñ = ŒªQ. Œªexp. Œªb.
  let result = ask(Q)(graph) in
  if-then-else
    (is-none exp)
    result
    (eq result (unwrap exp))
</code></pre>
<p><strong>SHACL Predicate</strong>:</p>
<pre><code>œÄ‚Çõ‚Çï‚Çê·¥Ñ‚Çó = ŒªS. Œªmode. Œªstrict. Œªb.
  let report = validate(graph)(S) in
  let viols = filter(Œªv. severity(v) ‚â• threshold)(report) in
  if-then-else
    (eq mode CONFORMS)
    (eq (length viols) 0)
    (and (gt (length viols) 0) (implies strict fail-fast))
</code></pre>
<p><strong>DELTA Predicate</strong>:</p>
<pre><code>œÄ·¥Ö‚Çë‚Çó‚Çú‚Çê = ŒªB. ŒªB_prev. ŒªK. Œªchange. ŒªŒ¥. Œªb.
  let key = project(b)(K) in
  let h_curr = hash(canonical(b)) in
  let h_prev = lookup(B_prev)(key) in
  match h_prev with
    | None   ‚Üí false
    | Some h ‚Üí
        let diff = div (abs (sub h_curr h)) h in
        match change with
          | ANY      ‚Üí neq h_curr h
          | INCREASE ‚Üí gt diff Œ¥
          | DECREASE ‚Üí lt diff (neg Œ¥)
</code></pre>
<h3 id="72-y-combinator-for-recursive-predicates"><a class="header" href="#72-y-combinator-for-recursive-predicates">7.2 Y-Combinator for Recursive Predicates</a></h3>
<p><strong>Definition 7.1</strong> (Fixed-Point Combinator)</p>
<pre><code>Y = Œªf. (Œªx. f (x x)) (Œªx. f (x x))

Recursive predicate:
  œÄ·µ£‚Çëc = Y (Œªf. Œªb. ... f ... )
</code></pre>
<p><strong>Example: Recursive SHACL Validation</strong>:</p>
<pre><code>validate_recursive = Y (Œªvalidate. Œªshape. Œªnode.
  if-then-else
    (has-children shape)
    (and
      (validate shape node)
      (all (Œªchild. validate child node) (children shape)))
    (validate shape node))
</code></pre>
<hr />
<h2 id="8-type-safety"><a class="header" href="#8-type-safety">8. Type Safety</a></h2>
<h3 id="81-type-preservation"><a class="header" href="#81-type-preservation">8.1 Type Preservation</a></h3>
<p><strong>Theorem 8.1</strong> (Type Preservation)</p>
<pre><code>If ‚ä¢ œÄ : Œ† and ‚ä¢ b : Bindings, then ‚ä¢ œÄ(b) : Bool
</code></pre>
<p><strong>Proof</strong>: By structural induction on œÄ</p>
<ul>
<li>Base case: œÄ = œÄ‚Çê‚Çõ‚Çñ(Q, exp) has type Œ† by Definition 3.1</li>
<li>Inductive case: If œÄ‚ÇÅ, œÄ‚ÇÇ : Œ†, then (œÄ‚ÇÅ ‚àß œÄ‚ÇÇ) : Œ† by Definition 1.5
‚àé</li>
</ul>
<p><strong>Theorem 8.2</strong> (Progress)</p>
<pre><code>If ‚ä¢ œÄ : Œ† and ‚ä¢ b : Bindings, then ‚àÉv : Bool. œÄ(b) ‚áì v
</code></pre>
<p><strong>Proof</strong>: By strong normalization of simply-typed Œª-calculus ‚àé</p>
<hr />
<h2 id="9-summary"><a class="header" href="#9-summary">9. Summary</a></h2>
<p>This chapter formalized Knowledge Hooks as:</p>
<ol>
<li><strong>Predicate Algebra</strong>: Monoid structure with compositional semantics</li>
<li><strong>Type System</strong>: 6 predicate types with Œª-calculus definitions</li>
<li><strong>Complexity Bounds</strong>: Formal analysis with optimization strategies</li>
<li><strong>Cryptographic Provenance</strong>: Non-repudiation via digital signatures</li>
<li><strong>Algebraic Laws</strong>: Distributivity, De Morgan, effect composition</li>
</ol>
<p><strong>Key Results</strong>:</p>
<ul>
<li>Predicates form a Boolean algebra (Theorems 6.1-6.2)</li>
<li>Type preservation and progress (Theorems 8.1-8.2)</li>
<li>Non-repudiation via Ed25519 signatures (Theorem 5.1)</li>
<li>Complexity bounds: O(|G|) to O(|B| log |B|) (Theorems 4.1-4.6)</li>
</ul>
<p><strong>Next Chapter</strong>: Chapter 5 formalizes the Dark Matter Engine with operational semantics and proof of correctness.</p>
<hr />
<h2 id="references"><a class="header" href="#references">References</a></h2>
<ol>
<li>Pierce, B. C. (2002). <em>Types and Programming Languages</em>. MIT Press.</li>
<li>Baader, F., et al. (2003). <em>The Description Logic Handbook</em>. Cambridge.</li>
<li>Knublauch, H., &amp; Kontokostas, D. (2017). <em>Shapes Constraint Language (SHACL)</em>. W3C Recommendation.</li>
<li>Harris, S., &amp; Seaborne, A. (2013). <em>SPARQL 1.1 Query Language</em>. W3C Recommendation.</li>
<li>Boneh, D., &amp; Shoup, V. (2020). <em>A Graduate Course in Applied Cryptography</em>. Cambridge.</li>
</ol>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../chapter-hyperdimensional/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../chapter-05/index.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../chapter-hyperdimensional/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../chapter-05/index.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
