<!DOCTYPE HTML>
<html lang="en" class="navy" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>UNRDF - Universal RDF Framework</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="Production-ready RDF knowledge graph library with Knowledge Hooks and autonomic capabilities">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "navy";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('navy')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html"><strong aria-hidden="true">1.</strong> Introduction</a></li><li class="chapter-item expanded "><a href="getting-started/quick-start.html"><strong aria-hidden="true">2.</strong> Getting Started</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="getting-started/quick-start.html"><strong aria-hidden="true">2.1.</strong> Quick Start</a></li><li class="chapter-item "><a href="getting-started/installation.html"><strong aria-hidden="true">2.2.</strong> Installation</a></li><li class="chapter-item "><a href="getting-started/basic-usage.html"><strong aria-hidden="true">2.3.</strong> Basic Usage</a></li><li class="chapter-item "><a href="getting-started/first-hook.html"><strong aria-hidden="true">2.4.</strong> Your First Hook</a></li></ol></li><li class="chapter-item expanded "><a href="concepts/rdf-fundamentals.html"><strong aria-hidden="true">3.</strong> Concepts</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="concepts/rdf-fundamentals.html"><strong aria-hidden="true">3.1.</strong> RDF Fundamentals</a></li><li class="chapter-item "><a href="concepts/composables.html"><strong aria-hidden="true">3.2.</strong> Composables</a></li><li class="chapter-item "><a href="concepts/store-context.html"><strong aria-hidden="true">3.3.</strong> Store & Context</a></li><li class="chapter-item "><a href="concepts/transactions.html"><strong aria-hidden="true">3.4.</strong> Transactions</a></li></ol></li><li class="chapter-item expanded "><a href="hooks/introduction.html"><strong aria-hidden="true">4.</strong> Hooks</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hooks/introduction.html"><strong aria-hidden="true">4.1.</strong> Introduction</a></li><li class="chapter-item "><a href="hooks/lifecycle.html"><strong aria-hidden="true">4.2.</strong> Lifecycle</a></li><li class="chapter-item "><a href="hooks/effects.html"><strong aria-hidden="true">4.3.</strong> Effects</a></li><li class="chapter-item "><a href="hooks/predicates.html"><strong aria-hidden="true">4.4.</strong> Predicates</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="hooks/predicates/ask.html"><strong aria-hidden="true">4.4.1.</strong> ASK</a></li><li class="chapter-item "><a href="hooks/predicates/shacl.html"><strong aria-hidden="true">4.4.2.</strong> SHACL</a></li><li class="chapter-item "><a href="hooks/predicates/delta.html"><strong aria-hidden="true">4.4.3.</strong> Delta</a></li><li class="chapter-item "><a href="hooks/predicates/threshold.html"><strong aria-hidden="true">4.4.4.</strong> Threshold</a></li><li class="chapter-item "><a href="hooks/predicates/custom.html"><strong aria-hidden="true">4.4.5.</strong> Custom</a></li></ol></li></ol></li><li class="chapter-item expanded "><a href="api/core.html"><strong aria-hidden="true">5.</strong> API Reference</a><a class="toggle"><div>‚ù±</div></a></li><li><ol class="section"><li class="chapter-item "><a href="api/cli.html"><strong aria-hidden="true">5.1.</strong> CLI</a></li><li class="chapter-item "><a href="api/core.html"><strong aria-hidden="true">5.2.</strong> Core</a></li><li class="chapter-item "><a href="api/knowledge-engine.html"><strong aria-hidden="true">5.3.</strong> Knowledge Engine</a></li><li class="chapter-item "><a href="api/composables.html"><strong aria-hidden="true">5.4.</strong> Composables</a></li><li class="chapter-item "><a href="api/utilities.html"><strong aria-hidden="true">5.5.</strong> Utilities</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">UNRDF - Universal RDF Framework</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>
                        <a href="https://github.com/seanchatmangpt/unrdf" title="Git repository" aria-label="Git repository">
                            <i id="git-repository-button" class="fa fa-github"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to <strong>UNRDF</strong> - the production-ready RDF knowledge graph library that transforms static data into intelligent, reactive systems.</p>
<h2 id="what-is-unrdf"><a class="header" href="#what-is-unrdf">What is UNRDF?</a></h2>
<p>UNRDF is a composable RDF knowledge graph library built on battle-tested foundations (<a href="https://github.com/rdfjs/N3.js">N3.js</a>, <a href="https://github.com/comunica/comunica">Comunica</a>, <a href="https://github.com/zazuko/rdf-validate-shacl">SHACL</a>) that adds three revolutionary capabilities:</p>
<ol>
<li><strong>Knowledge Hooks</strong> - Policy-driven autonomic behavior that reacts to graph changes</li>
<li><strong>Cryptographic Provenance</strong> - Immutable audit trails with SHA3-256 Merkle verification</li>
<li><strong>Dark Matter 80/20 Optimization</strong> - Performance-optimized critical path delivering 85% value from 20% of code</li>
</ol>
<h2 id="why-use-unrdf"><a class="header" href="#why-use-unrdf">Why Use UNRDF?</a></h2>
<h3 id="production-ready-from-day-one"><a class="header" href="#production-ready-from-day-one">Production-Ready from Day One</a></h3>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';

const system = await createDarkMatterCore();
// You now have:
// ‚úÖ Full SPARQL 1.1 support
// ‚úÖ SHACL validation
// ‚úÖ OpenTelemetry observability
// ‚úÖ Cryptographic audit trails
// ‚úÖ Performance optimizations
</code></pre>
<h3 id="autonomic-knowledge-graphs"><a class="header" href="#autonomic-knowledge-graphs">Autonomic Knowledge Graphs</a></h3>
<p>Traditional RDF libraries are passive - they store and query data. UNRDF is <strong>reactive</strong> - it enforces policies, maintains invariants, and adapts to changes automatically.</p>
<pre><code class="language-javascript">import { defineHook, registerHook } from 'unrdf';

// Define a policy: all persons must have names
const hook = defineHook({
  meta: {
    name: 'data-quality-gate',
    description: 'Ensures all persons have names'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a &lt;http://xmlns.com/foaf/0.1/Person&gt; .
        FILTER NOT EXISTS { ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have names');
    }
  }
});

await registerHook(hook);
// Now this policy is enforced on every transaction
</code></pre>
<h3 id="cryptographic-provenance"><a class="header" href="#cryptographic-provenance">Cryptographic Provenance</a></h3>
<p>Every change is recorded in an immutable, cryptographically verifiable audit trail using Git-based lockchains with Merkle tree verification.</p>
<pre><code class="language-javascript">import { LockchainWriter } from 'unrdf';

const lockchain = new LockchainWriter({
  repoPath: './audit-trail',
  enableMerkle: true
});

await lockchain.init();

// Every transaction creates a cryptographically signed receipt
const receipt = await lockchain.writeReceipt({
  actor: 'alice@example.org',
  action: 'add-user',
  delta: { additions: [/* quads */], removals: [] },
  timestamp: new Date(),
  metadata: { reason: 'User registration' }
});

// Receipt includes SHA3-256 Merkle root for tamper detection
console.log(receipt.merkleRoot); // "abc123..."
</code></pre>
<h2 id="key-features"><a class="header" href="#key-features">Key Features</a></h2>
<h3 id="1-complete-rdf-operations-"><a class="header" href="#1-complete-rdf-operations-">1. <strong>Complete RDF Operations</strong> üìö</a></h3>
<ul>
<li><strong>Parsing</strong>: Turtle, N-Triples, N-Quads, JSON-LD</li>
<li><strong>Serialization</strong>: Convert between any RDF format</li>
<li><strong>SPARQL</strong>: Full SPARQL 1.1 query support (SELECT, ASK, CONSTRUCT, DESCRIBE)</li>
<li><strong>SHACL</strong>: Shape-based validation</li>
<li><strong>N3 Reasoning</strong>: Rule-based inference</li>
</ul>
<h3 id="2-knowledge-hooks-system-"><a class="header" href="#2-knowledge-hooks-system-">2. <strong>Knowledge Hooks System</strong> ü™ù</a></h3>
<p>Autonomic, policy-driven triggers that react to graph changes:</p>
<ul>
<li><code>sparql-ask</code> - Boolean condition checking</li>
<li><code>shacl</code> - Shape validation</li>
<li><code>delta</code> - Change pattern detection</li>
<li><code>threshold</code> - Numeric comparisons</li>
<li><code>count</code> - Cardinality constraints</li>
<li><code>window</code> - Time-based aggregations</li>
</ul>
<h3 id="3-acid-transactions-"><a class="header" href="#3-acid-transactions-">3. <strong>ACID Transactions</strong> üîí</a></h3>
<p>Full ACID guarantees with rollback support:</p>
<pre><code class="language-javascript">try {
  await system.executeTransaction({
    additions: [quad(s, p, o)],
    removals: [],
    actor: 'user@example.org'
  });
} catch (error) {
  // Transaction automatically rolled back
  console.error('Transaction failed:', error);
}
</code></pre>
<h3 id="4-opentelemetry-observability-"><a class="header" href="#4-opentelemetry-observability-">4. <strong>OpenTelemetry Observability</strong> üìä</a></h3>
<p>Production-grade instrumentation out of the box:</p>
<ul>
<li>Distributed tracing with spans</li>
<li>Performance metrics (latency, throughput, cache hit rate)</li>
<li>Error tracking and analysis</li>
<li>Custom instrumentation support</li>
</ul>
<h3 id="5-performance-optimizations-"><a class="header" href="#5-performance-optimizations-">5. <strong>Performance Optimizations</strong> ‚ö°</a></h3>
<p>Dark Matter 80/20 framework delivers:</p>
<ul>
<li><strong>50% faster</strong> hook execution via batching</li>
<li><strong>60% faster</strong> queries via LRU caching</li>
<li><strong>20% faster</strong> transactions via optimized paths</li>
<li>&lt;100ms p95 latency for core operations</li>
</ul>
<h3 id="6-security-by-default-"><a class="header" href="#6-security-by-default-">6. <strong>Security by Default</strong> üõ°Ô∏è</a></h3>
<ul>
<li>Effect sandboxing for hook execution</li>
<li>SHA3-256 Merkle tree verification</li>
<li>Git-based immutable audit logs</li>
<li>Input validation with Zod schemas</li>
<li>Safe SPARQL with timeout and complexity limits</li>
</ul>
<h2 id="what-makes-unrdf-different"><a class="header" href="#what-makes-unrdf-different">What Makes UNRDF Different?</a></h2>
<h3 id="vs-traditional-rdf-libraries"><a class="header" href="#vs-traditional-rdf-libraries">vs. Traditional RDF Libraries</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Traditional RDF</th><th>UNRDF</th></tr></thead><tbody>
<tr><td>Data Storage</td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td>SPARQL Queries</td><td>‚úÖ</td><td>‚úÖ</td></tr>
<tr><td>SHACL Validation</td><td>Sometimes</td><td>‚úÖ</td></tr>
<tr><td><strong>Autonomic Behavior</strong></td><td>‚ùå</td><td>‚úÖ Knowledge Hooks</td></tr>
<tr><td><strong>Cryptographic Audit</strong></td><td>‚ùå</td><td>‚úÖ Lockchain + Merkle</td></tr>
<tr><td><strong>Performance Optimization</strong></td><td>Basic</td><td>‚úÖ Dark Matter 80/20</td></tr>
<tr><td><strong>Observability</strong></td><td>Manual</td><td>‚úÖ Built-in OTEL</td></tr>
<tr><td><strong>Production Ready</strong></td><td>DIY</td><td>‚úÖ Batteries Included</td></tr>
</tbody></table>
</div>
<h3 id="real-world-example"><a class="header" href="#real-world-example">Real-World Example</a></h3>
<p><strong>Traditional approach</strong> (100+ lines of code):</p>
<pre><code class="language-javascript">// Manually validate data
// Manually log changes
// Manually check business rules
// Manually handle errors
// Manually optimize queries
// Manually instrument metrics
</code></pre>
<p><strong>UNRDF approach</strong> (5 lines of code):</p>
<pre><code class="language-javascript">const system = await createDarkMatterCore();
await registerHook(dataQualityHook);
await system.executeTransaction({ additions, removals, actor });
const results = await system.query({ query, type: 'sparql-select' });
await system.cleanup();
</code></pre>
<h2 id="use-cases"><a class="header" href="#use-cases">Use Cases</a></h2>
<h3 id="knowledge-graph-applications"><a class="header" href="#knowledge-graph-applications">Knowledge Graph Applications</a></h3>
<ul>
<li><strong>Semantic data platforms</strong> - Store and query linked data</li>
<li><strong>Data integration</strong> - Merge data from multiple sources</li>
<li><strong>Ontology management</strong> - Version and govern vocabularies</li>
<li><strong>Triple stores</strong> - Scalable RDF storage and retrieval</li>
</ul>
<h3 id="policy-driven-systems"><a class="header" href="#policy-driven-systems">Policy-Driven Systems</a></h3>
<ul>
<li><strong>Compliance enforcement</strong> - Ensure regulatory requirements</li>
<li><strong>Data quality gates</strong> - Maintain data integrity invariants</li>
<li><strong>Business rule automation</strong> - Encode domain logic as hooks</li>
<li><strong>Audit and provenance</strong> - Track all changes cryptographically</li>
</ul>
<h3 id="ai-and-machine-learning"><a class="header" href="#ai-and-machine-learning">AI and Machine Learning</a></h3>
<ul>
<li><strong>Knowledge bases</strong> - Structured knowledge for AI systems</li>
<li><strong>Feature engineering</strong> - Extract features from knowledge graphs</li>
<li><strong>Explainable AI</strong> - Provide semantic context for decisions</li>
<li><strong>Data lineage</strong> - Track provenance for ML pipelines</li>
</ul>
<h2 id="architecture-overview"><a class="header" href="#architecture-overview">Architecture Overview</a></h2>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Dark Matter 80/20 Core         ‚îÇ
‚îÇ  (Performance-Optimized Critical)   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
               ‚îÇ
    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
    ‚îÇ                     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê    ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Knowledge  ‚îÇ    ‚îÇ  Transaction   ‚îÇ
‚îÇ   Hooks    ‚îÇ‚óÑ‚îÄ‚îÄ‚îÄ‚î§    Manager     ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò    ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚ñº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ      Knowledge Engine Core        ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ ‚Ä¢ SPARQL (Comunica)               ‚îÇ
‚îÇ ‚Ä¢ SHACL (rdf-validate-shacl)      ‚îÇ
‚îÇ ‚Ä¢ N3 Reasoning                    ‚îÇ
‚îÇ ‚Ä¢ RDF Store (N3.js)               ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="performance-benchmarks"><a class="header" href="#performance-benchmarks">Performance Benchmarks</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Operation</th><th>Baseline</th><th>Optimized</th><th>Improvement</th></tr></thead><tbody>
<tr><td>Hook execution (independent)</td><td>200ms</td><td>100ms</td><td><strong>50% faster</strong></td></tr>
<tr><td>Query optimization</td><td>500ms</td><td>200ms</td><td><strong>60% faster</strong></td></tr>
<tr><td>Transaction commit</td><td>150ms</td><td>120ms</td><td><strong>20% faster</strong></td></tr>
</tbody></table>
</div>
<p><strong>Production Metrics:</strong></p>
<ul>
<li>‚úÖ &lt;100ms p95 hook execution latency</li>
<li>‚úÖ &lt;500ms p95 query execution latency</li>
<li>‚úÖ &lt;500ms p95 transaction commit latency</li>
<li>‚úÖ 50%+ cache hit rate after warmup</li>
</ul>
<h2 id="getting-started"><a class="header" href="#getting-started">Getting Started</a></h2>
<p>Ready to build your first knowledge graph? Head to the <a href="getting-started/quick-start.html">Quick Start</a> guide to create your first UNRDF application in under 5 minutes.</p>
<h3 id="whats-next"><a class="header" href="#whats-next">What's Next?</a></h3>
<ul>
<li><strong><a href="getting-started/quick-start.html">Quick Start</a></strong> - Build your first app in 5 minutes</li>
<li><strong><a href="getting-started/installation.html">Installation</a></strong> - Detailed setup instructions</li>
<li><strong><a href="getting-started/basic-usage.html">Basic Usage</a></strong> - Learn core concepts</li>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Create your first Knowledge Hook</li>
</ul>
<h2 id="philosophy"><a class="header" href="#philosophy">Philosophy</a></h2>
<p>UNRDF is built on three core principles:</p>
<ol>
<li><strong>Composability</strong> - Use only what you need, when you need it</li>
<li><strong>Correctness</strong> - Runtime validation with Zod, not TypeScript illusions</li>
<li><strong>Production-First</strong> - Batteries included: observability, security, performance</li>
</ol>
<blockquote>
<p>"Good code is written for humans to read, and only incidentally for machines to execute."</p>
<p>‚Äî Harold Abelson</p>
</blockquote>
<p>UNRDF is designed to be <strong>readable</strong>, <strong>maintainable</strong>, and <strong>correct</strong> - in that order.</p>
<h2 id="license"><a class="header" href="#license">License</a></h2>
<p>MIT License - see <a href="https://github.com/unrdf/unrdf/blob/main/LICENSE">LICENSE</a> for details.</p>
<hr />
<p><strong>Let's build intelligent knowledge graphs together.</strong></p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start"><a class="header" href="#quick-start">Quick Start</a></h1>
<p>Get up and running with UNRDF in under 5 minutes. This tutorial will walk you through creating a simple knowledge graph, adding data, and querying it.</p>
<h2 id="installation"><a class="header" href="#installation">Installation</a></h2>
<p>First, install UNRDF using your preferred package manager:</p>
<pre><code class="language-bash">pnpm add unrdf
</code></pre>
<pre><code class="language-admonish info">UNRDF requires **Node.js ‚â• 18.0.0**. Check your version with `node --version`.
</code></pre>
<h2 id="your-first-knowledge-graph"><a class="header" href="#your-first-knowledge-graph">Your First Knowledge Graph</a></h2>
<p>Create a new file <code>example.mjs</code> and add the following code:</p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';

// 1. Create the knowledge engine
const system = await createDarkMatterCore();

// 2. Add some RDF data
await system.executeTransaction({
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Alice')
    ),
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/knows'),
      namedNode('http://example.org/bob')
    )
  ],
  removals: [],
  actor: 'system'
});

// 3. Query the data
const results = await system.query({
  query: 'SELECT ?name WHERE { ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name }',
  type: 'sparql-select'
});

console.log(results);
// Output: [{ name: 'Alice' }]

// 4. Cleanup
await system.cleanup();
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">node example.mjs
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code class="language-javascript">[{ name: 'Alice' }]
</code></pre>
<pre><code class="language-admonish success title=&quot;Congratulations!&quot;">You've just created your first UNRDF knowledge graph! In just 4 steps, you:
1. ‚úÖ Created a Dark Matter core instance
2. ‚úÖ Added RDF triples via a transaction
3. ‚úÖ Queried data with SPARQL
4. ‚úÖ Cleaned up resources
</code></pre>
<h2 id="what-just-happened"><a class="header" href="#what-just-happened">What Just Happened?</a></h2>
<p>Let's break down each step:</p>
<h3 id="step-1-create-the-knowledge-engine"><a class="header" href="#step-1-create-the-knowledge-engine">Step 1: Create the Knowledge Engine</a></h3>
<pre><code class="language-javascript">const system = await createDarkMatterCore();
</code></pre>
<p>This creates a complete knowledge graph system with:</p>
<ul>
<li><strong>RDF Store</strong> - In-memory quad storage using N3.js</li>
<li><strong>Transaction Manager</strong> - ACID guarantees with rollback support</li>
<li><strong>Query Engine</strong> - Full SPARQL 1.1 support via Comunica</li>
<li><strong>Hook Manager</strong> - Policy enforcement system</li>
<li><strong>Observability</strong> - OpenTelemetry instrumentation</li>
<li><strong>Performance Optimizations</strong> - Query caching, hook batching, parallel execution</li>
</ul>
<p>All of this is initialized with sensible defaults and ready to use.</p>
<h3 id="step-2-add-rdf-data"><a class="header" href="#step-2-add-rdf-data">Step 2: Add RDF Data</a></h3>
<pre><code class="language-javascript">await system.executeTransaction({
  additions: [
    quad(subject, predicate, object),
    // ... more quads
  ],
  removals: [],
  actor: 'system'
});
</code></pre>
<p>Transactions in UNRDF are <strong>ACID-compliant</strong>:</p>
<ul>
<li><strong>Atomic</strong> - All additions/removals succeed or fail together</li>
<li><strong>Consistent</strong> - Knowledge Hooks enforce invariants</li>
<li><strong>Isolated</strong> - Concurrent transactions don't interfere</li>
<li><strong>Durable</strong> - Changes are persisted (if lockchain is enabled)</li>
</ul>
<p>The <code>actor</code> parameter records who made the change - essential for audit trails.</p>
<pre><code class="language-admonish tip">Use descriptive actor names like `'user@example.org'` or `'import-job-123'` to make audit trails meaningful.
</code></pre>
<h3 id="step-3-query-the-data"><a class="header" href="#step-3-query-the-data">Step 3: Query the Data</a></h3>
<pre><code class="language-javascript">const results = await system.query({
  query: 'SELECT ?name WHERE { ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name }',
  type: 'sparql-select'
});
</code></pre>
<p>UNRDF supports all SPARQL 1.1 query types:</p>
<ul>
<li><code>sparql-select</code> - Returns bindings (array of objects)</li>
<li><code>sparql-ask</code> - Returns boolean</li>
<li><code>sparql-construct</code> - Returns RDF graph</li>
<li><code>sparql-describe</code> - Returns RDF description</li>
</ul>
<p>Query results are automatically optimized through:</p>
<ul>
<li><strong>LRU Query Cache</strong> - Frequently-used queries are cached</li>
<li><strong>Parallel Execution</strong> - Independent subqueries run in parallel</li>
<li><strong>Smart Indexing</strong> - Optimized quad store indexes</li>
</ul>
<h3 id="step-4-cleanup"><a class="header" href="#step-4-cleanup">Step 4: Cleanup</a></h3>
<pre><code class="language-javascript">await system.cleanup();
</code></pre>
<p>Always cleanup your system to:</p>
<ul>
<li>Close database connections</li>
<li>Clear caches and free memory</li>
<li>Flush pending metrics</li>
<li>Stop background workers</li>
</ul>
<pre><code class="language-admonish warning">Failing to cleanup can lead to memory leaks and resource exhaustion in long-running applications.
</code></pre>
<h2 id="next-steps"><a class="header" href="#next-steps">Next Steps</a></h2>
<p>Now that you've created your first knowledge graph, explore these topics:</p>
<h3 id="learn-core-concepts"><a class="header" href="#learn-core-concepts">Learn Core Concepts</a></h3>
<ul>
<li><strong><a href="getting-started/installation.html">Installation</a></strong> - Detailed setup and configuration</li>
<li><strong><a href="getting-started/basic-usage.html">Basic Usage</a></strong> - RDF operations, SPARQL queries, SHACL validation</li>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Create your first Knowledge Hook</li>
</ul>
<h3 id="explore-features"><a class="header" href="#explore-features">Explore Features</a></h3>
<p><strong>RDF Operations:</strong></p>
<pre><code class="language-javascript">import { parseTurtle, toTurtle } from 'unrdf';

const store = await parseTurtle(`
  @prefix ex: &lt;http://example.org/&gt; .
  ex:alice ex:name "Alice" .
`);

const turtle = await toTurtle(store);
</code></pre>
<p><strong>SPARQL Queries:</strong></p>
<pre><code class="language-javascript">// ASK query
const exists = await system.query({
  query: 'ASK { ?s ?p ?o }',
  type: 'sparql-ask'
});

// CONSTRUCT query
const graph = await system.query({
  query: 'CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o }',
  type: 'sparql-construct'
});
</code></pre>
<p><strong>Knowledge Hooks:</strong></p>
<pre><code class="language-javascript">import { defineHook, registerHook } from 'unrdf';

const hook = defineHook({
  meta: { name: 'validation', description: 'Ensure data quality' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person a foaf:Person . FILTER NOT EXISTS { ?person foaf:name ?name } }'
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have names');
    }
  }
});

await registerHook(hook);
</code></pre>
<p><strong>Cryptographic Audit Trails:</strong></p>
<pre><code class="language-javascript">import { LockchainWriter } from 'unrdf';

const lockchain = new LockchainWriter({
  repoPath: './audit-trail',
  enableMerkle: true
});

await lockchain.init();

const receipt = await lockchain.writeReceipt({
  actor: 'alice@example.org',
  action: 'add-data',
  delta: { additions, removals },
  timestamp: new Date()
});
</code></pre>
<h2 id="common-patterns"><a class="header" href="#common-patterns">Common Patterns</a></h2>
<h3 id="working-with-turtle-files"><a class="header" href="#working-with-turtle-files">Working with Turtle Files</a></h3>
<pre><code class="language-javascript">import { parseTurtle } from 'unrdf';
import { readFileSync } from 'node:fs';

// Load Turtle from file
const ttl = readFileSync('./data.ttl', 'utf8');
const store = await parseTurtle(ttl);

// Add to knowledge graph
await system.executeTransaction({
  additions: [...store],
  removals: [],
  actor: 'file-import'
});
</code></pre>
<h3 id="complex-sparql-queries"><a class="header" href="#complex-sparql-queries">Complex SPARQL Queries</a></h3>
<pre><code class="language-javascript">const results = await system.query({
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    PREFIX ex: &lt;http://example.org/&gt;

    SELECT ?person ?name ?friend ?friendName
    WHERE {
      ?person a foaf:Person ;
              foaf:name ?name ;
              foaf:knows ?friend .
      ?friend foaf:name ?friendName .
    }
    ORDER BY ?name
  `,
  type: 'sparql-select'
});
</code></pre>
<h3 id="error-handling"><a class="header" href="#error-handling">Error Handling</a></h3>
<pre><code class="language-javascript">try {
  await system.executeTransaction({
    additions: [quad(s, p, o)],
    removals: [],
    actor: 'user'
  });
} catch (error) {
  console.error('Transaction failed:', error.message);
  // Transaction automatically rolled back
  // Original store state preserved
}
</code></pre>
<h2 id="troubleshooting"><a class="header" href="#troubleshooting">Troubleshooting</a></h2>
<h3 id="module-not-found-error"><a class="header" href="#module-not-found-error">"Module not found" Error</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error [ERR_MODULE_NOT_FOUND]: Cannot find package 'unrdf'
</code></pre>
<p><strong>Solution:</strong> Install UNRDF with <code>pnpm add unrdf</code> and ensure you're using Node.js ‚â• 18.0.0.</p>
<h3 id="query-timeout"><a class="header" href="#query-timeout">Query Timeout</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error: Query execution timeout after 30000ms
</code></pre>
<p><strong>Solution:</strong> Optimize your SPARQL query or increase the timeout:</p>
<pre><code class="language-javascript">const system = await createDarkMatterCore({
  timeoutMs: 60000 // 60 seconds
});
</code></pre>
<h3 id="memory-issues"><a class="header" href="#memory-issues">Memory Issues</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
</code></pre>
<p><strong>Solution:</strong> For large graphs, configure Node.js with more memory:</p>
<pre><code class="language-bash">NODE_OPTIONS="--max-old-space-size=4096" node example.mjs
</code></pre>
<h2 id="whats-next-1"><a class="header" href="#whats-next-1">What's Next?</a></h2>
<p>Continue your UNRDF journey:</p>
<ol>
<li><strong><a href="getting-started/installation.html">Installation</a></strong> - Learn about production setup and configuration</li>
<li><strong><a href="getting-started/basic-usage.html">Basic Usage</a></strong> - Master RDF operations and SPARQL queries</li>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Build your first autonomic Knowledge Hook</li>
</ol>
<pre><code class="language-admonish tip">Join our [GitHub Discussions](https://github.com/unrdf/unrdf/discussions) to ask questions and share your projects!
</code></pre>
<hr />
<p><strong>Ready to dive deeper?</strong> Head to <a href="getting-started/installation.html">Installation</a> for detailed setup instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="quick-start-1"><a class="header" href="#quick-start-1">Quick Start</a></h1>
<p>Get up and running with UNRDF in under 5 minutes. This tutorial will walk you through creating a simple knowledge graph, adding data, and querying it.</p>
<h2 id="installation-1"><a class="header" href="#installation-1">Installation</a></h2>
<p>First, install UNRDF using your preferred package manager:</p>
<pre><code class="language-bash">pnpm add unrdf
</code></pre>
<pre><code class="language-admonish info">UNRDF requires **Node.js ‚â• 18.0.0**. Check your version with `node --version`.
</code></pre>
<h2 id="your-first-knowledge-graph-1"><a class="header" href="#your-first-knowledge-graph-1">Your First Knowledge Graph</a></h2>
<p>Create a new file <code>example.mjs</code> and add the following code:</p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';

// 1. Create the knowledge engine
const system = await createDarkMatterCore();

// 2. Add some RDF data
await system.executeTransaction({
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Alice')
    ),
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/knows'),
      namedNode('http://example.org/bob')
    )
  ],
  removals: [],
  actor: 'system'
});

// 3. Query the data
const results = await system.query({
  query: 'SELECT ?name WHERE { ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name }',
  type: 'sparql-select'
});

console.log(results);
// Output: [{ name: 'Alice' }]

// 4. Cleanup
await system.cleanup();
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">node example.mjs
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code class="language-javascript">[{ name: 'Alice' }]
</code></pre>
<pre><code class="language-admonish success title=&quot;Congratulations!&quot;">You've just created your first UNRDF knowledge graph! In just 4 steps, you:
1. ‚úÖ Created a Dark Matter core instance
2. ‚úÖ Added RDF triples via a transaction
3. ‚úÖ Queried data with SPARQL
4. ‚úÖ Cleaned up resources
</code></pre>
<h2 id="what-just-happened-1"><a class="header" href="#what-just-happened-1">What Just Happened?</a></h2>
<p>Let's break down each step:</p>
<h3 id="step-1-create-the-knowledge-engine-1"><a class="header" href="#step-1-create-the-knowledge-engine-1">Step 1: Create the Knowledge Engine</a></h3>
<pre><code class="language-javascript">const system = await createDarkMatterCore();
</code></pre>
<p>This creates a complete knowledge graph system with:</p>
<ul>
<li><strong>RDF Store</strong> - In-memory quad storage using N3.js</li>
<li><strong>Transaction Manager</strong> - ACID guarantees with rollback support</li>
<li><strong>Query Engine</strong> - Full SPARQL 1.1 support via Comunica</li>
<li><strong>Hook Manager</strong> - Policy enforcement system</li>
<li><strong>Observability</strong> - OpenTelemetry instrumentation</li>
<li><strong>Performance Optimizations</strong> - Query caching, hook batching, parallel execution</li>
</ul>
<p>All of this is initialized with sensible defaults and ready to use.</p>
<h3 id="step-2-add-rdf-data-1"><a class="header" href="#step-2-add-rdf-data-1">Step 2: Add RDF Data</a></h3>
<pre><code class="language-javascript">await system.executeTransaction({
  additions: [
    quad(subject, predicate, object),
    // ... more quads
  ],
  removals: [],
  actor: 'system'
});
</code></pre>
<p>Transactions in UNRDF are <strong>ACID-compliant</strong>:</p>
<ul>
<li><strong>Atomic</strong> - All additions/removals succeed or fail together</li>
<li><strong>Consistent</strong> - Knowledge Hooks enforce invariants</li>
<li><strong>Isolated</strong> - Concurrent transactions don't interfere</li>
<li><strong>Durable</strong> - Changes are persisted (if lockchain is enabled)</li>
</ul>
<p>The <code>actor</code> parameter records who made the change - essential for audit trails.</p>
<pre><code class="language-admonish tip">Use descriptive actor names like `'user@example.org'` or `'import-job-123'` to make audit trails meaningful.
</code></pre>
<h3 id="step-3-query-the-data-1"><a class="header" href="#step-3-query-the-data-1">Step 3: Query the Data</a></h3>
<pre><code class="language-javascript">const results = await system.query({
  query: 'SELECT ?name WHERE { ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name }',
  type: 'sparql-select'
});
</code></pre>
<p>UNRDF supports all SPARQL 1.1 query types:</p>
<ul>
<li><code>sparql-select</code> - Returns bindings (array of objects)</li>
<li><code>sparql-ask</code> - Returns boolean</li>
<li><code>sparql-construct</code> - Returns RDF graph</li>
<li><code>sparql-describe</code> - Returns RDF description</li>
</ul>
<p>Query results are automatically optimized through:</p>
<ul>
<li><strong>LRU Query Cache</strong> - Frequently-used queries are cached</li>
<li><strong>Parallel Execution</strong> - Independent subqueries run in parallel</li>
<li><strong>Smart Indexing</strong> - Optimized quad store indexes</li>
</ul>
<h3 id="step-4-cleanup-1"><a class="header" href="#step-4-cleanup-1">Step 4: Cleanup</a></h3>
<pre><code class="language-javascript">await system.cleanup();
</code></pre>
<p>Always cleanup your system to:</p>
<ul>
<li>Close database connections</li>
<li>Clear caches and free memory</li>
<li>Flush pending metrics</li>
<li>Stop background workers</li>
</ul>
<pre><code class="language-admonish warning">Failing to cleanup can lead to memory leaks and resource exhaustion in long-running applications.
</code></pre>
<h2 id="next-steps-1"><a class="header" href="#next-steps-1">Next Steps</a></h2>
<p>Now that you've created your first knowledge graph, explore these topics:</p>
<h3 id="learn-core-concepts-1"><a class="header" href="#learn-core-concepts-1">Learn Core Concepts</a></h3>
<ul>
<li><strong><a href="getting-started/installation.html">Installation</a></strong> - Detailed setup and configuration</li>
<li><strong><a href="getting-started/basic-usage.html">Basic Usage</a></strong> - RDF operations, SPARQL queries, SHACL validation</li>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Create your first Knowledge Hook</li>
</ul>
<h3 id="explore-features-1"><a class="header" href="#explore-features-1">Explore Features</a></h3>
<p><strong>RDF Operations:</strong></p>
<pre><code class="language-javascript">import { parseTurtle, toTurtle } from 'unrdf';

const store = await parseTurtle(`
  @prefix ex: &lt;http://example.org/&gt; .
  ex:alice ex:name "Alice" .
`);

const turtle = await toTurtle(store);
</code></pre>
<p><strong>SPARQL Queries:</strong></p>
<pre><code class="language-javascript">// ASK query
const exists = await system.query({
  query: 'ASK { ?s ?p ?o }',
  type: 'sparql-ask'
});

// CONSTRUCT query
const graph = await system.query({
  query: 'CONSTRUCT { ?s ?p ?o } WHERE { ?s ?p ?o }',
  type: 'sparql-construct'
});
</code></pre>
<p><strong>Knowledge Hooks:</strong></p>
<pre><code class="language-javascript">import { defineHook, registerHook } from 'unrdf';

const hook = defineHook({
  meta: { name: 'validation', description: 'Ensure data quality' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person a foaf:Person . FILTER NOT EXISTS { ?person foaf:name ?name } }'
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have names');
    }
  }
});

await registerHook(hook);
</code></pre>
<p><strong>Cryptographic Audit Trails:</strong></p>
<pre><code class="language-javascript">import { LockchainWriter } from 'unrdf';

const lockchain = new LockchainWriter({
  repoPath: './audit-trail',
  enableMerkle: true
});

await lockchain.init();

const receipt = await lockchain.writeReceipt({
  actor: 'alice@example.org',
  action: 'add-data',
  delta: { additions, removals },
  timestamp: new Date()
});
</code></pre>
<h2 id="common-patterns-1"><a class="header" href="#common-patterns-1">Common Patterns</a></h2>
<h3 id="working-with-turtle-files-1"><a class="header" href="#working-with-turtle-files-1">Working with Turtle Files</a></h3>
<pre><code class="language-javascript">import { parseTurtle } from 'unrdf';
import { readFileSync } from 'node:fs';

// Load Turtle from file
const ttl = readFileSync('./data.ttl', 'utf8');
const store = await parseTurtle(ttl);

// Add to knowledge graph
await system.executeTransaction({
  additions: [...store],
  removals: [],
  actor: 'file-import'
});
</code></pre>
<h3 id="complex-sparql-queries-1"><a class="header" href="#complex-sparql-queries-1">Complex SPARQL Queries</a></h3>
<pre><code class="language-javascript">const results = await system.query({
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    PREFIX ex: &lt;http://example.org/&gt;

    SELECT ?person ?name ?friend ?friendName
    WHERE {
      ?person a foaf:Person ;
              foaf:name ?name ;
              foaf:knows ?friend .
      ?friend foaf:name ?friendName .
    }
    ORDER BY ?name
  `,
  type: 'sparql-select'
});
</code></pre>
<h3 id="error-handling-1"><a class="header" href="#error-handling-1">Error Handling</a></h3>
<pre><code class="language-javascript">try {
  await system.executeTransaction({
    additions: [quad(s, p, o)],
    removals: [],
    actor: 'user'
  });
} catch (error) {
  console.error('Transaction failed:', error.message);
  // Transaction automatically rolled back
  // Original store state preserved
}
</code></pre>
<h2 id="troubleshooting-1"><a class="header" href="#troubleshooting-1">Troubleshooting</a></h2>
<h3 id="module-not-found-error-1"><a class="header" href="#module-not-found-error-1">"Module not found" Error</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error [ERR_MODULE_NOT_FOUND]: Cannot find package 'unrdf'
</code></pre>
<p><strong>Solution:</strong> Install UNRDF with <code>pnpm add unrdf</code> and ensure you're using Node.js ‚â• 18.0.0.</p>
<h3 id="query-timeout-1"><a class="header" href="#query-timeout-1">Query Timeout</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error: Query execution timeout after 30000ms
</code></pre>
<p><strong>Solution:</strong> Optimize your SPARQL query or increase the timeout:</p>
<pre><code class="language-javascript">const system = await createDarkMatterCore({
  timeoutMs: 60000 // 60 seconds
});
</code></pre>
<h3 id="memory-issues-1"><a class="header" href="#memory-issues-1">Memory Issues</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">FATAL ERROR: Reached heap limit Allocation failed - JavaScript heap out of memory
</code></pre>
<p><strong>Solution:</strong> For large graphs, configure Node.js with more memory:</p>
<pre><code class="language-bash">NODE_OPTIONS="--max-old-space-size=4096" node example.mjs
</code></pre>
<h2 id="whats-next-2"><a class="header" href="#whats-next-2">What's Next?</a></h2>
<p>Continue your UNRDF journey:</p>
<ol>
<li><strong><a href="getting-started/installation.html">Installation</a></strong> - Learn about production setup and configuration</li>
<li><strong><a href="getting-started/basic-usage.html">Basic Usage</a></strong> - Master RDF operations and SPARQL queries</li>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Build your first autonomic Knowledge Hook</li>
</ol>
<pre><code class="language-admonish tip">Join our [GitHub Discussions](https://github.com/unrdf/unrdf/discussions) to ask questions and share your projects!
</code></pre>
<hr />
<p><strong>Ready to dive deeper?</strong> Head to <a href="getting-started/installation.html">Installation</a> for detailed setup instructions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="installation-2"><a class="header" href="#installation-2">Installation</a></h1>
<p>This guide covers installing UNRDF for both development and production environments.</p>
<h2 id="requirements"><a class="header" href="#requirements">Requirements</a></h2>
<p>Before installing UNRDF, ensure you have:</p>
<ul>
<li><strong>Node.js</strong> ‚â• 18.0.0 (LTS recommended)</li>
<li><strong>pnpm</strong> ‚â• 8.0.0 (recommended) or npm ‚â• 9.0.0</li>
</ul>
<pre><code class="language-admonish info">UNRDF uses ES modules and requires Node.js 18+ for native ESM support and performance features.
</code></pre>
<h3 id="check-your-environment"><a class="header" href="#check-your-environment">Check Your Environment</a></h3>
<pre><code class="language-bash"># Check Node.js version
node --version
# Should print: v18.x.x or higher

# Check pnpm version (if using pnpm)
pnpm --version
# Should print: 8.x.x or higher
</code></pre>
<h2 id="installing-unrdf"><a class="header" href="#installing-unrdf">Installing UNRDF</a></h2>
<h3 id="using-pnpm-recommended"><a class="header" href="#using-pnpm-recommended">Using pnpm (Recommended)</a></h3>
<pre><code class="language-bash">pnpm add unrdf
</code></pre>
<h3 id="using-npm"><a class="header" href="#using-npm">Using npm</a></h3>
<pre><code class="language-bash">npm install unrdf
</code></pre>
<h3 id="using-yarn"><a class="header" href="#using-yarn">Using yarn</a></h3>
<pre><code class="language-bash">yarn add unrdf
</code></pre>
<pre><code class="language-admonish success title=&quot;Why pnpm?&quot;">UNRDF recommends pnpm for:
- **Faster installs** - Shared dependency store
- **Less disk space** - Content-addressed storage
- **Stricter** - Better dependency resolution
</code></pre>
<h2 id="verify-installation"><a class="header" href="#verify-installation">Verify Installation</a></h2>
<p>Create a test file <code>test-install.mjs</code>:</p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';

console.log('‚úÖ UNRDF imported successfully');

const system = await createDarkMatterCore();
console.log('‚úÖ Dark Matter core created');

await system.cleanup();
console.log('‚úÖ Cleanup successful');
console.log('\nüéâ UNRDF is installed and working!');
</code></pre>
<p>Run it:</p>
<pre><code class="language-bash">node test-install.mjs
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code>‚úÖ UNRDF imported successfully
üåå Initializing Dark Matter 80/20 Core...
üîß Initializing transactionManager (25% value weight)...
‚úÖ transactionManager initialized (contributes 25% of system value)
üîß Initializing knowledgeHookManager (20% value weight)...
‚úÖ knowledgeHookManager initialized (contributes 20% of system value)
... [more initialization logs]
‚úÖ Dark Matter 80/20 Core initialized successfully
‚úÖ Dark Matter core created
üßπ Cleaning up Dark Matter 80/20 Core...
‚úÖ Cleanup successful

üéâ UNRDF is installed and working!
</code></pre>
<h2 id="development-vs-production-setup"><a class="header" href="#development-vs-production-setup">Development vs Production Setup</a></h2>
<h3 id="development-setup"><a class="header" href="#development-setup">Development Setup</a></h3>
<p>For local development, install UNRDF with all dev dependencies:</p>
<pre><code class="language-bash"># Clone the repository
git clone https://github.com/unrdf/unrdf.git
cd unrdf

# Install dependencies
pnpm install

# Run tests to verify
pnpm test

# Run OTEL validation
node validation/run-all.mjs comprehensive
</code></pre>
<p>This gives you:</p>
<ul>
<li>Source code for debugging</li>
<li>Test suites for learning</li>
<li>Validation tools</li>
<li>Development scripts</li>
</ul>
<h3 id="production-setup"><a class="header" href="#production-setup">Production Setup</a></h3>
<p>For production applications, install only the runtime package:</p>
<pre><code class="language-bash">pnpm add unrdf --save-prod
</code></pre>
<p><strong>Production configuration example:</strong></p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';

const system = await createDarkMatterCore({
  // Enable all core components
  enableTransactionManager: true,
  enableKnowledgeHookManager: true,
  enableEffectSandbox: true,
  enableObservability: true,
  enablePerformanceOptimizer: true,
  enableLockchainWriter: true,

  // Production performance targets
  performanceTargets: {
    p50PreHookPipeline: 0.2,    // 200¬µs
    p99PreHookPipeline: 2,      // 2ms
    receiptWriteMedian: 5,      // 5ms
    hookEngineExecPerMin: 10000 // 10k/min
  },

  // Optimization flags
  enableFastPath: true,
  enableCaching: true,
  enableBatchProcessing: true,

  // Resource limits
  maxConcurrency: 10,
  cacheSize: 10000,
  batchSize: 1000,
  timeoutMs: 2000
});
</code></pre>
<pre><code class="language-admonish warning">In production, always configure timeouts, cache sizes, and concurrency limits based on your workload and infrastructure.
</code></pre>
<h2 id="optional-dependencies"><a class="header" href="#optional-dependencies">Optional Dependencies</a></h2>
<p>UNRDF has optional features that require additional dependencies:</p>
<h3 id="cryptographic-lockchain"><a class="header" href="#cryptographic-lockchain">Cryptographic Lockchain</a></h3>
<p>For cryptographic audit trails with Merkle verification:</p>
<pre><code class="language-bash">pnpm add isomorphic-git simple-git
</code></pre>
<pre><code class="language-javascript">import { LockchainWriter } from 'unrdf';

const lockchain = new LockchainWriter({
  repoPath: './audit-trail',
  enableMerkle: true
});

await lockchain.init();
</code></pre>
<h3 id="opentelemetry-exporters"><a class="header" href="#opentelemetry-exporters">OpenTelemetry Exporters</a></h3>
<p>For production observability, install OTEL exporters:</p>
<pre><code class="language-bash"># Jaeger exporter
pnpm add @opentelemetry/exporter-jaeger

# Prometheus exporter
pnpm add @opentelemetry/exporter-prometheus

# OTLP exporter
pnpm add @opentelemetry/exporter-trace-otlp-http
</code></pre>
<pre><code class="language-javascript">import { NodeTracerProvider } from '@opentelemetry/sdk-trace-node';
import { JaegerExporter } from '@opentelemetry/exporter-jaeger';

const provider = new NodeTracerProvider();
provider.addSpanProcessor(
  new SimpleSpanProcessor(new JaegerExporter())
);
provider.register();
</code></pre>
<h2 id="platform-specific-notes"><a class="header" href="#platform-specific-notes">Platform-Specific Notes</a></h2>
<h3 id="nodejs-on-macos"><a class="header" href="#nodejs-on-macos">Node.js on macOS</a></h3>
<p>UNRDF works out of the box on macOS with Node.js 18+:</p>
<pre><code class="language-bash"># Install Node.js via Homebrew
brew install node@18

# Or use nvm
nvm install 18
nvm use 18

# Install UNRDF
pnpm add unrdf
</code></pre>
<h3 id="nodejs-on-linux"><a class="header" href="#nodejs-on-linux">Node.js on Linux</a></h3>
<p>For Linux, ensure you have the latest Node.js:</p>
<pre><code class="language-bash"># Ubuntu/Debian
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# Or use nvm
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.0/install.sh | bash
nvm install 18

# Install UNRDF
pnpm add unrdf
</code></pre>
<h3 id="nodejs-on-windows"><a class="header" href="#nodejs-on-windows">Node.js on Windows</a></h3>
<pre><code class="language-bash"># Using nvm-windows
nvm install 18.0.0
nvm use 18.0.0

# Install UNRDF
pnpm add unrdf
</code></pre>
<pre><code class="language-admonish warning title=&quot;Windows Path Issues&quot;">On Windows, if you encounter Git path errors with lockchain, ensure Git is in your PATH:
</code></pre>
<pre><code class="language-powershell"># Add Git to PATH (PowerShell as Admin)
$env:Path += ";C:\Program Files\Git\cmd"
</code></pre>
<h2 id="docker-setup"><a class="header" href="#docker-setup">Docker Setup</a></h2>
<p>For containerized deployments:</p>
<pre><code class="language-dockerfile">FROM node:18-alpine

WORKDIR /app

# Install pnpm
RUN npm install -g pnpm

# Copy package files
COPY package.json pnpm-lock.yaml ./

# Install dependencies
RUN pnpm install --frozen-lockfile

# Copy application code
COPY . .

# Run application
CMD ["node", "index.mjs"]
</code></pre>
<p><strong>Build and run:</strong></p>
<pre><code class="language-bash">docker build -t my-unrdf-app .
docker run -p 3000:3000 my-unrdf-app
</code></pre>
<h2 id="troubleshooting-2"><a class="header" href="#troubleshooting-2">Troubleshooting</a></h2>
<h3 id="module-resolution-errors"><a class="header" href="#module-resolution-errors">Module Resolution Errors</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error [ERR_MODULE_NOT_FOUND]: Cannot find package '@rdfjs/data-model'
</code></pre>
<p><strong>Solution:</strong> Ensure all peer dependencies are installed:</p>
<pre><code class="language-bash">pnpm add @rdfjs/data-model n3 zod
</code></pre>
<h3 id="version-conflicts"><a class="header" href="#version-conflicts">Version Conflicts</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">npm ERR! ERESOLVE unable to resolve dependency tree
</code></pre>
<p><strong>Solution:</strong> Use pnpm or install with legacy peer deps:</p>
<pre><code class="language-bash">npm install unrdf --legacy-peer-deps
</code></pre>
<h3 id="git-not-found-lockchain"><a class="header" href="#git-not-found-lockchain">Git Not Found (Lockchain)</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error: Command failed: git init
</code></pre>
<p><strong>Solution:</strong> Install Git and ensure it's in your PATH:</p>
<pre><code class="language-bash"># macOS
brew install git

# Ubuntu/Debian
sudo apt-get install git

# Windows
# Download from https://git-scm.com/download/win
</code></pre>
<h3 id="permission-errors"><a class="header" href="#permission-errors">Permission Errors</a></h3>
<pre><code class="language-admonish danger title=&quot;Error&quot;">Error: EACCES: permission denied
</code></pre>
<p><strong>Solution:</strong> Don't use sudo with npm/pnpm. Fix permissions:</p>
<pre><code class="language-bash"># macOS/Linux
sudo chown -R $USER:$USER ~/.npm
sudo chown -R $USER:$USER ~/.pnpm-store
</code></pre>
<h2 id="next-steps-2"><a class="header" href="#next-steps-2">Next Steps</a></h2>
<p>Now that UNRDF is installed, continue to:</p>
<ol>
<li><strong><a href="getting-started/basic-usage.html">Basic Usage</a></strong> - Learn core RDF operations</li>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Create your first Knowledge Hook</li>
<li><strong>API Reference</strong> - Explore the complete API</li>
</ol>
<pre><code class="language-admonish tip">For production deployments, see our [Production Deployment Guide](../guides/production-deployment.md) for best practices on scaling, monitoring, and security.
</code></pre>
<h2 id="getting-help"><a class="header" href="#getting-help">Getting Help</a></h2>
<p>If you encounter issues:</p>
<ol>
<li><strong>Check the <a href="getting-started/../troubleshooting/faq.html">FAQ</a></strong> - Common questions and solutions</li>
<li><strong>Search <a href="https://github.com/unrdf/unrdf/issues">GitHub Issues</a></strong> - Known issues and workarounds</li>
<li><strong>Ask on <a href="https://github.com/unrdf/unrdf/discussions">GitHub Discussions</a></strong> - Community support</li>
<li><strong>Report bugs</strong> - <a href="https://github.com/unrdf/unrdf/issues/new">Create an issue</a></li>
</ol>
<hr />
<p><strong>Installation complete!</strong> Head to <a href="getting-started/basic-usage.html">Basic Usage</a> to start building with UNRDF.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="basic-usage"><a class="header" href="#basic-usage">Basic Usage</a></h1>
<p>This guide covers the essential UNRDF operations: creating stores, parsing RDF data, running SPARQL queries, and serializing results.</p>
<h2 id="creating-a-knowledge-store"><a class="header" href="#creating-a-knowledge-store">Creating a Knowledge Store</a></h2>
<p>UNRDF provides two ways to create a knowledge graph system:</p>
<h3 id="option-1-dark-matter-core-recommended"><a class="header" href="#option-1-dark-matter-core-recommended">Option 1: Dark Matter Core (Recommended)</a></h3>
<p>The Dark Matter core provides a complete, optimized system:</p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';

const system = await createDarkMatterCore();

// You now have:
// - RDF quad store (N3.js)
// - Transaction manager (ACID guarantees)
// - SPARQL query engine (Comunica)
// - Knowledge Hook manager
// - OpenTelemetry observability
// - Performance optimizations
</code></pre>
<pre><code class="language-admonish success title=&quot;Why Dark Matter?&quot;">The Dark Matter 80/20 framework delivers 85% of value from 20% of code. It automatically enables:
- Query caching (60% faster queries)
- Hook batching (50% faster execution)
- Parallel processing
- Resource optimization
</code></pre>
<h3 id="option-2-minimal-system"><a class="header" href="#option-2-minimal-system">Option 2: Minimal System</a></h3>
<p>For lightweight use cases, create a minimal system:</p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';

const system = await createDarkMatterCore({
  enableObservability: false,
  enablePerformanceOptimizer: false,
  enableLockchainWriter: false
});

// Minimal system with just:
// - RDF store
// - Transaction manager
// - Knowledge Hooks
</code></pre>
<h2 id="working-with-rdf-data"><a class="header" href="#working-with-rdf-data">Working with RDF Data</a></h2>
<h3 id="parsing-turtle"><a class="header" href="#parsing-turtle">Parsing Turtle</a></h3>
<pre><code class="language-javascript">import { parseTurtle } from 'unrdf';

const ttl = `
  @prefix ex: &lt;http://example.org/&gt; .
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

  ex:alice a foaf:Person ;
           foaf:name "Alice" ;
           foaf:age 30 ;
           foaf:knows ex:bob .

  ex:bob a foaf:Person ;
         foaf:name "Bob" ;
         foaf:age 25 .
`;

const store = await parseTurtle(ttl);

console.log(`Parsed ${store.size} triples`);
// Output: Parsed 6 triples
</code></pre>
<pre><code class="language-admonish info">`parseTurtle()` returns an N3.Store containing RDF quads. It supports Turtle syntax including prefixes, blank nodes, and lists.
</code></pre>
<h3 id="adding-data-via-transactions"><a class="header" href="#adding-data-via-transactions">Adding Data via Transactions</a></h3>
<pre><code class="language-javascript">import { namedNode, quad, literal } from '@rdfjs/data-model';

await system.executeTransaction({
  additions: [
    quad(
      namedNode('http://example.org/charlie'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Charlie')
    ),
    quad(
      namedNode('http://example.org/charlie'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('35', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ],
  removals: [],
  actor: 'admin@example.org'
});
</code></pre>
<pre><code class="language-admonish tip">Always specify the `actor` parameter to track who made changes. This is essential for audit trails and debugging.
</code></pre>
<h3 id="loading-from-files"><a class="header" href="#loading-from-files">Loading from Files</a></h3>
<pre><code class="language-javascript">import { readFileSync } from 'node:fs';
import { parseTurtle } from 'unrdf';

// Load Turtle file
const ttl = readFileSync('./data.ttl', 'utf8');
const store = await parseTurtle(ttl);

// Add to knowledge graph
await system.executeTransaction({
  additions: [...store],
  removals: [],
  actor: 'file-import'
});
</code></pre>
<h3 id="removing-data"><a class="header" href="#removing-data">Removing Data</a></h3>
<pre><code class="language-javascript">await system.executeTransaction({
  additions: [],
  removals: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('30', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ],
  actor: 'admin@example.org'
});
</code></pre>
<h2 id="sparql-queries"><a class="header" href="#sparql-queries">SPARQL Queries</a></h2>
<p>UNRDF supports all SPARQL 1.1 query types through Comunica.</p>
<h3 id="select-queries"><a class="header" href="#select-queries">SELECT Queries</a></h3>
<pre><code class="language-javascript">const results = await system.query({
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

    SELECT ?person ?name ?age
    WHERE {
      ?person a foaf:Person ;
              foaf:name ?name ;
              foaf:age ?age .
    }
    ORDER BY DESC(?age)
  `,
  type: 'sparql-select'
});

console.log(results);
// [
//   { person: NamedNode('ex:charlie'), name: Literal('Charlie'), age: Literal('35') },
//   { person: NamedNode('ex:alice'), name: Literal('Alice'), age: Literal('30') },
//   { person: NamedNode('ex:bob'), name: Literal('Bob'), age: Literal('25') }
// ]
</code></pre>
<pre><code class="language-admonish info">SELECT queries return an array of binding objects. Each binding is a plain JavaScript object with variable names as keys.
</code></pre>
<h3 id="ask-queries"><a class="header" href="#ask-queries">ASK Queries</a></h3>
<pre><code class="language-javascript">const exists = await system.query({
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

    ASK {
      ?person foaf:name "Alice" .
    }
  `,
  type: 'sparql-ask'
});

console.log(exists); // true
</code></pre>
<p>ASK queries return a boolean - useful for validation and conditional logic.</p>
<h3 id="construct-queries"><a class="header" href="#construct-queries">CONSTRUCT Queries</a></h3>
<pre><code class="language-javascript">const graph = await system.query({
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

    CONSTRUCT {
      ?person foaf:name ?name .
    }
    WHERE {
      ?person a foaf:Person ;
              foaf:name ?name .
    }
  `,
  type: 'sparql-construct'
});

// graph is an N3.Store with the constructed triples
console.log(`Constructed ${graph.size} triples`);
</code></pre>
<p>CONSTRUCT queries return a new RDF graph (N3.Store) containing the constructed triples.</p>
<h3 id="describe-queries"><a class="header" href="#describe-queries">DESCRIBE Queries</a></h3>
<pre><code class="language-javascript">const description = await system.query({
  query: `
    PREFIX ex: &lt;http://example.org/&gt;

    DESCRIBE ex:alice
  `,
  type: 'sparql-describe'
});

// description is an N3.Store with all triples about ex:alice
console.log(description);
</code></pre>
<h3 id="complex-queries"><a class="header" href="#complex-queries">Complex Queries</a></h3>
<pre><code class="language-javascript">const results = await system.query({
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    PREFIX ex: &lt;http://example.org/&gt;

    SELECT ?person ?name ?friend ?friendName
    WHERE {
      # Find all people who know someone
      ?person a foaf:Person ;
              foaf:name ?name ;
              foaf:knows ?friend .

      # Get the friend's name
      ?friend foaf:name ?friendName .

      # Only include people over 25
      ?person foaf:age ?age .
      FILTER (?age &gt; 25)
    }
    ORDER BY ?name
  `,
  type: 'sparql-select'
});
</code></pre>
<pre><code class="language-admonish tip">UNRDF automatically caches SPARQL queries using an LRU cache. Frequently-used queries are served from cache, providing up to 60% faster execution.
</code></pre>
<h2 id="serialization"><a class="header" href="#serialization">Serialization</a></h2>
<p>Convert RDF stores to different formats:</p>
<h3 id="turtle-serialization"><a class="header" href="#turtle-serialization">Turtle Serialization</a></h3>
<pre><code class="language-javascript">import { toTurtle } from 'unrdf';

const turtle = await toTurtle(store, {
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  }
});

console.log(turtle);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

ex:alice a foaf:Person ;
         foaf:name "Alice" ;
         foaf:age 30 ;
         foaf:knows ex:bob .

ex:bob a foaf:Person ;
       foaf:name "Bob" ;
       foaf:age 25 .
</code></pre>
<h3 id="n-quads-serialization"><a class="header" href="#n-quads-serialization">N-Quads Serialization</a></h3>
<pre><code class="language-javascript">import { toNQuads } from 'unrdf';

const nquads = await toNQuads(store);

console.log(nquads);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>&lt;http://example.org/alice&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://xmlns.com/foaf/0.1/Person&gt; .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; "Alice" .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/age&gt; "30"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; .
</code></pre>
<h3 id="json-ld-serialization"><a class="header" href="#json-ld-serialization">JSON-LD Serialization</a></h3>
<pre><code class="language-javascript">import { toJsonLd } from 'unrdf';

const jsonld = await toJsonLd(store, {
  context: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/',
    name: 'foaf:name',
    age: 'foaf:age'
  }
});

console.log(JSON.stringify(jsonld, null, 2));
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-json">{
  "@context": {
    "ex": "http://example.org/",
    "foaf": "http://xmlns.com/foaf/0.1/",
    "name": "foaf:name",
    "age": "foaf:age"
  },
  "@graph": [
    {
      "@id": "ex:alice",
      "@type": "foaf:Person",
      "name": "Alice",
      "age": 30
    },
    {
      "@id": "ex:bob",
      "@type": "foaf:Person",
      "name": "Bob",
      "age": 25
    }
  ]
}
</code></pre>
<h2 id="shacl-validation"><a class="header" href="#shacl-validation">SHACL Validation</a></h2>
<p>Validate RDF data against SHACL shapes:</p>
<pre><code class="language-javascript">import { parseTurtle } from 'unrdf';

// Define SHACL shapes
const shapes = await parseTurtle(`
  @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
  @prefix ex: &lt;http://example.org/&gt; .
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
  @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

  ex:PersonShape a sh:NodeShape ;
    sh:targetClass foaf:Person ;
    sh:property [
      sh:path foaf:name ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:string ;
    ] ;
    sh:property [
      sh:path foaf:age ;
      sh:minCount 1 ;
      sh:datatype xsd:integer ;
      sh:minInclusive 0 ;
      sh:maxInclusive 150 ;
    ] .
`);

// Validate data
const validation = await system.validate({
  dataGraph: store,
  shapesGraph: shapes
});

if (!validation.conforms) {
  console.log('Validation errors:');
  validation.results.forEach(result =&gt; {
    console.log(`- ${result.message}`);
  });
}
</code></pre>
<pre><code class="language-admonish warning">SHACL validation is performed during transactions when validation hooks are registered. Failed validations cause the transaction to roll back.
</code></pre>
<h2 id="error-handling-2"><a class="header" href="#error-handling-2">Error Handling</a></h2>
<p>Always wrap UNRDF operations in try-catch blocks:</p>
<pre><code class="language-javascript">try {
  await system.executeTransaction({
    additions: [quad(s, p, o)],
    removals: [],
    actor: 'user'
  });
} catch (error) {
  if (error.message.includes('validation')) {
    console.error('Validation failed:', error.message);
  } else if (error.message.includes('timeout')) {
    console.error('Query timeout:', error.message);
  } else {
    console.error('Transaction failed:', error);
  }

  // Transaction automatically rolled back
  // Store state is preserved
}
</code></pre>
<pre><code class="language-admonish info">UNRDF transactions have **automatic rollback** on failure. The store always remains in a consistent state.
</code></pre>
<h2 id="complete-example"><a class="header" href="#complete-example">Complete Example</a></h2>
<p>Here's a complete example combining all the concepts:</p>
<pre><code class="language-javascript">import { createDarkMatterCore, parseTurtle, toTurtle } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';

// Create system
const system = await createDarkMatterCore();

try {
  // Load initial data
  const ttl = `
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

    ex:alice a foaf:Person ;
             foaf:name "Alice" ;
             foaf:age 30 .
  `;

  const store = await parseTurtle(ttl);

  await system.executeTransaction({
    additions: [...store],
    removals: [],
    actor: 'initial-import'
  });

  // Add more data
  await system.executeTransaction({
    additions: [
      quad(
        namedNode('http://example.org/bob'),
        namedNode('http://xmlns.com/foaf/0.1/name'),
        literal('Bob')
      ),
      quad(
        namedNode('http://example.org/alice'),
        namedNode('http://xmlns.com/foaf/0.1/knows'),
        namedNode('http://example.org/bob')
      )
    ],
    removals: [],
    actor: 'admin@example.org'
  });

  // Query data
  const results = await system.query({
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      SELECT ?person ?name ?friend
      WHERE {
        ?person foaf:name ?name ;
                foaf:knows ?friend .
      }
    `,
    type: 'sparql-select'
  });

  console.log('Results:', results);

  // Serialize to Turtle
  const output = await toTurtle(system.store, {
    prefixes: {
      ex: 'http://example.org/',
      foaf: 'http://xmlns.com/foaf/0.1/'
    }
  });

  console.log('Turtle output:\n', output);

} catch (error) {
  console.error('Error:', error);
} finally {
  // Always cleanup
  await system.cleanup();
}
</code></pre>
<h2 id="performance-tips"><a class="header" href="#performance-tips">Performance Tips</a></h2>
<h3 id="1-batch-transactions"><a class="header" href="#1-batch-transactions">1. Batch Transactions</a></h3>
<pre><code class="language-javascript">// ‚ùå Inefficient: Multiple small transactions
for (const person of people) {
  await system.executeTransaction({
    additions: [createPersonQuad(person)],
    removals: [],
    actor: 'import'
  });
}

// ‚úÖ Efficient: Single large transaction
await system.executeTransaction({
  additions: people.map(createPersonQuad),
  removals: [],
  actor: 'import'
});
</code></pre>
<h3 id="2-use-query-caching"><a class="header" href="#2-use-query-caching">2. Use Query Caching</a></h3>
<pre><code class="language-javascript">// Frequently-used queries are automatically cached
const config = await createDarkMatterCore({
  enableCaching: true,
  cacheSize: 10000 // LRU cache for 10k queries
});
</code></pre>
<h3 id="3-optimize-sparql-queries"><a class="header" href="#3-optimize-sparql-queries">3. Optimize SPARQL Queries</a></h3>
<pre><code class="language-javascript">// ‚ùå Inefficient: Unbounded query
SELECT * WHERE { ?s ?p ?o }

// ‚úÖ Efficient: Specific patterns with LIMIT
SELECT ?person ?name
WHERE {
  ?person a foaf:Person ;
          foaf:name ?name .
}
LIMIT 100
</code></pre>
<h2 id="whats-next-3"><a class="header" href="#whats-next-3">What's Next?</a></h2>
<p>Now that you understand basic RDF operations, continue to:</p>
<ol>
<li><strong><a href="getting-started/first-hook.html">First Hook</a></strong> - Create your first Knowledge Hook for autonomic behavior</li>
<li><strong>Advanced Queries</strong> - Learn complex SPARQL patterns</li>
<li><strong>Performance Tuning</strong> - Optimize for production workloads</li>
</ol>
<pre><code class="language-admonish tip">For production applications, enable observability to track performance metrics:

```javascript
const system = await createDarkMatterCore({
  enableObservability: true
});

// Access metrics
const metrics = system.getComponent('observability').getPerformanceMetrics();
console.log(`Query p95 latency: ${metrics.latency.p95}ms`);
</code></pre>
<pre><code>
---

**Ready for autonomic behavior?** Head to [First Hook](first-hook.md) to learn about Knowledge Hooks.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="your-first-knowledge-hook"><a class="header" href="#your-first-knowledge-hook">Your First Knowledge Hook</a></h1>
<p>Knowledge Hooks are the heart of UNRDF's autonomic capabilities. They transform your knowledge graph from a passive data store into an intelligent, self-governing system.</p>
<h2 id="what-is-a-knowledge-hook"><a class="header" href="#what-is-a-knowledge-hook">What is a Knowledge Hook?</a></h2>
<p>A <strong>Knowledge Hook</strong> is a policy-driven trigger that:</p>
<ol>
<li><strong>Observes</strong> - Monitors the knowledge graph for specific conditions</li>
<li><strong>Evaluates</strong> - Checks if a condition is met (using SPARQL, SHACL, or custom logic)</li>
<li><strong>Reacts</strong> - Executes effects when triggered (validate, transform, notify, etc.)</li>
</ol>
<p>Think of hooks as "business rules" or "database triggers" for knowledge graphs, but with:</p>
<ul>
<li><strong>Declarative conditions</strong> (SPARQL queries, SHACL shapes)</li>
<li><strong>Cryptographic provenance</strong> (every hook execution is logged)</li>
<li><strong>Effect sandboxing</strong> (hooks run in isolated environments)</li>
<li><strong>Performance optimization</strong> (hooks are batched and parallelized)</li>
</ul>
<pre><code class="language-admonish info">Knowledge Hooks are inspired by Nitro's `defineTask` and React's `useEffect`, but designed specifically for knowledge-native, policy-first systems.
</code></pre>
<h2 id="creating-your-first-hook"><a class="header" href="#creating-your-first-hook">Creating Your First Hook</a></h2>
<p>Let's create a simple validation hook that ensures all persons have names.</p>
<h3 id="step-1-define-the-hook"><a class="header" href="#step-1-define-the-hook">Step 1: Define the Hook</a></h3>
<pre><code class="language-javascript">import { defineHook } from 'unrdf';

const nameValidationHook = defineHook({
  meta: {
    name: 'person-name-required',
    description: 'Ensures all persons have names'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have a name');
    }
  }
});
</code></pre>
<p><strong>Let's break this down:</strong></p>
<ul>
<li><strong><code>meta</code></strong> - Identifies the hook for logging and debugging</li>
<li><strong><code>when</code></strong> - Defines the trigger condition (SPARQL ASK query)</li>
<li><strong><code>run</code></strong> - Executes when the condition is true</li>
</ul>
<pre><code class="language-admonish tip">The `when` clause uses a SPARQL ASK query that returns `true` if any person exists without a name. The `run` function then throws an error to prevent the transaction.
</code></pre>
<h3 id="step-2-register-the-hook"><a class="header" href="#step-2-register-the-hook">Step 2: Register the Hook</a></h3>
<pre><code class="language-javascript">import { registerHook } from 'unrdf';

await registerHook(nameValidationHook);

console.log('‚úÖ Hook registered successfully');
</code></pre>
<p>Once registered, the hook is <strong>active</strong> and will evaluate on every transaction.</p>
<h3 id="step-3-test-the-hook"><a class="header" href="#step-3-test-the-hook">Step 3: Test the Hook</a></h3>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';

const system = await createDarkMatterCore();

// This transaction will FAIL (person without name)
try {
  await system.executeTransaction({
    additions: [
      quad(
        namedNode('http://example.org/alice'),
        namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
        namedNode('http://xmlns.com/foaf/0.1/Person')
      )
      // Missing foaf:name!
    ],
    removals: [],
    actor: 'test-user'
  });
} catch (error) {
  console.log('‚ùå Transaction rejected:', error.message);
  // Output: ‚ùå Transaction rejected: All persons must have a name
}

// This transaction will SUCCEED (person with name)
await system.executeTransaction({
  additions: [
    quad(
      namedNode('http://example.org/bob'),
      namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      namedNode('http://xmlns.com/foaf/0.1/Person')
    ),
    quad(
      namedNode('http://example.org/bob'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Bob')
    )
  ],
  removals: [],
  actor: 'test-user'
});

console.log('‚úÖ Transaction succeeded');

await system.cleanup();
</code></pre>
<pre><code class="language-admonish success title=&quot;Congratulations!&quot;">You've created your first Knowledge Hook! Your knowledge graph now **automatically enforces** the "persons must have names" policy.
</code></pre>
<h2 id="complete-example-1"><a class="header" href="#complete-example-1">Complete Example</a></h2>
<p>Here's a complete, runnable example:</p>
<pre><code class="language-javascript">import { createDarkMatterCore, defineHook, registerHook } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';

// 1. Define the hook
const nameValidationHook = defineHook({
  meta: {
    name: 'person-name-required',
    description: 'Ensures all persons have names'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have a name');
    }
  }
});

// 2. Create system and register hook
const system = await createDarkMatterCore();
await registerHook(nameValidationHook);

// 3. Test valid transaction (should succeed)
await system.executeTransaction({
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      namedNode('http://xmlns.com/foaf/0.1/Person')
    ),
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Alice')
    )
  ],
  removals: [],
  actor: 'admin'
});

console.log('‚úÖ Valid transaction succeeded');

// 4. Test invalid transaction (should fail)
try {
  await system.executeTransaction({
    additions: [
      quad(
        namedNode('http://example.org/bob'),
        namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
        namedNode('http://xmlns.com/foaf/0.1/Person')
      )
      // Missing name!
    ],
    removals: [],
    actor: 'admin'
  });
} catch (error) {
  console.log('‚ùå Invalid transaction rejected:', error.message);
}

// 5. Cleanup
await system.cleanup();
</code></pre>
<p>Save this as <code>first-hook.mjs</code> and run:</p>
<pre><code class="language-bash">node first-hook.mjs
</code></pre>
<p><strong>Expected output:</strong></p>
<pre><code>‚úÖ Valid transaction succeeded
‚ùå Invalid transaction rejected: All persons must have a name
</code></pre>
<h2 id="hook-types"><a class="header" href="#hook-types">Hook Types</a></h2>
<p>UNRDF supports multiple hook types for different use cases:</p>
<h3 id="1-sparql-ask-hooks"><a class="header" href="#1-sparql-ask-hooks">1. SPARQL ASK Hooks</a></h3>
<p>Use SPARQL ASK queries to check conditions:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'age-validation', description: 'Ensure age &gt;= 18' },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        ?person ex:age ?age .
        FILTER (?age &lt; 18)
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must be 18 or older');
    }
  }
});
</code></pre>
<h3 id="2-shacl-hooks"><a class="header" href="#2-shacl-hooks">2. SHACL Hooks</a></h3>
<p>Use SHACL shapes for structural validation:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'shacl-validation', description: 'Validate against shapes' },
  when: {
    kind: 'shacl',
    shapes: shaclShapesStore // N3.Store containing SHACL shapes
  },
  run: async (event) =&gt; {
    if (!event.conforms) {
      throw new Error(`SHACL validation failed: ${event.results.length} violations`);
    }
  }
});
</code></pre>
<h3 id="3-delta-hooks"><a class="header" href="#3-delta-hooks">3. Delta Hooks</a></h3>
<p>React to specific changes in the graph:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'audit-logger', description: 'Log all person changes' },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      object: namedNode('http://xmlns.com/foaf/0.1/Person')
    }
  },
  run: async (event) =&gt; {
    console.log(`Person added: ${event.delta.additions.length} triples`);
  }
});
</code></pre>
<h3 id="4-threshold-hooks"><a class="header" href="#4-threshold-hooks">4. Threshold Hooks</a></h3>
<p>Trigger when numeric values exceed thresholds:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'large-transaction', description: 'Alert on large transactions' },
  when: {
    kind: 'threshold',
    value: 1000,
    operator: 'gt'
  },
  run: async (event) =&gt; {
    console.log(`Large transaction detected: ${event.value} triples`);
  }
});
</code></pre>
<h3 id="5-count-hooks"><a class="header" href="#5-count-hooks">5. Count Hooks</a></h3>
<p>Enforce cardinality constraints:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'max-persons', description: 'Limit total persons' },
  when: {
    kind: 'count',
    min: 0,
    max: 10000
  },
  run: async (event) =&gt; {
    if (event.count &gt; 10000) {
      throw new Error('Maximum 10,000 persons allowed');
    }
  }
});
</code></pre>
<h3 id="6-window-hooks"><a class="header" href="#6-window-hooks">6. Window Hooks</a></h3>
<p>Time-based aggregations:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'rate-limiter', description: 'Limit transaction rate' },
  when: {
    kind: 'window',
    duration: '5m'
  },
  run: async (event) =&gt; {
    if (event.count &gt; 100) {
      throw new Error('Rate limit exceeded: max 100 transactions per 5 minutes');
    }
  }
});
</code></pre>
<h2 id="hook-lifecycle"><a class="header" href="#hook-lifecycle">Hook Lifecycle</a></h2>
<p>Hooks have three lifecycle phases:</p>
<h3 id="before-phase-optional"><a class="header" href="#before-phase-optional">Before Phase (Optional)</a></h3>
<p>Pre-condition gate for payload normalization or early cancellation:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'example', description: 'Example with before' },
  when: { kind: 'sparql-ask', query: '...' },

  async before({ payload }) {
    // Validate payload
    if (!payload.actor) {
      return { cancel: true, reason: 'Actor required' };
    }

    // Normalize payload
    return { ...payload, timestamp: new Date().toISOString() };
  },

  run: async (event) =&gt; {
    // Main logic
  }
});
</code></pre>
<h3 id="run-phase-required"><a class="header" href="#run-phase-required">Run Phase (Required)</a></h3>
<p>The core effect or analysis:</p>
<pre><code class="language-javascript">run: async (event) =&gt; {
  // event.result - Condition evaluation result
  // event.payload - Transaction payload
  // event.context - Execution context

  if (event.result === true) {
    throw new Error('Condition violated');
  }

  return { result: 'success' };
}
</code></pre>
<h3 id="after-phase-optional"><a class="header" href="#after-phase-optional">After Phase (Optional)</a></h3>
<p>Post-execution step for auditing and cleanup:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'example', description: 'Example with after' },
  when: { kind: 'sparql-ask', query: '...' },

  run: async (event) =&gt; {
    // Main logic
    return { result: 'processed' };
  },

  async after({ result, cancelled, reason }) {
    if (cancelled) {
      console.log(`Hook cancelled: ${reason}`);
    } else {
      console.log(`Hook completed: ${result}`);
    }

    return { finalStatus: cancelled ? 'cancelled' : 'completed' };
  }
});
</code></pre>
<h2 id="advanced-example-age-validation-with-lifecycle"><a class="header" href="#advanced-example-age-validation-with-lifecycle">Advanced Example: Age Validation with Lifecycle</a></h2>
<pre><code class="language-javascript">import { defineHook, registerHook } from 'unrdf';

const ageValidationHook = defineHook({
  meta: {
    name: 'age-validation',
    description: 'Ensure age is valid and &gt;= 18'
  },

  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        ?person ex:age ?age .
        FILTER (?age &lt; 18)
      }
    `
  },

  async before({ payload }) {
    // Validate payload has required fields
    if (!payload || !payload.actor) {
      return {
        cancel: true,
        reason: 'Transaction requires an actor'
      };
    }

    // Add timestamp for audit
    return {
      ...payload,
      validatedAt: new Date().toISOString()
    };
  },

  async run({ result, payload }) {
    console.log(`Validating age for transaction by ${payload.actor}`);

    if (result === true) {
      throw new Error('All persons must be 18 or older');
    }

    return {
      result: 'valid',
      validatedAt: payload.validatedAt
    };
  },

  async after({ result, cancelled, reason }) {
    if (cancelled) {
      console.log(`‚ùå Validation cancelled: ${reason}`);
    } else {
      console.log(`‚úÖ Validation passed at ${result.validatedAt}`);
    }

    return {
      finalStatus: cancelled ? 'cancelled' : 'completed',
      timestamp: new Date().toISOString()
    };
  }
});

await registerHook(ageValidationHook);
</code></pre>
<h2 id="managing-hooks"><a class="header" href="#managing-hooks">Managing Hooks</a></h2>
<h3 id="list-registered-hooks"><a class="header" href="#list-registered-hooks">List Registered Hooks</a></h3>
<pre><code class="language-javascript">import { getRegisteredHooks } from 'unrdf';

const hooks = getRegisteredHooks();
console.log(`${hooks.length} hooks registered:`);

hooks.forEach(hook =&gt; {
  console.log(`- ${hook.meta.name}: ${hook.meta.description}`);
});
</code></pre>
<h3 id="deregister-a-hook"><a class="header" href="#deregister-a-hook">Deregister a Hook</a></h3>
<pre><code class="language-javascript">import { deregisterHook } from 'unrdf';

await deregisterHook('person-name-required');
console.log('Hook deregistered');
</code></pre>
<h3 id="reset-all-hooks"><a class="header" href="#reset-all-hooks">Reset All Hooks</a></h3>
<pre><code class="language-javascript">import { resetGlobalHookManager } from 'unrdf';

resetGlobalHookManager();
console.log('All hooks cleared');
</code></pre>
<h2 id="best-practices"><a class="header" href="#best-practices">Best Practices</a></h2>
<h3 id="1-keep-hooks-focused"><a class="header" href="#1-keep-hooks-focused">1. Keep Hooks Focused</a></h3>
<pre><code class="language-javascript">// ‚ùå Bad: Hook does too much
defineHook({
  meta: { name: 'do-everything', description: 'Does everything' },
  when: { kind: 'sparql-ask', query: '...' },
  run: async (event) =&gt; {
    validateAge(event);
    validateName(event);
    validateEmail(event);
    sendNotification(event);
    updateCache(event);
  }
});

// ‚úÖ Good: Separate hooks for separate concerns
defineHook({ meta: { name: 'validate-age' }, ... });
defineHook({ meta: { name: 'validate-name' }, ... });
defineHook({ meta: { name: 'validate-email' }, ... });
</code></pre>
<h3 id="2-use-descriptive-names"><a class="header" href="#2-use-descriptive-names">2. Use Descriptive Names</a></h3>
<pre><code class="language-javascript">// ‚ùå Bad
defineHook({ meta: { name: 'hook1' }, ... });

// ‚úÖ Good
defineHook({ meta: { name: 'person-age-validation' }, ... });
</code></pre>
<h3 id="3-handle-errors-gracefully"><a class="header" href="#3-handle-errors-gracefully">3. Handle Errors Gracefully</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  try {
    if (event.result === true) {
      throw new Error('Validation failed');
    }
  } catch (error) {
    // Log for debugging
    console.error(`Hook ${event.name} failed:`, error);

    // Re-throw to fail transaction
    throw error;
  }
}
</code></pre>
<h3 id="4-use-before-for-early-cancellation"><a class="header" href="#4-use-before-for-early-cancellation">4. Use <code>before</code> for Early Cancellation</a></h3>
<pre><code class="language-javascript">before: async ({ payload }) =&gt; {
  // Cancel early if payload is invalid
  if (!isValidPayload(payload)) {
    return { cancel: true, reason: 'Invalid payload' };
  }

  // Don't proceed to expensive SPARQL evaluation
  return payload;
}
</code></pre>
<h2 id="whats-next-4"><a class="header" href="#whats-next-4">What's Next?</a></h2>
<p>Now that you understand Knowledge Hooks, explore:</p>
<ol>
<li><strong>Policy Packs</strong> - Organize related hooks into reusable packages</li>
<li><strong>Advanced Hooks</strong> - Learn about effect composition and multi-agent coordination</li>
<li><strong>Performance Tuning</strong> - Optimize hook execution for production</li>
</ol>
<pre><code class="language-admonish tip">For production systems, enable hook observability to track performance:

```javascript
const system = await createDarkMatterCore({
  enableObservability: true
});

// After running hooks
const metrics = system.getComponent('observability').getPerformanceMetrics();
console.log(`Hook p95 latency: ${metrics.hookExecutionLatency.p95}ms`);
</code></pre>
<pre><code>
---

**Congratulations!** You've mastered the basics of Knowledge Hooks. Your knowledge graph is now an intelligent, self-governing system.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rdf-fundamentals"><a class="header" href="#rdf-fundamentals">RDF Fundamentals</a></h1>
<p>This chapter introduces RDF (Resource Description Framework) from a developer's perspective, focusing on practical understanding and implementation using UNRDF.</p>
<h2 id="what-is-rdf"><a class="header" href="#what-is-rdf">What is RDF?</a></h2>
<p>RDF is a W3C standard for representing information as <strong>graphs</strong> of interconnected data. Unlike traditional databases that organize data in tables, RDF uses a <strong>graph model</strong> where:</p>
<ul>
<li><strong>Everything is a resource</strong> (documents, people, concepts, events)</li>
<li><strong>Resources have properties</strong> (attributes and relationships)</li>
<li><strong>Properties connect resources</strong> (forming a web of linked data)</li>
<li><strong>Data is machine-readable</strong> (enabling automated reasoning)</li>
</ul>
<blockquote>
<p><strong>Developer Insight</strong>: Think of RDF as a schema-less graph database with built-in semantics. It's like JSON-LD meets graph theory meets type safety.</p>
</blockquote>
<h2 id="the-triple-model"><a class="header" href="#the-triple-model">The Triple Model</a></h2>
<p>The foundation of RDF is the <strong>triple</strong> (also called a <strong>statement</strong>):</p>
<pre><code class="language-text">Subject ‚Üí Predicate ‚Üí Object
</code></pre>
<p>Every piece of information is expressed as a combination of these three elements:</p>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

# Triple: Subject ‚Üí Predicate ‚Üí Object
ex:alice foaf:name "Alice Smith" .
#   ‚Üë         ‚Üë           ‚Üë
# Subject  Predicate   Object
</code></pre>
<h3 id="triple-components"><a class="header" href="#triple-components">Triple Components</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Subject</strong></td><td>The resource being described</td><td><code>ex:alice</code></td></tr>
<tr><td><strong>Predicate</strong></td><td>The property or relationship</td><td><code>foaf:name</code></td></tr>
<tr><td><strong>Object</strong></td><td>The value or target resource</td><td><code>"Alice Smith"</code></td></tr>
</tbody></table>
</div>
<h2 id="rdf-terms"><a class="header" href="#rdf-terms">RDF Terms</a></h2>
<p>RDF uses three types of terms to build triples:</p>
<h3 id="1-urisiris-internationalized-resource-identifiers"><a class="header" href="#1-urisiris-internationalized-resource-identifiers">1. URIs/IRIs (Internationalized Resource Identifiers)</a></h3>
<p>URIs uniquely identify resources globally:</p>
<pre><code class="language-javascript">import { namedNode } from '@rdfjs/data-model';

// Create IRIs
const person = namedNode('http://example.org/people/alice');
const predicate = namedNode('http://xmlns.com/foaf/0.1/name');
const knows = namedNode('http://xmlns.com/foaf/0.1/knows');
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();

  // Create named nodes (IRIs)
  const alice = ctx.namedNode('http://example.org/alice');
  const name = ctx.namedNode('http://xmlns.com/foaf/0.1/name');

  console.log(alice.termType);  // 'NamedNode'
  console.log(alice.value);     // 'http://example.org/alice'
});
</code></pre>
<h3 id="2-literals"><a class="header" href="#2-literals">2. Literals</a></h3>
<p>Literals represent data values (strings, numbers, dates):</p>
<pre><code class="language-javascript">import { literal } from '@rdfjs/data-model';

// Plain string
const name = literal('Alice Smith');

// Typed literal (integer)
const age = literal('30', namedNode('http://www.w3.org/2001/XMLSchema#integer'));

// Language-tagged string
const greeting = literal('Hello', 'en');
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Plain literal
  const name = ctx.literal('Alice Smith');

  // Typed literal
  const age = ctx.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');

  console.log(name.value);      // 'Alice Smith'
  console.log(age.datatype);    // NamedNode with value xsd:integer
});
</code></pre>
<h4 id="common-xsd-datatypes"><a class="header" href="#common-xsd-datatypes">Common XSD Datatypes</a></h4>
<pre><code class="language-turtle"># String
"Hello World"

# Integer
"42"^^xsd:integer

# Decimal
"3.14"^^xsd:decimal

# Boolean
"true"^^xsd:boolean

# Date
"2025-01-15"^^xsd:date

# DateTime
"2025-01-15T10:30:00Z"^^xsd:dateTime
</code></pre>
<h3 id="3-blank-nodes"><a class="header" href="#3-blank-nodes">3. Blank Nodes</a></h3>
<p>Blank nodes are anonymous resources without URIs:</p>
<pre><code class="language-javascript">import { blankNode } from '@rdfjs/data-model';

// Create blank node
const anon = blankNode();  // Auto-generated ID
const specific = blankNode('b1');  // Specific ID
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Auto-generated blank node
  const b1 = ctx.blankNode();

  // Named blank node
  const b2 = ctx.blankNode('address');

  console.log(b1.termType);  // 'BlankNode'
  console.log(b2.value);     // '_:address'
});
</code></pre>
<p><strong>Use cases for blank nodes:</strong></p>
<ul>
<li>Modeling nested objects (addresses, contact info)</li>
<li>Intermediate nodes in complex relationships</li>
<li>Anonymous resources that don't need global identity</li>
</ul>
<h2 id="quads-triples--context"><a class="header" href="#quads-triples--context">Quads: Triples + Context</a></h2>
<p>UNRDF extends triples to <strong>quads</strong> by adding a fourth component: the <strong>graph</strong>:</p>
<pre><code class="language-text">Subject ‚Üí Predicate ‚Üí Object ‚Üí Graph
</code></pre>
<p>Graphs allow you to organize triples into named contexts:</p>
<pre><code class="language-javascript">import { quad, namedNode, literal, defaultGraph } from '@rdfjs/data-model';

// Quad in default graph
const q1 = quad(
  namedNode('http://example.org/alice'),
  namedNode('http://xmlns.com/foaf/0.1/name'),
  literal('Alice'),
  defaultGraph()
);

// Quad in named graph
const q2 = quad(
  namedNode('http://example.org/bob'),
  namedNode('http://xmlns.com/foaf/0.1/name'),
  literal('Bob'),
  namedNode('http://example.org/graph/users')
);
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  const subject = ctx.namedNode('http://example.org/alice');
  const predicate = ctx.namedNode('http://xmlns.com/foaf/0.1/name');
  const object = ctx.literal('Alice Smith');

  // Create quad
  const quad = ctx.quad(subject, predicate, object);

  // Add to store
  ctx.add(quad);

  console.log(ctx.store.size);  // 1
});
</code></pre>
<h2 id="namespaces-and-prefixes"><a class="header" href="#namespaces-and-prefixes">Namespaces and Prefixes</a></h2>
<p>Namespaces shorten URIs for readability:</p>
<pre><code class="language-turtle"># Without prefixes (verbose)
&lt;http://xmlns.com/foaf/0.1/Person&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://xmlns.com/foaf/0.1/Person&gt; .

# With prefixes (readable)
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

foaf:Person rdf:type foaf:Person .
</code></pre>
<h3 id="common-namespaces"><a class="header" href="#common-namespaces">Common Namespaces</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Prefix</th><th>Namespace</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>rdf:</code></td><td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td><td>RDF vocabulary</td></tr>
<tr><td><code>rdfs:</code></td><td><code>http://www.w3.org/2000/01/rdf-schema#</code></td><td>RDF Schema</td></tr>
<tr><td><code>xsd:</code></td><td><code>http://www.w3.org/2001/XMLSchema#</code></td><td>XML Schema datatypes</td></tr>
<tr><td><code>owl:</code></td><td><code>http://www.w3.org/2002/07/owl#</code></td><td>Web Ontology Language</td></tr>
<tr><td><code>foaf:</code></td><td><code>http://xmlns.com/foaf/0.1/</code></td><td>Friend of a Friend</td></tr>
<tr><td><code>dc:</code></td><td><code>http://purl.org/dc/elements/1.1/</code></td><td>Dublin Core</td></tr>
<tr><td><code>schema:</code></td><td><code>https://schema.org/</code></td><td>Schema.org</td></tr>
</tbody></table>
</div>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { useTurtle, initStore } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const turtle = useTurtle('./graph');

  // Parse with automatic prefix handling
  const store = turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

    ex:alice a foaf:Person ;
             foaf:name "Alice Smith" ;
             foaf:age 30 .
  `);

  // Serialize with prefixes
  const output = turtle.serialize({
    prefixes: {
      ex: 'http://example.org/',
      foaf: 'http://xmlns.com/foaf/0.1/'
    }
  });

  console.log(output);
});
</code></pre>
<h2 id="rdf-serialization-formats"><a class="header" href="#rdf-serialization-formats">RDF Serialization Formats</a></h2>
<p>RDF can be represented in multiple formats:</p>
<h3 id="turtle-terse-rdf-triple-language"><a class="header" href="#turtle-terse-rdf-triple-language">Turtle (Terse RDF Triple Language)</a></h3>
<p>Human-readable, compact format:</p>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

ex:alice a foaf:Person ;
    foaf:name "Alice Smith" ;
    foaf:age 30 ;
    foaf:knows ex:bob .

ex:bob a foaf:Person ;
    foaf:name "Bob Jones" ;
    foaf:age 28 .
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Supports prefixes</li>
<li>Uses <code>;</code> to repeat subjects</li>
<li>Uses <code>,</code> to repeat subject+predicate</li>
<li><code>a</code> is shorthand for <code>rdf:type</code></li>
</ul>
<h3 id="n-quads"><a class="header" href="#n-quads">N-Quads</a></h3>
<p>Line-based format for quads:</p>
<pre><code class="language-nquads">&lt;http://example.org/alice&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://xmlns.com/foaf/0.1/Person&gt; .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; "Alice Smith" .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/age&gt; "30"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; &lt;http://example.org/bob&gt; &lt;http://example.org/graph/social&gt; .
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>One quad per line</li>
<li>No prefixes (full URIs)</li>
<li>Fourth element for named graphs</li>
<li>Machine-optimized</li>
</ul>
<h3 id="json-ld"><a class="header" href="#json-ld">JSON-LD</a></h3>
<p>JSON format for linked data:</p>
<pre><code class="language-json">{
  "@context": {
    "foaf": "http://xmlns.com/foaf/0.1/",
    "ex": "http://example.org/"
  },
  "@id": "ex:alice",
  "@type": "foaf:Person",
  "foaf:name": "Alice Smith",
  "foaf:age": 30,
  "foaf:knows": {
    "@id": "ex:bob"
  }
}
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Standard JSON syntax</li>
<li><code>@context</code> for namespace mapping</li>
<li><code>@id</code> for URIs</li>
<li><code>@type</code> for rdf:type</li>
<li>Easy integration with web APIs</li>
</ul>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { parseTurtle, toNQuads, toJsonLd } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  // Parse Turtle
  const turtleData = `
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

    ex:alice foaf:name "Alice" .
  `;

  const store = await parseTurtle(turtleData);

  // Convert to N-Quads
  const nquads = await toNQuads(store);
  console.log(nquads);

  // Convert to JSON-LD
  const jsonld = await toJsonLd(store);
  console.log(JSON.stringify(jsonld, null, 2));
});
</code></pre>
<h2 id="practical-examples"><a class="header" href="#practical-examples">Practical Examples</a></h2>
<h3 id="example-1-social-network"><a class="header" href="#example-1-social-network">Example 1: Social Network</a></h3>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:alice a foaf:Person ;
    foaf:name "Alice Smith" ;
    foaf:age "30"^^xsd:integer ;
    foaf:mbox &lt;mailto:alice@example.org&gt; ;
    foaf:knows ex:bob, ex:carol .

ex:bob a foaf:Person ;
    foaf:name "Bob Jones" ;
    foaf:age "28"^^xsd:integer ;
    foaf:knows ex:alice .

ex:carol a foaf:Person ;
    foaf:name "Carol Williams" ;
    foaf:age "32"^^xsd:integer .
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { initStore, useStoreContext, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();
  const turtle = useTurtle('./graph');

  // Create nodes
  const alice = ctx.namedNode('http://example.org/alice');
  const bob = ctx.namedNode('http://example.org/bob');
  const foafName = ctx.namedNode('http://xmlns.com/foaf/0.1/name');
  const foafKnows = ctx.namedNode('http://xmlns.com/foaf/0.1/knows');

  // Create quads
  const quads = [
    ctx.quad(alice, foafName, ctx.literal('Alice Smith')),
    ctx.quad(alice, foafKnows, bob),
    ctx.quad(bob, foafName, ctx.literal('Bob Jones'))
  ];

  // Add to store
  quads.forEach(q =&gt; ctx.add(q));

  console.log(`Store contains ${ctx.store.size} quads`);

  // Save as Turtle
  turtle.save('social-network', {
    prefixes: {
      ex: 'http://example.org/',
      foaf: 'http://xmlns.com/foaf/0.1/'
    }
  });
});
</code></pre>
<h3 id="example-2-product-catalog"><a class="header" href="#example-2-product-catalog">Example 2: Product Catalog</a></h3>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:product123 a schema:Product ;
    schema:name "Wireless Mouse" ;
    schema:description "Ergonomic wireless mouse with USB receiver" ;
    schema:price "29.99"^^xsd:decimal ;
    schema:priceCurrency "USD" ;
    schema:availability schema:InStock ;
    schema:brand [
        a schema:Brand ;
        schema:name "TechCo"
    ] .
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Create product
  const product = ctx.namedNode('http://example.org/product123');
  const schemaProduct = ctx.namedNode('https://schema.org/Product');
  const schemaName = ctx.namedNode('https://schema.org/name');
  const schemaPrice = ctx.namedNode('https://schema.org/price');
  const schemaBrand = ctx.namedNode('https://schema.org/brand');
  const rdfType = ctx.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');

  // Create brand (blank node)
  const brand = ctx.blankNode('brand');

  // Build graph
  ctx.add(
    ctx.quad(product, rdfType, schemaProduct),
    ctx.quad(product, schemaName, ctx.literal('Wireless Mouse')),
    ctx.quad(product, schemaPrice, ctx.literal('29.99', 'http://www.w3.org/2001/XMLSchema#decimal')),
    ctx.quad(product, schemaBrand, brand),
    ctx.quad(brand, schemaName, ctx.literal('TechCo'))
  );

  console.log(`Product catalog: ${ctx.store.size} quads`);
});
</code></pre>
<h2 id="best-practices-1"><a class="header" href="#best-practices-1">Best Practices</a></h2>
<h3 id="1-use-meaningful-uris"><a class="header" href="#1-use-meaningful-uris">1. Use Meaningful URIs</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Descriptive URIs
const person = ctx.namedNode('http://example.org/people/alice-smith');
const property = ctx.namedNode('http://example.org/schema/employeeId');

// ‚ùå Avoid: Opaque identifiers
const person = ctx.namedNode('http://example.org/p1');
const property = ctx.namedNode('http://example.org/x');
</code></pre>
<h3 id="2-choose-appropriate-datatypes"><a class="header" href="#2-choose-appropriate-datatypes">2. Choose Appropriate Datatypes</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Typed literals
const age = ctx.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');
const price = ctx.literal('19.99', 'http://www.w3.org/2001/XMLSchema#decimal');
const active = ctx.literal('true', 'http://www.w3.org/2001/XMLSchema#boolean');

// ‚ùå Avoid: Untyped when type matters
const age = ctx.literal('30');  // Treated as string
</code></pre>
<h3 id="3-use-standard-vocabularies"><a class="header" href="#3-use-standard-vocabularies">3. Use Standard Vocabularies</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Reuse standard vocabularies
import { FOAF, SCHEMA, DC } from 'unrdf/vocabularies';

const person = ctx.quad(
  ctx.namedNode('http://example.org/alice'),
  ctx.namedNode(FOAF.name),
  ctx.literal('Alice')
);

// ‚ùå Avoid: Creating custom vocabularies for common concepts
const customName = ctx.namedNode('http://example.org/hasName');
</code></pre>
<h3 id="4-organize-with-namespaces"><a class="header" href="#4-organize-with-namespaces">4. Organize with Namespaces</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Clear namespace organization
const prefixes = {
  ex: 'http://example.org/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  schema: 'https://schema.org/',
  xsd: 'http://www.w3.org/2001/XMLSchema#'
};

// ‚ùå Avoid: Mixing namespaces inconsistently
</code></pre>
<h2 id="next-steps-3"><a class="header" href="#next-steps-3">Next Steps</a></h2>
<p>Now that you understand RDF fundamentals:</p>
<ol>
<li><strong><a href="concepts/./store-context.html">Store Context Pattern</a></strong> - Learn how UNRDF manages state</li>
<li><strong><a href="concepts/./composables.html">Composables</a></strong> - Explore UNRDF's composable functions</li>
<li><strong><a href="concepts/./transactions.html">Transactions</a></strong> - Master atomic operations</li>
</ol>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<ul>
<li><strong>RDF</strong> is a graph-based data model using triples (subject-predicate-object)</li>
<li><strong>Terms</strong> include URIs (resources), Literals (values), and Blank Nodes (anonymous)</li>
<li><strong>Quads</strong> extend triples with graph context</li>
<li><strong>Namespaces</strong> shorten URIs and organize vocabularies</li>
<li><strong>Formats</strong> include Turtle (human), N-Quads (machine), JSON-LD (web)</li>
<li><strong>UNRDF</strong> provides a composable, type-safe API for RDF operations</li>
</ul>
<p>The composable nature of UNRDF makes it easy to work with RDF while maintaining clean, maintainable code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="rdf-fundamentals-1"><a class="header" href="#rdf-fundamentals-1">RDF Fundamentals</a></h1>
<p>This chapter introduces RDF (Resource Description Framework) from a developer's perspective, focusing on practical understanding and implementation using UNRDF.</p>
<h2 id="what-is-rdf-1"><a class="header" href="#what-is-rdf-1">What is RDF?</a></h2>
<p>RDF is a W3C standard for representing information as <strong>graphs</strong> of interconnected data. Unlike traditional databases that organize data in tables, RDF uses a <strong>graph model</strong> where:</p>
<ul>
<li><strong>Everything is a resource</strong> (documents, people, concepts, events)</li>
<li><strong>Resources have properties</strong> (attributes and relationships)</li>
<li><strong>Properties connect resources</strong> (forming a web of linked data)</li>
<li><strong>Data is machine-readable</strong> (enabling automated reasoning)</li>
</ul>
<blockquote>
<p><strong>Developer Insight</strong>: Think of RDF as a schema-less graph database with built-in semantics. It's like JSON-LD meets graph theory meets type safety.</p>
</blockquote>
<h2 id="the-triple-model-1"><a class="header" href="#the-triple-model-1">The Triple Model</a></h2>
<p>The foundation of RDF is the <strong>triple</strong> (also called a <strong>statement</strong>):</p>
<pre><code class="language-text">Subject ‚Üí Predicate ‚Üí Object
</code></pre>
<p>Every piece of information is expressed as a combination of these three elements:</p>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

# Triple: Subject ‚Üí Predicate ‚Üí Object
ex:alice foaf:name "Alice Smith" .
#   ‚Üë         ‚Üë           ‚Üë
# Subject  Predicate   Object
</code></pre>
<h3 id="triple-components-1"><a class="header" href="#triple-components-1">Triple Components</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Component</th><th>Description</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Subject</strong></td><td>The resource being described</td><td><code>ex:alice</code></td></tr>
<tr><td><strong>Predicate</strong></td><td>The property or relationship</td><td><code>foaf:name</code></td></tr>
<tr><td><strong>Object</strong></td><td>The value or target resource</td><td><code>"Alice Smith"</code></td></tr>
</tbody></table>
</div>
<h2 id="rdf-terms-1"><a class="header" href="#rdf-terms-1">RDF Terms</a></h2>
<p>RDF uses three types of terms to build triples:</p>
<h3 id="1-urisiris-internationalized-resource-identifiers-1"><a class="header" href="#1-urisiris-internationalized-resource-identifiers-1">1. URIs/IRIs (Internationalized Resource Identifiers)</a></h3>
<p>URIs uniquely identify resources globally:</p>
<pre><code class="language-javascript">import { namedNode } from '@rdfjs/data-model';

// Create IRIs
const person = namedNode('http://example.org/people/alice');
const predicate = namedNode('http://xmlns.com/foaf/0.1/name');
const knows = namedNode('http://xmlns.com/foaf/0.1/knows');
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();

  // Create named nodes (IRIs)
  const alice = ctx.namedNode('http://example.org/alice');
  const name = ctx.namedNode('http://xmlns.com/foaf/0.1/name');

  console.log(alice.termType);  // 'NamedNode'
  console.log(alice.value);     // 'http://example.org/alice'
});
</code></pre>
<h3 id="2-literals-1"><a class="header" href="#2-literals-1">2. Literals</a></h3>
<p>Literals represent data values (strings, numbers, dates):</p>
<pre><code class="language-javascript">import { literal } from '@rdfjs/data-model';

// Plain string
const name = literal('Alice Smith');

// Typed literal (integer)
const age = literal('30', namedNode('http://www.w3.org/2001/XMLSchema#integer'));

// Language-tagged string
const greeting = literal('Hello', 'en');
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Plain literal
  const name = ctx.literal('Alice Smith');

  // Typed literal
  const age = ctx.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');

  console.log(name.value);      // 'Alice Smith'
  console.log(age.datatype);    // NamedNode with value xsd:integer
});
</code></pre>
<h4 id="common-xsd-datatypes-1"><a class="header" href="#common-xsd-datatypes-1">Common XSD Datatypes</a></h4>
<pre><code class="language-turtle"># String
"Hello World"

# Integer
"42"^^xsd:integer

# Decimal
"3.14"^^xsd:decimal

# Boolean
"true"^^xsd:boolean

# Date
"2025-01-15"^^xsd:date

# DateTime
"2025-01-15T10:30:00Z"^^xsd:dateTime
</code></pre>
<h3 id="3-blank-nodes-1"><a class="header" href="#3-blank-nodes-1">3. Blank Nodes</a></h3>
<p>Blank nodes are anonymous resources without URIs:</p>
<pre><code class="language-javascript">import { blankNode } from '@rdfjs/data-model';

// Create blank node
const anon = blankNode();  // Auto-generated ID
const specific = blankNode('b1');  // Specific ID
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Auto-generated blank node
  const b1 = ctx.blankNode();

  // Named blank node
  const b2 = ctx.blankNode('address');

  console.log(b1.termType);  // 'BlankNode'
  console.log(b2.value);     // '_:address'
});
</code></pre>
<p><strong>Use cases for blank nodes:</strong></p>
<ul>
<li>Modeling nested objects (addresses, contact info)</li>
<li>Intermediate nodes in complex relationships</li>
<li>Anonymous resources that don't need global identity</li>
</ul>
<h2 id="quads-triples--context-1"><a class="header" href="#quads-triples--context-1">Quads: Triples + Context</a></h2>
<p>UNRDF extends triples to <strong>quads</strong> by adding a fourth component: the <strong>graph</strong>:</p>
<pre><code class="language-text">Subject ‚Üí Predicate ‚Üí Object ‚Üí Graph
</code></pre>
<p>Graphs allow you to organize triples into named contexts:</p>
<pre><code class="language-javascript">import { quad, namedNode, literal, defaultGraph } from '@rdfjs/data-model';

// Quad in default graph
const q1 = quad(
  namedNode('http://example.org/alice'),
  namedNode('http://xmlns.com/foaf/0.1/name'),
  literal('Alice'),
  defaultGraph()
);

// Quad in named graph
const q2 = quad(
  namedNode('http://example.org/bob'),
  namedNode('http://xmlns.com/foaf/0.1/name'),
  literal('Bob'),
  namedNode('http://example.org/graph/users')
);
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  const subject = ctx.namedNode('http://example.org/alice');
  const predicate = ctx.namedNode('http://xmlns.com/foaf/0.1/name');
  const object = ctx.literal('Alice Smith');

  // Create quad
  const quad = ctx.quad(subject, predicate, object);

  // Add to store
  ctx.add(quad);

  console.log(ctx.store.size);  // 1
});
</code></pre>
<h2 id="namespaces-and-prefixes-1"><a class="header" href="#namespaces-and-prefixes-1">Namespaces and Prefixes</a></h2>
<p>Namespaces shorten URIs for readability:</p>
<pre><code class="language-turtle"># Without prefixes (verbose)
&lt;http://xmlns.com/foaf/0.1/Person&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://xmlns.com/foaf/0.1/Person&gt; .

# With prefixes (readable)
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix rdf: &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#&gt; .

foaf:Person rdf:type foaf:Person .
</code></pre>
<h3 id="common-namespaces-1"><a class="header" href="#common-namespaces-1">Common Namespaces</a></h3>
<div class="table-wrapper"><table><thead><tr><th>Prefix</th><th>Namespace</th><th>Purpose</th></tr></thead><tbody>
<tr><td><code>rdf:</code></td><td><code>http://www.w3.org/1999/02/22-rdf-syntax-ns#</code></td><td>RDF vocabulary</td></tr>
<tr><td><code>rdfs:</code></td><td><code>http://www.w3.org/2000/01/rdf-schema#</code></td><td>RDF Schema</td></tr>
<tr><td><code>xsd:</code></td><td><code>http://www.w3.org/2001/XMLSchema#</code></td><td>XML Schema datatypes</td></tr>
<tr><td><code>owl:</code></td><td><code>http://www.w3.org/2002/07/owl#</code></td><td>Web Ontology Language</td></tr>
<tr><td><code>foaf:</code></td><td><code>http://xmlns.com/foaf/0.1/</code></td><td>Friend of a Friend</td></tr>
<tr><td><code>dc:</code></td><td><code>http://purl.org/dc/elements/1.1/</code></td><td>Dublin Core</td></tr>
<tr><td><code>schema:</code></td><td><code>https://schema.org/</code></td><td>Schema.org</td></tr>
</tbody></table>
</div>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { useTurtle, initStore } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const turtle = useTurtle('./graph');

  // Parse with automatic prefix handling
  const store = turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

    ex:alice a foaf:Person ;
             foaf:name "Alice Smith" ;
             foaf:age 30 .
  `);

  // Serialize with prefixes
  const output = turtle.serialize({
    prefixes: {
      ex: 'http://example.org/',
      foaf: 'http://xmlns.com/foaf/0.1/'
    }
  });

  console.log(output);
});
</code></pre>
<h2 id="rdf-serialization-formats-1"><a class="header" href="#rdf-serialization-formats-1">RDF Serialization Formats</a></h2>
<p>RDF can be represented in multiple formats:</p>
<h3 id="turtle-terse-rdf-triple-language-1"><a class="header" href="#turtle-terse-rdf-triple-language-1">Turtle (Terse RDF Triple Language)</a></h3>
<p>Human-readable, compact format:</p>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

ex:alice a foaf:Person ;
    foaf:name "Alice Smith" ;
    foaf:age 30 ;
    foaf:knows ex:bob .

ex:bob a foaf:Person ;
    foaf:name "Bob Jones" ;
    foaf:age 28 .
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Supports prefixes</li>
<li>Uses <code>;</code> to repeat subjects</li>
<li>Uses <code>,</code> to repeat subject+predicate</li>
<li><code>a</code> is shorthand for <code>rdf:type</code></li>
</ul>
<h3 id="n-quads-1"><a class="header" href="#n-quads-1">N-Quads</a></h3>
<p>Line-based format for quads:</p>
<pre><code class="language-nquads">&lt;http://example.org/alice&gt; &lt;http://www.w3.org/1999/02/22-rdf-syntax-ns#type&gt; &lt;http://xmlns.com/foaf/0.1/Person&gt; .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/name&gt; "Alice Smith" .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/age&gt; "30"^^&lt;http://www.w3.org/2001/XMLSchema#integer&gt; .
&lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; &lt;http://example.org/bob&gt; &lt;http://example.org/graph/social&gt; .
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>One quad per line</li>
<li>No prefixes (full URIs)</li>
<li>Fourth element for named graphs</li>
<li>Machine-optimized</li>
</ul>
<h3 id="json-ld-1"><a class="header" href="#json-ld-1">JSON-LD</a></h3>
<p>JSON format for linked data:</p>
<pre><code class="language-json">{
  "@context": {
    "foaf": "http://xmlns.com/foaf/0.1/",
    "ex": "http://example.org/"
  },
  "@id": "ex:alice",
  "@type": "foaf:Person",
  "foaf:name": "Alice Smith",
  "foaf:age": 30,
  "foaf:knows": {
    "@id": "ex:bob"
  }
}
</code></pre>
<p><strong>Features:</strong></p>
<ul>
<li>Standard JSON syntax</li>
<li><code>@context</code> for namespace mapping</li>
<li><code>@id</code> for URIs</li>
<li><code>@type</code> for rdf:type</li>
<li>Easy integration with web APIs</li>
</ul>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { parseTurtle, toNQuads, toJsonLd } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  // Parse Turtle
  const turtleData = `
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

    ex:alice foaf:name "Alice" .
  `;

  const store = await parseTurtle(turtleData);

  // Convert to N-Quads
  const nquads = await toNQuads(store);
  console.log(nquads);

  // Convert to JSON-LD
  const jsonld = await toJsonLd(store);
  console.log(JSON.stringify(jsonld, null, 2));
});
</code></pre>
<h2 id="practical-examples-1"><a class="header" href="#practical-examples-1">Practical Examples</a></h2>
<h3 id="example-1-social-network-1"><a class="header" href="#example-1-social-network-1">Example 1: Social Network</a></h3>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:alice a foaf:Person ;
    foaf:name "Alice Smith" ;
    foaf:age "30"^^xsd:integer ;
    foaf:mbox &lt;mailto:alice@example.org&gt; ;
    foaf:knows ex:bob, ex:carol .

ex:bob a foaf:Person ;
    foaf:name "Bob Jones" ;
    foaf:age "28"^^xsd:integer ;
    foaf:knows ex:alice .

ex:carol a foaf:Person ;
    foaf:name "Carol Williams" ;
    foaf:age "32"^^xsd:integer .
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">import { initStore, useStoreContext, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();
  const turtle = useTurtle('./graph');

  // Create nodes
  const alice = ctx.namedNode('http://example.org/alice');
  const bob = ctx.namedNode('http://example.org/bob');
  const foafName = ctx.namedNode('http://xmlns.com/foaf/0.1/name');
  const foafKnows = ctx.namedNode('http://xmlns.com/foaf/0.1/knows');

  // Create quads
  const quads = [
    ctx.quad(alice, foafName, ctx.literal('Alice Smith')),
    ctx.quad(alice, foafKnows, bob),
    ctx.quad(bob, foafName, ctx.literal('Bob Jones'))
  ];

  // Add to store
  quads.forEach(q =&gt; ctx.add(q));

  console.log(`Store contains ${ctx.store.size} quads`);

  // Save as Turtle
  turtle.save('social-network', {
    prefixes: {
      ex: 'http://example.org/',
      foaf: 'http://xmlns.com/foaf/0.1/'
    }
  });
});
</code></pre>
<h3 id="example-2-product-catalog-1"><a class="header" href="#example-2-product-catalog-1">Example 2: Product Catalog</a></h3>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix schema: &lt;https://schema.org/&gt; .
@prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

ex:product123 a schema:Product ;
    schema:name "Wireless Mouse" ;
    schema:description "Ergonomic wireless mouse with USB receiver" ;
    schema:price "29.99"^^xsd:decimal ;
    schema:priceCurrency "USD" ;
    schema:availability schema:InStock ;
    schema:brand [
        a schema:Brand ;
        schema:name "TechCo"
    ] .
</code></pre>
<p><strong>In UNRDF:</strong></p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Create product
  const product = ctx.namedNode('http://example.org/product123');
  const schemaProduct = ctx.namedNode('https://schema.org/Product');
  const schemaName = ctx.namedNode('https://schema.org/name');
  const schemaPrice = ctx.namedNode('https://schema.org/price');
  const schemaBrand = ctx.namedNode('https://schema.org/brand');
  const rdfType = ctx.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type');

  // Create brand (blank node)
  const brand = ctx.blankNode('brand');

  // Build graph
  ctx.add(
    ctx.quad(product, rdfType, schemaProduct),
    ctx.quad(product, schemaName, ctx.literal('Wireless Mouse')),
    ctx.quad(product, schemaPrice, ctx.literal('29.99', 'http://www.w3.org/2001/XMLSchema#decimal')),
    ctx.quad(product, schemaBrand, brand),
    ctx.quad(brand, schemaName, ctx.literal('TechCo'))
  );

  console.log(`Product catalog: ${ctx.store.size} quads`);
});
</code></pre>
<h2 id="best-practices-2"><a class="header" href="#best-practices-2">Best Practices</a></h2>
<h3 id="1-use-meaningful-uris-1"><a class="header" href="#1-use-meaningful-uris-1">1. Use Meaningful URIs</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Descriptive URIs
const person = ctx.namedNode('http://example.org/people/alice-smith');
const property = ctx.namedNode('http://example.org/schema/employeeId');

// ‚ùå Avoid: Opaque identifiers
const person = ctx.namedNode('http://example.org/p1');
const property = ctx.namedNode('http://example.org/x');
</code></pre>
<h3 id="2-choose-appropriate-datatypes-1"><a class="header" href="#2-choose-appropriate-datatypes-1">2. Choose Appropriate Datatypes</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Typed literals
const age = ctx.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');
const price = ctx.literal('19.99', 'http://www.w3.org/2001/XMLSchema#decimal');
const active = ctx.literal('true', 'http://www.w3.org/2001/XMLSchema#boolean');

// ‚ùå Avoid: Untyped when type matters
const age = ctx.literal('30');  // Treated as string
</code></pre>
<h3 id="3-use-standard-vocabularies-1"><a class="header" href="#3-use-standard-vocabularies-1">3. Use Standard Vocabularies</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Reuse standard vocabularies
import { FOAF, SCHEMA, DC } from 'unrdf/vocabularies';

const person = ctx.quad(
  ctx.namedNode('http://example.org/alice'),
  ctx.namedNode(FOAF.name),
  ctx.literal('Alice')
);

// ‚ùå Avoid: Creating custom vocabularies for common concepts
const customName = ctx.namedNode('http://example.org/hasName');
</code></pre>
<h3 id="4-organize-with-namespaces-1"><a class="header" href="#4-organize-with-namespaces-1">4. Organize with Namespaces</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Clear namespace organization
const prefixes = {
  ex: 'http://example.org/',
  foaf: 'http://xmlns.com/foaf/0.1/',
  schema: 'https://schema.org/',
  xsd: 'http://www.w3.org/2001/XMLSchema#'
};

// ‚ùå Avoid: Mixing namespaces inconsistently
</code></pre>
<h2 id="next-steps-4"><a class="header" href="#next-steps-4">Next Steps</a></h2>
<p>Now that you understand RDF fundamentals:</p>
<ol>
<li><strong><a href="concepts/./store-context.html">Store Context Pattern</a></strong> - Learn how UNRDF manages state</li>
<li><strong><a href="concepts/./composables.html">Composables</a></strong> - Explore UNRDF's composable functions</li>
<li><strong><a href="concepts/./transactions.html">Transactions</a></strong> - Master atomic operations</li>
</ol>
<h2 id="summary-1"><a class="header" href="#summary-1">Summary</a></h2>
<ul>
<li><strong>RDF</strong> is a graph-based data model using triples (subject-predicate-object)</li>
<li><strong>Terms</strong> include URIs (resources), Literals (values), and Blank Nodes (anonymous)</li>
<li><strong>Quads</strong> extend triples with graph context</li>
<li><strong>Namespaces</strong> shorten URIs and organize vocabularies</li>
<li><strong>Formats</strong> include Turtle (human), N-Quads (machine), JSON-LD (web)</li>
<li><strong>UNRDF</strong> provides a composable, type-safe API for RDF operations</li>
</ul>
<p>The composable nature of UNRDF makes it easy to work with RDF while maintaining clean, maintainable code.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composables"><a class="header" href="#composables">Composables</a></h1>
<p>UNRDF provides a suite of <strong>composable functions</strong> that work seamlessly with the Store Context. Each composable has a specific purpose and can be combined to build powerful RDF applications.</p>
<h2 id="what-are-composables"><a class="header" href="#what-are-composables">What are Composables?</a></h2>
<p>Composables are reusable functions that:</p>
<ol>
<li><strong>Access the Store Context</strong> automatically (no parameters needed)</li>
<li><strong>Provide focused APIs</strong> for specific RDF operations</li>
<li><strong>Compose together</strong> to build complex workflows</li>
<li><strong>Maintain type safety</strong> through JSDoc annotations</li>
<li><strong>Follow async/await</strong> patterns consistently</li>
</ol>
<p>Think of composables as <strong>specialized tools</strong> in your RDF toolkit‚Äîeach designed for a specific task, all sharing the same underlying store.</p>
<h2 id="core-composables"><a class="header" href="#core-composables">Core Composables</a></h2>
<h3 id="usestorecontext"><a class="header" href="#usestorecontext"><code>useStoreContext()</code></a></h3>
<p>The foundation composable that provides direct store access.</p>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();

  // Access underlying N3.Store
  console.log(ctx.store.size);

  // Create terms
  const person = ctx.namedNode('http://example.org/alice');
  const name = ctx.literal('Alice');

  // Add/remove quads
  ctx.add(ctx.quad(person, ctx.namedNode('http://xmlns.com/foaf/0.1/name'), name));
  ctx.remove(someQuad);
  ctx.clear();

  // Get statistics
  const stats = ctx.stats();

  // Serialize
  const turtle = ctx.serialize({ format: 'Turtle' });
});
</code></pre>
<p><strong>When to use:</strong></p>
<ul>
<li>Direct store manipulation</li>
<li>Term creation</li>
<li>Low-level operations</li>
<li>Custom logic</li>
</ul>
<h2 id="usegraph---sparql--graph-operations"><a class="header" href="#usegraph---sparql--graph-operations"><code>useGraph()</code> - SPARQL &amp; Graph Operations</a></h2>
<p>High-level interface for querying and manipulating RDF graphs.</p>
<p><strong>Source Reference</strong> (<code>src/composables/use-graph.mjs</code>)</p>
<h3 id="basic-usage-1"><a class="header" href="#basic-usage-1">Basic Usage</a></h3>
<pre><code class="language-javascript">import { initStore, useGraph } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const graph = useGraph();

  // Execute SPARQL SELECT
  const results = await graph.select(`
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

    SELECT ?name ?age WHERE {
      ?person foaf:name ?name ;
              foaf:age ?age .
    }
  `);

  console.log(results);
  // [{ name: 'Alice', age: 30 }, { name: 'Bob', age: 28 }]
});
</code></pre>
<h3 id="query-methods"><a class="header" href="#query-methods">Query Methods</a></h3>
<h4 id="querysparql-options---execute-any-sparql-query"><a class="header" href="#querysparql-options---execute-any-sparql-query"><code>query(sparql, options)</code> - Execute Any SPARQL Query</a></h4>
<pre><code class="language-javascript">const result = await graph.query(`
  SELECT ?s ?p ?o WHERE { ?s ?p ?o }
`, {
  limit: 100,
  signal: abortController.signal  // For cancellation
});
</code></pre>
<h4 id="selectsparql---execute-select-query"><a class="header" href="#selectsparql---execute-select-query"><code>select(sparql)</code> - Execute SELECT Query</a></h4>
<pre><code class="language-javascript">const rows = await graph.select(`
  PREFIX ex: &lt;http://example.org/&gt;

  SELECT ?name WHERE {
    ?person ex:name ?name .
  }
`);

// Returns: [{ name: 'Alice' }, { name: 'Bob' }]
</code></pre>
<h4 id="asksparql---execute-ask-query"><a class="header" href="#asksparql---execute-ask-query"><code>ask(sparql)</code> - Execute ASK Query</a></h4>
<pre><code class="language-javascript">const exists = await graph.ask(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

  ASK {
    ?person foaf:name "Alice" .
  }
`);

console.log(exists);  // true or false
</code></pre>
<h4 id="constructsparql---execute-construct-query"><a class="header" href="#constructsparql---execute-construct-query"><code>construct(sparql)</code> - Execute CONSTRUCT Query</a></h4>
<pre><code class="language-javascript">const newStore = await graph.construct(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  PREFIX ex: &lt;http://example.org/&gt;

  CONSTRUCT {
    ?person ex:hasName ?name .
  } WHERE {
    ?person foaf:name ?name .
  }
`);

console.log(newStore.size);  // Number of constructed triples
</code></pre>
<h4 id="updatesparql---execute-update-query"><a class="header" href="#updatesparql---execute-update-query"><code>update(sparql)</code> - Execute UPDATE Query</a></h4>
<pre><code class="language-javascript">await graph.update(`
  PREFIX ex: &lt;http://example.org/&gt;
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

  INSERT DATA {
    ex:charlie foaf:name "Charlie" .
  }
`);
</code></pre>
<h3 id="graph-operations"><a class="header" href="#graph-operations">Graph Operations</a></h3>
<h4 id="uniongraphs---combine-graphs"><a class="header" href="#uniongraphs---combine-graphs"><code>union(...graphs)</code> - Combine Graphs</a></h4>
<pre><code class="language-javascript">const graph1 = useGraph();
const graph2 = useGraph();

// Union of graphs
const combined = graph1.union(graph2);
console.log(combined.size);
</code></pre>
<h4 id="intersectiongraph---find-common-quads"><a class="header" href="#intersectiongraph---find-common-quads"><code>intersection(graph)</code> - Find Common Quads</a></h4>
<pre><code class="language-javascript">const common = graph1.intersection(graph2);
console.log(`${common.size} shared quads`);
</code></pre>
<h4 id="differencegraph---find-unique-quads"><a class="header" href="#differencegraph---find-unique-quads"><code>difference(graph)</code> - Find Unique Quads</a></h4>
<pre><code class="language-javascript">const unique = graph1.difference(graph2);
console.log(`${unique.size} quads only in graph1`);
</code></pre>
<h3 id="validation"><a class="header" href="#validation">Validation</a></h3>
<h4 id="validateshapesinput---shacl-validation"><a class="header" href="#validateshapesinput---shacl-validation"><code>validate(shapesInput)</code> - SHACL Validation</a></h4>
<pre><code class="language-javascript">const shapes = await parseTurtle(`
  @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
  @prefix ex: &lt;http://example.org/&gt; .
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

  ex:PersonShape a sh:NodeShape ;
    sh:targetClass foaf:Person ;
    sh:property [
      sh:path foaf:name ;
      sh:minCount 1 ;
      sh:datatype xsd:string ;
    ] .
`);

const report = graph.validate(shapes);

if (!report.conforms) {
  console.log('Validation errors:', report.results);
}
</code></pre>
<h4 id="validateorthrowshapesinput---validate-or-throw"><a class="header" href="#validateorthrowshapesinput---validate-or-throw"><code>validateOrThrow(shapesInput)</code> - Validate or Throw</a></h4>
<pre><code class="language-javascript">try {
  graph.validateOrThrow(shapes);
  console.log('Valid!');
} catch (err) {
  console.error('Validation failed:', err.message);
}
</code></pre>
<h3 id="serialization--stats"><a class="header" href="#serialization--stats">Serialization &amp; Stats</a></h3>
<pre><code class="language-javascript">// Serialize to Turtle
const turtle = graph.serialize({
  format: 'Turtle',
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  }
});

// Serialize to N-Quads
const nquads = graph.serialize({ format: 'N-Quads' });

// Get statistics
const stats = graph.stats();
console.log(stats);
// { quads: 100, subjects: 50, predicates: 10, objects: 80, graphs: 1 }

// Get size
console.log(graph.size);  // Number of quads
</code></pre>
<h2 id="useturtle---file-io-operations"><a class="header" href="#useturtle---file-io-operations"><code>useTurtle()</code> - File I/O Operations</a></h2>
<p>Manage Turtle files with automatic parsing and serialization.</p>
<p><strong>Source Reference</strong> (<code>src/composables/use-turtle.mjs</code>)</p>
<h3 id="basic-usage-2"><a class="header" href="#basic-usage-2">Basic Usage</a></h3>
<pre><code class="language-javascript">import { initStore, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const turtle = useTurtle('./graph', {
    baseIRI: 'http://example.org/',
    autoLoad: true,
    validateOnLoad: true
  });

  // Load all .ttl files
  const { loaded, files } = turtle.loadAll();
  console.log(`Loaded ${loaded} files:`, files);

  // Save to file
  turtle.save('people', {
    prefixes: {
      ex: 'http://example.org/',
      foaf: 'http://xmlns.com/foaf/0.1/'
    },
    createBackup: true
  });
});
</code></pre>
<h3 id="file-operations"><a class="header" href="#file-operations">File Operations</a></h3>
<h4 id="loadalloptions---load-all-turtle-files"><a class="header" href="#loadalloptions---load-all-turtle-files"><code>loadAll(options)</code> - Load All Turtle Files</a></h4>
<pre><code class="language-javascript">const result = turtle.loadAll({
  merge: true,      // Merge with existing store
  validate: true    // Validate on load
});

console.log(`Loaded ${result.loaded} files`);
console.log('Files:', result.files);
</code></pre>
<h4 id="loadfilename-options---load-specific-file"><a class="header" href="#loadfilename-options---load-specific-file"><code>load(fileName, options)</code> - Load Specific File</a></h4>
<pre><code class="language-javascript">const store = turtle.load('people', {
  merge: true,
  validate: true
});
</code></pre>
<h4 id="savefilename-options---save-to-file"><a class="header" href="#savefilename-options---save-to-file"><code>save(fileName, options)</code> - Save to File</a></h4>
<pre><code class="language-javascript">turtle.save('output', {
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  },
  createBackup: true
});
</code></pre>
<h4 id="savedefault--loaddefault---default-file"><a class="header" href="#savedefault--loaddefault---default-file"><code>saveDefault()</code> / <code>loadDefault()</code> - Default File</a></h4>
<pre><code class="language-javascript">// Save to default.ttl
turtle.saveDefault();

// Load from default.ttl
const store = turtle.loadDefault();
</code></pre>
<h3 id="parsing--serialization"><a class="header" href="#parsing--serialization">Parsing &amp; Serialization</a></h3>
<h4 id="parsettl-options---parse-turtle-string"><a class="header" href="#parsettl-options---parse-turtle-string"><code>parse(ttl, options)</code> - Parse Turtle String</a></h4>
<pre><code class="language-javascript">const store = turtle.parse(`
  @prefix ex: &lt;http://example.org/&gt; .
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

  ex:alice foaf:name "Alice" .
`, {
  addToStore: true  // Add parsed quads to context store
});
</code></pre>
<h4 id="serializeoptions---serialize-to-turtle"><a class="header" href="#serializeoptions---serialize-to-turtle"><code>serialize(options)</code> - Serialize to Turtle</a></h4>
<pre><code class="language-javascript">const turtleString = turtle.serialize({
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  }
});

console.log(turtleString);
</code></pre>
<h3 id="utility-methods"><a class="header" href="#utility-methods">Utility Methods</a></h3>
<pre><code class="language-javascript">// List all .ttl files
const files = turtle.listFiles();
console.log('Turtle files:', files);

// Get statistics
const stats = turtle.stats();

// Clear store
turtle.clear();

// Access properties
console.log(turtle.graphDir);   // './graph'
console.log(turtle.engine);      // RdfEngine instance
console.log(turtle.store);       // StoreContext
</code></pre>
<h2 id="usedelta---graph-diff--patch"><a class="header" href="#usedelta---graph-diff--patch"><code>useDelta()</code> - Graph Diff &amp; Patch</a></h2>
<p>Track changes and apply patches to RDF graphs.</p>
<p><strong>Source Reference</strong> (<code>src/composables/use-delta.mjs</code>)</p>
<h3 id="basic-usage-3"><a class="header" href="#basic-usage-3">Basic Usage</a></h3>
<pre><code class="language-javascript">import { initStore, useDelta, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const delta = useDelta({ deterministic: true });
  const turtle = useTurtle();

  // Original data
  turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    ex:alice ex:age 30 .
  `, { addToStore: true });

  // New data
  const newData = turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    ex:alice ex:age 31 .
    ex:bob ex:age 28 .
  `);

  // Compare
  const changes = delta.compareWith(newData);

  console.log(`Added: ${changes.addedCount} quads`);
  console.log(`Removed: ${changes.removedCount} quads`);
});
</code></pre>
<h3 id="comparison-methods"><a class="header" href="#comparison-methods">Comparison Methods</a></h3>
<h4 id="comparewithnewstore---compare-stores"><a class="header" href="#comparewithnewstore---compare-stores"><code>compareWith(newStore)</code> - Compare Stores</a></h4>
<pre><code class="language-javascript">const changes = delta.compareWith(newStore);

console.log(changes);
// {
//   added: Store,           // Quads to add
//   removed: Store,         // Quads to remove
//   addedCount: 2,
//   removedCount: 1,
//   unchangedCount: 5,
//   contextSize: 6,
//   newDataSize: 7
// }
</code></pre>
<h4 id="syncwithnewstore-options---sync-stores"><a class="header" href="#syncwithnewstore-options---sync-stores"><code>syncWith(newStore, options)</code> - Sync Stores</a></h4>
<pre><code class="language-javascript">const result = delta.syncWith(newStore, {
  dryRun: false  // Set true to preview without applying
});

console.log(`Synced: +${result.added} -${result.removed}`);
</code></pre>
<h3 id="applying-changes"><a class="header" href="#applying-changes">Applying Changes</a></h3>
<h4 id="applychanges-options---apply-changes"><a class="header" href="#applychanges-options---apply-changes"><code>apply(changes, options)</code> - Apply Changes</a></h4>
<pre><code class="language-javascript">const result = delta.apply(changes, {
  dryRun: false
});

console.log(result);
// {
//   success: true,
//   added: 2,
//   removed: 1,
//   originalSize: 6,
//   finalSize: 7,
//   dryRun: false
// }
</code></pre>
<h3 id="change-analysis"><a class="header" href="#change-analysis">Change Analysis</a></h3>
<h4 id="getstatschanges---get-change-statistics"><a class="header" href="#getstatschanges---get-change-statistics"><code>getStats(changes)</code> - Get Change Statistics</a></h4>
<pre><code class="language-javascript">const stats = delta.getStats(changes);

console.log(stats);
// {
//   added: { quads: 2, subjects: 1, predicates: 1, objects: 2 },
//   removed: { quads: 1, subjects: 1, predicates: 1, objects: 1 },
//   total: { quads: 3, netChange: 1 },
//   coverage: {
//     addedSubjects: ['http://example.org/bob'],
//     removedSubjects: [],
//     addedPredicates: ['http://example.org/age'],
//     removedPredicates: []
//   }
// }
</code></pre>
<h4 id="isemptychanges---check-if-empty"><a class="header" href="#isemptychanges---check-if-empty"><code>isEmpty(changes)</code> - Check if Empty</a></h4>
<pre><code class="language-javascript">if (delta.isEmpty(changes)) {
  console.log('No changes detected');
}
</code></pre>
<h3 id="patch-operations"><a class="header" href="#patch-operations">Patch Operations</a></h3>
<h4 id="createpatchchanges-options---create-patch"><a class="header" href="#createpatchchanges-options---create-patch"><code>createPatch(changes, options)</code> - Create Patch</a></h4>
<pre><code class="language-javascript">const patch = delta.createPatch(changes, {
  format: 'Turtle'  // or 'N-Quads'
});

console.log(patch);
// {
//   added: '...',       // Turtle/N-Quads string
//   removed: '...',     // Turtle/N-Quads string
//   addedCount: 2,
//   removedCount: 1,
//   format: 'Turtle',
//   stats: { ... }
// }
</code></pre>
<h4 id="applypatchpatch-options---apply-patch"><a class="header" href="#applypatchpatch-options---apply-patch"><code>applyPatch(patch, options)</code> - Apply Patch</a></h4>
<pre><code class="language-javascript">const result = delta.applyPatch(patch, {
  dryRun: false
});
</code></pre>
<h3 id="advanced-operations"><a class="header" href="#advanced-operations">Advanced Operations</a></h3>
<h4 id="mergechangesets---merge-changes"><a class="header" href="#mergechangesets---merge-changes"><code>merge(...changeSets)</code> - Merge Changes</a></h4>
<pre><code class="language-javascript">const merged = delta.merge(changes1, changes2, changes3);

console.log(`Total changes: ${merged.added.size + merged.removed.size}`);
</code></pre>
<h4 id="invertchanges---invert-changes"><a class="header" href="#invertchanges---invert-changes"><code>invert(changes)</code> - Invert Changes</a></h4>
<pre><code class="language-javascript">const inverted = delta.invert(changes);

// Apply and rollback
delta.apply(changes);       // Apply changes
delta.apply(inverted);      // Rollback
</code></pre>
<h2 id="useterms---term-creation-helpers"><a class="header" href="#useterms---term-creation-helpers"><code>useTerms()</code> - Term Creation Helpers</a></h2>
<p>Simplified term creation with namespace support.</p>
<pre><code class="language-javascript">import { initStore, useTerms } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const terms = useTerms();

  // Create terms
  const person = terms.iri('http://example.org/alice');
  const name = terms.lit('Alice');
  const age = terms.lit('30', 'http://www.w3.org/2001/XMLSchema#integer');
  const blank = terms.blank('b1');

  // Create quad
  const quad = terms.quad(person,
    terms.iri('http://xmlns.com/foaf/0.1/name'),
    name
  );
});
</code></pre>
<h2 id="usereasoner---owl-reasoning"><a class="header" href="#usereasoner---owl-reasoning"><code>useReasoner()</code> - OWL Reasoning</a></h2>
<p>Perform inference and reasoning over RDF graphs.</p>
<pre><code class="language-javascript">import { initStore, useReasoner, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const reasoner = useReasoner();
  const turtle = useTurtle();

  // Load ontology
  turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix owl: &lt;http://www.w3.org/2002/07/owl#&gt; .
    @prefix rdfs: &lt;http://www.w3.org/2000/01/rdf-schema#&gt; .

    ex:Student rdfs:subClassOf ex:Person .
    ex:alice a ex:Student .
  `, { addToStore: true });

  // Perform reasoning
  const inferred = await reasoner.reason();

  console.log(`Inferred ${inferred.size} new triples`);
  // ex:alice a ex:Person (inferred from subclass)
});
</code></pre>
<h2 id="usecanon---canonicalization"><a class="header" href="#usecanon---canonicalization"><code>useCanon()</code> - Canonicalization</a></h2>
<p>Canonicalize graphs using URDNA2015 algorithm.</p>
<pre><code class="language-javascript">import { initStore, useCanon } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const canon = useCanon();

  // Canonicalize current store
  const canonical = await canon.canonicalize();

  console.log(canonical);  // Canonical N-Quads

  // Generate hash
  const hash = await canon.hash();
  console.log(`Graph hash: ${hash}`);

  // Check isomorphism
  const isIso = await canon.isIsomorphic(otherStore);
  console.log(`Isomorphic: ${isIso}`);
});
</code></pre>
<h2 id="usezod---type-safety-integration"><a class="header" href="#usezod---type-safety-integration"><code>useZod()</code> - Type Safety Integration</a></h2>
<p>Bridge RDF and Zod schemas for runtime validation.</p>
<pre><code class="language-javascript">import { z } from 'zod';
import { initStore, useZod } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const zodHelper = useZod();

  // Define schema
  const PersonSchema = z.object({
    id: z.string().url(),
    name: z.string().min(1),
    age: z.number().int().min(0).max(150).optional(),
    email: z.string().email().optional()
  });

  // Convert object to RDF
  const person = {
    id: 'http://example.org/alice',
    name: 'Alice Smith',
    age: 30,
    email: 'alice@example.org'
  };

  const quads = zodHelper.toRdf(person, PersonSchema);

  // Convert RDF back to object
  const reconstructed = zodHelper.fromRdf(quads, PersonSchema);

  console.log(reconstructed);
  // { id: '...', name: 'Alice Smith', age: 30, email: '...' }
});
</code></pre>
<h2 id="composable-composition"><a class="header" href="#composable-composition">Composable Composition</a></h2>
<p>The power of composables comes from <strong>combining them</strong>:</p>
<h3 id="example-complete-etl-pipeline"><a class="header" href="#example-complete-etl-pipeline">Example: Complete ETL Pipeline</a></h3>
<pre><code class="language-javascript">import {
  initStore,
  useTurtle,
  useGraph,
  useDelta,
  useCanon
} from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const turtle = useTurtle('./data');
  const graph = useGraph();
  const delta = useDelta();
  const canon = useCanon();

  // 1. Load data
  turtle.loadAll();

  // 2. Query and validate
  const people = await graph.select(`
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    SELECT ?name WHERE {
      ?person foaf:name ?name .
    }
  `);

  // 3. Transform
  const transformed = await graph.construct(`
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    PREFIX ex: &lt;http://example.org/&gt;
    CONSTRUCT {
      ?person ex:fullName ?name .
    } WHERE {
      ?person foaf:name ?name .
    }
  `);

  // 4. Track changes
  const changes = delta.compareWith(transformed);
  console.log(`Changes: +${changes.addedCount} -${changes.removedCount}`);

  // 5. Generate hash
  const hash = await canon.hash();
  console.log(`Data hash: ${hash}`);

  // 6. Save result
  turtle.save('output');
});
</code></pre>
<h3 id="example-data-validation-pipeline"><a class="header" href="#example-data-validation-pipeline">Example: Data Validation Pipeline</a></h3>
<pre><code class="language-javascript">runApp(async () =&gt; {
  const turtle = useTurtle('./data');
  const graph = useGraph();

  // Load data
  turtle.load('people');

  // Load SHACL shapes
  const shapes = await turtle.parse(`
    @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
    # ... shapes ...
  `);

  // Validate
  const report = graph.validate(shapes);

  if (!report.conforms) {
    console.error('Validation failed');
    for (const result of report.results) {
      console.log(`- ${result.message}`);
    }
    return;
  }

  console.log('‚úì Data is valid');

  // Process valid data
  // ...
});
</code></pre>
<h2 id="best-practices-3"><a class="header" href="#best-practices-3">Best Practices</a></h2>
<h3 id="1-choose-the-right-composable"><a class="header" href="#1-choose-the-right-composable">1. Choose the Right Composable</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Use specific composables
const graph = useGraph();        // For queries
const turtle = useTurtle();      // For file I/O
const delta = useDelta();        // For diffs

// ‚ùå Avoid: Using wrong composable
const ctx = useStoreContext();
// Don't manually implement what composables provide
</code></pre>
<h3 id="2-combine-composables"><a class="header" href="#2-combine-composables">2. Combine Composables</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Combine multiple composables
runApp(() =&gt; {
  const turtle = useTurtle('./data');
  const graph = useGraph();
  const delta = useDelta();

  turtle.loadAll();
  const results = await graph.select('...');
  const changes = delta.compareWith(newData);
});

// ‚ùå Avoid: Reinventing functionality
runApp(() =&gt; {
  const ctx = useStoreContext();
  // Manually implementing query logic
});
</code></pre>
<h3 id="3-use-inside-context"><a class="header" href="#3-use-inside-context">3. Use Inside Context</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Composables inside runApp()
const runApp = initStore();
runApp(() =&gt; {
  const graph = useGraph();
  // Use composable
});

// ‚ùå Avoid: Outside context
const graph = useGraph();  // Error!
</code></pre>
<h3 id="4-leverage-asyncawait"><a class="header" href="#4-leverage-asyncawait">4. Leverage Async/Await</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Use async/await
runApp(async () =&gt; {
  const results = await graph.select('...');
  const canonical = await canon.canonicalize();
});

// ‚ùå Avoid: Mixing callbacks
runApp(() =&gt; {
  graph.select('...').then(results =&gt; {
    // Harder to read
  });
});
</code></pre>
<h2 id="creating-custom-composables"><a class="header" href="#creating-custom-composables">Creating Custom Composables</a></h2>
<p>You can create your own composables following the pattern:</p>
<pre><code class="language-javascript">import { useStoreContext } from 'unrdf';

export function useMyCustomComposable(options = {}) {
  // Access store context
  const ctx = useStoreContext();

  return {
    // Your custom methods
    doSomething() {
      // Use ctx.store, ctx.add, etc.
    },

    doSomethingElse() {
      // ...
    }
  };
}

// Usage
const runApp = initStore();
runApp(() =&gt; {
  const custom = useMyCustomComposable({ option: 'value' });
  custom.doSomething();
});
</code></pre>
<h2 id="summary-2"><a class="header" href="#summary-2">Summary</a></h2>
<ul>
<li><strong>Composables</strong> are reusable functions for RDF operations</li>
<li><strong><code>useGraph()</code></strong> - SPARQL queries and graph operations</li>
<li><strong><code>useTurtle()</code></strong> - File I/O with Turtle format</li>
<li><strong><code>useDelta()</code></strong> - Graph diffs and patches</li>
<li><strong><code>useTerms()</code></strong> - Term creation helpers</li>
<li><strong><code>useReasoner()</code></strong> - OWL reasoning and inference</li>
<li><strong><code>useCanon()</code></strong> - Canonicalization and hashing</li>
<li><strong><code>useZod()</code></strong> - Type safety with Zod schemas</li>
<li><strong>Composition</strong> - Combine composables for complex workflows</li>
<li><strong>Context-Aware</strong> - All composables share the same store</li>
</ul>
<p>Each composable is focused, composable, and type-safe, making UNRDF development clean and maintainable.</p>
<h2 id="next-steps-5"><a class="header" href="#next-steps-5">Next Steps</a></h2>
<ul>
<li><strong><a href="concepts/./transactions.html">Transactions</a></strong> - Learn about atomic operations</li>
<li><strong><a href="concepts/./store-context.html">Store Context</a></strong> - Review context management</li>
<li><strong><a href="concepts/./rdf-fundamentals.html">RDF Fundamentals</a></strong> - RDF basics</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="store-context-pattern"><a class="header" href="#store-context-pattern">Store Context Pattern</a></h1>
<p>UNRDF uses a <strong>context-based architecture</strong> powered by <a href="https://github.com/unjs/unctx">unctx</a> to manage RDF stores across async operations. This chapter explains the Store Context pattern and how it enables clean, composable RDF applications.</p>
<h2 id="the-problem-shared-state-in-rdf"><a class="header" href="#the-problem-shared-state-in-rdf">The Problem: Shared State in RDF</a></h2>
<p>Traditional RDF libraries face a common challenge:</p>
<pre><code class="language-javascript">// ‚ùå Problem: Passing stores everywhere
function createPerson(store, name) {
  // Need to pass store to every function
}

function queryPeople(store) {
  // Store coupling throughout codebase
}

function validateData(store, shapes) {
  // Tight coupling to store instance
}
</code></pre>
<p>This approach leads to:</p>
<ul>
<li><strong>Boilerplate</strong>: Passing stores as parameters everywhere</li>
<li><strong>Coupling</strong>: Functions tightly bound to store instances</li>
<li><strong>Async Issues</strong>: Context lost across async boundaries</li>
<li><strong>Testing Complexity</strong>: Mocking and isolating becomes difficult</li>
</ul>
<h2 id="the-solution-store-context"><a class="header" href="#the-solution-store-context">The Solution: Store Context</a></h2>
<p>UNRDF solves this with <strong>async-aware context</strong> using unctx:</p>
<pre><code class="language-javascript">import { initStore, useStoreContext, useGraph } from 'unrdf';

// Initialize context once
const runApp = initStore();

// All operations use the same store automatically
runApp(() =&gt; {
  const ctx = useStoreContext();  // Access store anywhere
  const graph = useGraph();        // Composables share context

  // No need to pass store around!
});
</code></pre>
<h3 id="key-benefits"><a class="header" href="#key-benefits">Key Benefits</a></h3>
<ol>
<li><strong>Context Preservation</strong>: Works across async/await boundaries</li>
<li><strong>Composability</strong>: Functions don't need store parameters</li>
<li><strong>Type Safety</strong>: Context ensures store is always available</li>
<li><strong>Isolation</strong>: Each context is independent (great for testing)</li>
<li><strong>Performance</strong>: Single store instance, minimal overhead</li>
</ol>
<h2 id="core-concepts"><a class="header" href="#core-concepts">Core Concepts</a></h2>
<h3 id="1-initstore---context-initialization"><a class="header" href="#1-initstore---context-initialization">1. <code>initStore()</code> - Context Initialization</a></h3>
<p>Creates a store context and returns a function to run code within that context:</p>
<pre><code class="language-javascript">import { initStore } from 'unrdf';

// Initialize with empty store
const runApp = initStore();

// Initialize with initial quads
const runApp = initStore([quad1, quad2, quad3]);

// Initialize with options
const runApp = initStore([], {
  baseIRI: 'http://example.org/'
});
</code></pre>
<p><strong>Source Reference</strong> (<code>src/context/index.mjs:473-479</code>):</p>
<pre><code class="language-javascript">export function initStore(initialQuads = [], options = {}) {
  const context = createStoreContext(initialQuads, options);

  return (fn) =&gt; {
    return storeContext.callAsync(context, fn);
  };
}
</code></pre>
<h3 id="2-runapp---context-execution"><a class="header" href="#2-runapp---context-execution">2. <code>runApp()</code> - Context Execution</a></h3>
<p>The function returned by <code>initStore()</code> executes code within the store context:</p>
<pre><code class="language-javascript">const runApp = initStore();

// Everything inside this callback has access to the store
runApp(() =&gt; {
  // Store context is active here
  const ctx = useStoreContext();
  const graph = useGraph();

  // All operations use the same store
});
</code></pre>
<h3 id="3-usestorecontext---context-access"><a class="header" href="#3-usestorecontext---context-access">3. <code>useStoreContext()</code> - Context Access</a></h3>
<p>Access the current store context from anywhere:</p>
<pre><code class="language-javascript">import { useStoreContext } from 'unrdf';

function addPerson(name, age) {
  // Access store from context - no parameters needed!
  const ctx = useStoreContext();

  const person = ctx.namedNode(`http://example.org/people/${name}`);
  const foafName = ctx.namedNode('http://xmlns.com/foaf/0.1/name');
  const foafAge = ctx.namedNode('http://xmlns.com/foaf/0.1/age');

  ctx.add(
    ctx.quad(person, foafName, ctx.literal(name)),
    ctx.quad(person, foafAge, ctx.literal(String(age), 'http://www.w3.org/2001/XMLSchema#integer'))
  );
}

const runApp = initStore();
runApp(() =&gt; {
  addPerson('Alice', 30);  // No store parameter!
  addPerson('Bob', 28);

  const ctx = useStoreContext();
  console.log(`Store size: ${ctx.store.size}`);  // 4 quads
});
</code></pre>
<h2 id="context-api"><a class="header" href="#context-api">Context API</a></h2>
<p>The <code>StoreContext</code> provides both <strong>SENDER</strong> (write) and <strong>READER</strong> (read) operations:</p>
<h3 id="sender-operations-primary"><a class="header" href="#sender-operations-primary">SENDER Operations (Primary)</a></h3>
<p>These operations modify the store:</p>
<pre><code class="language-javascript">const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();

  // Add quads to store
  ctx.add(quad1, quad2, quad3);

  // Remove quads from store
  ctx.remove(quad1);

  // Clear all quads
  ctx.clear();
});
</code></pre>
<p><strong>Source Reference</strong> (<code>src/context/index.mjs:107-155</code>):</p>
<pre><code class="language-javascript">/**
 * Add quads to the store (SENDER operation)
 */
add(...quads) {
  for (const q of quads) {
    if (q === null || q === undefined) {
      throw new TypeError("[StoreContext] Cannot add null or undefined quad");
    }
    if (typeof q !== "object" || !q.termType) {
      throw new TypeError("[StoreContext] Invalid quad");
    }
    store.add(q);
  }
  return this;
},

/**
 * Remove quads from the store (SENDER operation)
 */
remove(...quads) {
  for (const q of quads) {
    if (q === null || q === undefined) {
      throw new TypeError("[StoreContext] Cannot remove null or undefined quad");
    }
    if (typeof q !== "object" || !q.termType) {
      throw new TypeError("[StoreContext] Invalid quad");
    }
    store.delete(q);
  }
  return this;
},
</code></pre>
<h3 id="term-creation"><a class="header" href="#term-creation">Term Creation</a></h3>
<p>Create RDF terms (URIs, literals, blank nodes, quads):</p>
<pre><code class="language-javascript">runApp(() =&gt; {
  const ctx = useStoreContext();

  // Create named node (URI)
  const person = ctx.namedNode('http://example.org/alice');

  // Create literal (string value)
  const name = ctx.literal('Alice Smith');

  // Create typed literal
  const age = ctx.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');

  // Create blank node
  const address = ctx.blankNode('addr1');

  // Create quad
  const quad = ctx.quad(person,
    ctx.namedNode('http://xmlns.com/foaf/0.1/name'),
    name
  );
});
</code></pre>
<h3 id="reader-operations-optional"><a class="header" href="#reader-operations-optional">READER Operations (Optional)</a></h3>
<p>These operations query the store:</p>
<pre><code class="language-javascript">runApp(async () =&gt; {
  const ctx = useStoreContext();

  // Get store statistics
  const stats = ctx.stats();
  console.log(stats);
  // { quads: 10, subjects: 5, predicates: 3, objects: 8, graphs: 1 }

  // Serialize store
  const turtle = ctx.serialize({ format: 'Turtle' });
  const nquads = ctx.serialize({ format: 'N-Quads' });

  // Execute SPARQL query
  const result = await ctx.query(`
    SELECT ?name WHERE {
      ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name .
    }
  `);

  // Canonicalize (for hash-based verification)
  const canonical = await ctx.canonicalize();

  // Generate hash
  const hash = await ctx.hash();
});
</code></pre>
<h2 id="context-isolation"><a class="header" href="#context-isolation">Context Isolation</a></h2>
<p>Each <code>runApp()</code> call creates an <strong>isolated context</strong>:</p>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

// Context 1
const runApp1 = initStore();
runApp1(() =&gt; {
  const ctx = useStoreContext();
  ctx.add(ctx.quad(
    ctx.namedNode('http://example.org/alice'),
    ctx.namedNode('http://xmlns.com/foaf/0.1/name'),
    ctx.literal('Alice')
  ));

  console.log(`App1 store size: ${ctx.store.size}`);  // 1
});

// Context 2 (completely independent)
const runApp2 = initStore();
runApp2(() =&gt; {
  const ctx = useStoreContext();
  console.log(`App2 store size: ${ctx.store.size}`);  // 0

  ctx.add(ctx.quad(
    ctx.namedNode('http://example.org/bob'),
    ctx.namedNode('http://xmlns.com/foaf/0.1/name'),
    ctx.literal('Bob')
  ));

  console.log(`App2 store size: ${ctx.store.size}`);  // 1
});

// App1 and App2 have separate stores!
</code></pre>
<p>This isolation is crucial for:</p>
<ul>
<li><strong>Testing</strong>: Each test gets a clean context</li>
<li><strong>Multi-tenancy</strong>: Separate data per user/request</li>
<li><strong>Modularity</strong>: Independent components</li>
</ul>
<h2 id="async-context-preservation"><a class="header" href="#async-context-preservation">Async Context Preservation</a></h2>
<p>The power of unctx is <strong>async context preservation</strong>:</p>
<pre><code class="language-javascript">const runApp = initStore();

runApp(async () =&gt; {
  const ctx = useStoreContext();

  // Add data
  ctx.add(ctx.quad(
    ctx.namedNode('http://example.org/alice'),
    ctx.namedNode('http://xmlns.com/foaf/0.1/name'),
    ctx.literal('Alice')
  ));

  // Context preserved across await!
  await new Promise(resolve =&gt; setTimeout(resolve, 100));

  // Still has access to the same store
  const ctx2 = useStoreContext();
  console.log(ctx === ctx2);  // true
  console.log(ctx.store.size);  // 1

  // Works with async functions
  async function queryData() {
    // Context automatically available
    const ctx = useStoreContext();
    return await ctx.query('SELECT ?s ?p ?o WHERE { ?s ?p ?o }');
  }

  const results = await queryData();
  console.log(results);
});
</code></pre>
<p><strong>Without async context</strong>, this would fail:</p>
<pre><code class="language-javascript">// ‚ùå Traditional approach loses context
let globalStore = new Store();

async function doWork() {
  await someAsyncOp();
  // globalStore might have changed!
  globalStore.add(quad);
}
</code></pre>
<h2 id="composable-integration"><a class="header" href="#composable-integration">Composable Integration</a></h2>
<p>All UNRDF composables use the store context automatically:</p>
<pre><code class="language-javascript">import {
  initStore,
  useStoreContext,
  useGraph,
  useTurtle,
  useDelta
} from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  // All composables share the same store
  const ctx = useStoreContext();
  const graph = useGraph();
  const turtle = useTurtle('./graph');
  const delta = useDelta();

  // Add data via context
  ctx.add(ctx.quad(
    ctx.namedNode('http://example.org/alice'),
    ctx.namedNode('http://xmlns.com/foaf/0.1/name'),
    ctx.literal('Alice')
  ));

  // Query via graph composable
  const results = await graph.select(`
    SELECT ?name WHERE {
      ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name .
    }
  `);

  console.log(results);  // [{ name: 'Alice' }]

  // Save via turtle composable
  turtle.save('people');

  // Track changes via delta composable
  const newData = await turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

    ex:alice foaf:age 30 .
  `);

  const changes = delta.compareWith(newData);
  console.log(`Added ${changes.addedCount} quads`);
});
</code></pre>
<p><strong>Source Reference</strong> (<code>src/composables/use-turtle.mjs:39-48</code>):</p>
<pre><code class="language-javascript">export function useTurtle(graphDir = "./graph", options = {}) {
  // Get the engine from context
  const storeContext = useStoreContext();
  const engine = storeContext.engine;

  // All operations use the context store
  return {
    get store() {
      return storeContext;
    },
    // ... methods use storeContext.store
  };
}
</code></pre>
<h2 id="memory-management"><a class="header" href="#memory-management">Memory Management</a></h2>
<p>The store context manages memory efficiently:</p>
<pre><code class="language-javascript">const runApp = initStore();

runApp(() =&gt; {
  const ctx = useStoreContext();

  // Add 1 million quads
  for (let i = 0; i &lt; 1_000_000; i++) {
    ctx.add(ctx.quad(
      ctx.namedNode(`http://example.org/item${i}`),
      ctx.namedNode('http://xmlns.com/foaf/0.1/name'),
      ctx.literal(`Item ${i}`)
    ));
  }

  console.log(`Store size: ${ctx.store.size}`);  // 1,000,000

  // Clear when done
  ctx.clear();

  console.log(`Store size: ${ctx.store.size}`);  // 0
});

// Context automatically cleaned up after runApp() completes
</code></pre>
<h2 id="real-world-examples"><a class="header" href="#real-world-examples">Real-World Examples</a></h2>
<h3 id="example-1-multi-function-pipeline"><a class="header" href="#example-1-multi-function-pipeline">Example 1: Multi-Function Pipeline</a></h3>
<pre><code class="language-javascript">import { initStore, useStoreContext, useGraph } from 'unrdf';

// Step 1: Load data
async function loadPeople() {
  const ctx = useStoreContext();

  const people = [
    { name: 'Alice', age: 30 },
    { name: 'Bob', age: 28 },
    { name: 'Carol', age: 32 }
  ];

  for (const person of people) {
    const uri = ctx.namedNode(`http://example.org/${person.name.toLowerCase()}`);
    ctx.add(
      ctx.quad(uri, ctx.namedNode('http://xmlns.com/foaf/0.1/name'), ctx.literal(person.name)),
      ctx.quad(uri, ctx.namedNode('http://xmlns.com/foaf/0.1/age'), ctx.literal(String(person.age), 'http://www.w3.org/2001/XMLSchema#integer'))
    );
  }
}

// Step 2: Query data
async function findPeopleOver25() {
  const graph = useGraph();

  return await graph.select(`
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    PREFIX xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt;

    SELECT ?name ?age WHERE {
      ?person foaf:name ?name ;
              foaf:age ?age .
      FILTER (?age &gt; 25)
    }
  `);
}

// Step 3: Pipeline
const runApp = initStore();

runApp(async () =&gt; {
  await loadPeople();

  const results = await findPeopleOver25();

  console.log('People over 25:');
  for (const row of results) {
    console.log(`- ${row.name}: ${row.age}`);
  }

  const ctx = useStoreContext();
  console.log(`Total quads: ${ctx.store.size}`);
});
</code></pre>
<h3 id="example-2-testing-with-isolated-contexts"><a class="header" href="#example-2-testing-with-isolated-contexts">Example 2: Testing with Isolated Contexts</a></h3>
<pre><code class="language-javascript">import { describe, it, expect } from 'vitest';
import { initStore, useStoreContext } from 'unrdf';

describe('Person Management', () =&gt; {
  it('should add person', () =&gt; {
    const runApp = initStore();

    runApp(() =&gt; {
      const ctx = useStoreContext();

      const alice = ctx.namedNode('http://example.org/alice');
      const name = ctx.namedNode('http://xmlns.com/foaf/0.1/name');

      ctx.add(ctx.quad(alice, name, ctx.literal('Alice')));

      expect(ctx.store.size).toBe(1);
    });
  });

  it('should be isolated from previous test', () =&gt; {
    const runApp = initStore();

    runApp(() =&gt; {
      const ctx = useStoreContext();

      // New context - completely empty
      expect(ctx.store.size).toBe(0);
    });
  });
});
</code></pre>
<h3 id="example-3-request-scoped-data-server"><a class="header" href="#example-3-request-scoped-data-server">Example 3: Request-Scoped Data (Server)</a></h3>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

export async function handleRequest(req, res) {
  // Each request gets isolated context
  const runApp = initStore();

  await runApp(async () =&gt; {
    const ctx = useStoreContext();

    // Load user data
    const userId = req.params.userId;
    const userData = await fetchUserData(userId);

    // Build RDF graph
    const user = ctx.namedNode(`http://example.org/users/${userId}`);
    ctx.add(
      ctx.quad(user, ctx.namedNode('http://xmlns.com/foaf/0.1/name'), ctx.literal(userData.name)),
      ctx.quad(user, ctx.namedNode('http://xmlns.com/foaf/0.1/mbox'), ctx.namedNode(`mailto:${userData.email}`))
    );

    // Process and respond
    const turtle = ctx.serialize({ format: 'Turtle' });
    res.setHeader('Content-Type', 'text/turtle');
    res.send(turtle);
  });

  // Context automatically cleaned up after response
}
</code></pre>
<h2 id="best-practices-4"><a class="header" href="#best-practices-4">Best Practices</a></h2>
<h3 id="1-always-initialize-context"><a class="header" href="#1-always-initialize-context">1. Always Initialize Context</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Always use initStore()
const runApp = initStore();
runApp(() =&gt; {
  const ctx = useStoreContext();
  // Work with context
});

// ‚ùå Avoid: Using composables without context
try {
  const ctx = useStoreContext();  // Throws error!
} catch (err) {
  console.error('Context not initialized');
}
</code></pre>
<h3 id="2-one-context-per-scope"><a class="header" href="#2-one-context-per-scope">2. One Context Per Scope</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: One context for entire operation
const runApp = initStore();
runApp(async () =&gt; {
  await step1();
  await step2();
  await step3();
});

// ‚ùå Avoid: Multiple nested contexts (usually)
runApp(() =&gt; {
  const runApp2 = initStore();  // Nested context - rarely needed
  runApp2(() =&gt; {
    // ...
  });
});
</code></pre>
<h3 id="3-use-composables-inside-context"><a class="header" href="#3-use-composables-inside-context">3. Use Composables Inside Context</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Composables inside runApp()
const runApp = initStore();
runApp(() =&gt; {
  const graph = useGraph();
  const turtle = useTurtle();
  // Use composables
});

// ‚ùå Avoid: Composables outside context
const graph = useGraph();  // Error: Context not initialized
</code></pre>
<h3 id="4-clean-up-when-done"><a class="header" href="#4-clean-up-when-done">4. Clean Up When Done</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Clear large datasets
runApp(() =&gt; {
  const ctx = useStoreContext();

  // Process large dataset
  processMillionsOfQuads();

  // Clear when done
  ctx.clear();
});

// Context automatically cleaned up after runApp()
</code></pre>
<h2 id="common-patterns-2"><a class="header" href="#common-patterns-2">Common Patterns</a></h2>
<h3 id="pattern-1-load-process-save"><a class="header" href="#pattern-1-load-process-save">Pattern 1: Load-Process-Save</a></h3>
<pre><code class="language-javascript">const runApp = initStore();

runApp(() =&gt; {
  const turtle = useTurtle('./data');
  const graph = useGraph();

  // Load
  turtle.loadAll();

  // Process
  const results = await graph.select(`
    SELECT ?s ?p ?o WHERE { ?s ?p ?o }
  `);

  // Transform
  // ... modify data ...

  // Save
  turtle.save('processed-data');
});
</code></pre>
<h3 id="pattern-2-validate-transform-export"><a class="header" href="#pattern-2-validate-transform-export">Pattern 2: Validate-Transform-Export</a></h3>
<pre><code class="language-javascript">const runApp = initStore();

runApp(async () =&gt; {
  const ctx = useStoreContext();
  const graph = useGraph();

  // Load data
  // ...

  // Validate
  const shapes = await parseTurtle(shaclShapes);
  const report = graph.validate(shapes);

  if (!report.conforms) {
    throw new Error('Validation failed');
  }

  // Transform
  const transformed = await graph.construct(`
    CONSTRUCT {
      ?s &lt;http://example.org/valid&gt; true .
    } WHERE {
      ?s ?p ?o .
    }
  `);

  // Export
  const jsonld = await toJsonLd(transformed);
  console.log(jsonld);
});
</code></pre>
<h2 id="summary-3"><a class="header" href="#summary-3">Summary</a></h2>
<ul>
<li><strong>Store Context</strong> manages RDF stores using unctx async context</li>
<li><strong><code>initStore()</code></strong> creates isolated contexts for each operation</li>
<li><strong><code>useStoreContext()</code></strong> accesses store from anywhere (no parameters needed)</li>
<li><strong>Async Preservation</strong> maintains context across async/await</li>
<li><strong>Composability</strong> enables clean, decoupled functions</li>
<li><strong>Isolation</strong> perfect for testing and multi-tenancy</li>
<li><strong>Memory Efficient</strong> automatic cleanup after context ends</li>
</ul>
<p>The Store Context pattern is the foundation that makes UNRDF's composable architecture possible.</p>
<h2 id="next-steps-6"><a class="header" href="#next-steps-6">Next Steps</a></h2>
<ul>
<li><strong><a href="concepts/./composables.html">Composables</a></strong> - Learn about UNRDF's composable functions</li>
<li><strong><a href="concepts/./transactions.html">Transactions</a></strong> - Master atomic operations with transactions</li>
<li><strong><a href="concepts/./rdf-fundamentals.html">RDF Fundamentals</a></strong> - Review RDF basics if needed</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="transactions"><a class="header" href="#transactions">Transactions</a></h1>
<p>UNRDF provides <strong>atomic transactions</strong> with ACID guarantees, cryptographic provenance, and Knowledge Hooks integration. This chapter explains how to use transactions to ensure data integrity and auditability in your RDF applications.</p>
<h2 id="what-are-transactions"><a class="header" href="#what-are-transactions">What are Transactions?</a></h2>
<p>Transactions are <strong>atomic operations</strong> that either completely succeed or completely fail‚Äîno partial updates. In UNRDF, transactions provide:</p>
<ol>
<li><strong>Atomicity</strong> - All changes succeed or all fail</li>
<li><strong>Consistency</strong> - Maintains data integrity via hooks</li>
<li><strong>Isolation</strong> - Concurrent transactions don't interfere</li>
<li><strong>Durability</strong> - Changes are permanent and auditable</li>
<li><strong>Provenance</strong> - Cryptographic proof of what changed and when</li>
</ol>
<h2 id="transaction-lifecycle"><a class="header" href="#transaction-lifecycle">Transaction Lifecycle</a></h2>
<p>A transaction goes through several phases:</p>
<pre><code class="language-text">1. Create Delta (additions + removals)
       ‚Üì
2. Execute Pre-Hooks (validation)
       ‚Üì
3. Apply Changes to Store
       ‚Üì
4. Execute Post-Hooks (side effects)
       ‚Üì
5. Generate Receipt (cryptographic proof)
       ‚Üì
6. Write to Lockchain (optional audit trail)
</code></pre>
<h2 id="basic-transaction-usage"><a class="header" href="#basic-transaction-usage">Basic Transaction Usage</a></h2>
<h3 id="creating-a-transaction-manager"><a class="header" href="#creating-a-transaction-manager">Creating a Transaction Manager</a></h3>
<pre><code class="language-javascript">import { TransactionManager } from 'unrdf';
import { Store } from 'n3';

// Create transaction manager
const txManager = new TransactionManager({
  maxHooks: 100,
  enableLockchain: true,
  enableResolution: true,
  observability: {
    enableOTEL: true
  }
});

// Create a store
const store = new Store();

// Define a delta (changes)
const delta = {
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Alice Smith')
    )
  ],
  removals: []
};

// Apply transaction
const result = await txManager.apply(store, delta, {
  actor: 'alice@example.org',
  skipHooks: false,
  timeoutMs: 5000
});

console.log('Committed:', result.receipt.committed);
console.log('Transaction ID:', result.receipt.id);
console.log('Duration:', result.receipt.durationMs, 'ms');
</code></pre>
<p><strong>Source Reference</strong> (<code>src/knowledge-engine/transaction.mjs:88-140</code>)</p>
<h2 id="deltas-additions-and-removals"><a class="header" href="#deltas-additions-and-removals">Deltas: Additions and Removals</a></h2>
<p>A <strong>delta</strong> represents the changes in a transaction:</p>
<pre><code class="language-javascript">import { namedNode, literal, quad } from '@rdfjs/data-model';

const delta = {
  additions: [
    // Add new person
    quad(
      namedNode('http://example.org/bob'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Bob Jones')
    ),
    quad(
      namedNode('http://example.org/bob'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('28', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ],
  removals: [
    // Remove old data
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('29', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ]
};
</code></pre>
<h3 id="delta-from-store-comparison"><a class="header" href="#delta-from-store-comparison">Delta from Store Comparison</a></h3>
<p>Use <code>useDelta()</code> composable to generate deltas:</p>
<pre><code class="language-javascript">import { initStore, useDelta, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const delta = useDelta();
  const turtle = useTurtle();

  // Load current state
  turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    ex:alice ex:age 29 .
  `, { addToStore: true });

  // Parse new state
  const newData = turtle.parse(`
    @prefix ex: &lt;http://example.org/&gt; .
    ex:alice ex:age 30 .
    ex:bob ex:age 28 .
  `);

  // Generate delta
  const changes = delta.compareWith(newData);

  console.log('Delta:');
  console.log('- Added:', changes.addedCount, 'quads');
  console.log('- Removed:', changes.removedCount, 'quads');

  // Use in transaction
  // const result = await txManager.apply(store, changes);
});
</code></pre>
<h2 id="transaction-receipts"><a class="header" href="#transaction-receipts">Transaction Receipts</a></h2>
<p>Every transaction generates a <strong>receipt</strong> with complete audit information:</p>
<pre><code class="language-javascript">const result = await txManager.apply(store, delta, {
  actor: 'alice@example.org'
});

const receipt = result.receipt;

console.log('Receipt:');
console.log('- ID:', receipt.id);                    // UUID
console.log('- Timestamp:', receipt.timestamp);      // Unix timestamp
console.log('- Actor:', receipt.actor);              // Who made the change
console.log('- Committed:', receipt.committed);      // Success/failure
console.log('- Duration:', receipt.durationMs);      // Execution time

// Cryptographic hashes
console.log('- Store Hash (SHA3):', receipt.storeHash.sha3);
console.log('- Store Hash (BLAKE3):', receipt.storeHash.blake3);
console.log('- Before Hash:', receipt.beforeHash);
console.log('- After Hash:', receipt.afterHash);

// Delta information
console.log('- Added Quads:', receipt.delta.additions.length);
console.log('- Removed Quads:', receipt.delta.removals.length);

// Hook execution
console.log('- Hook Results:', receipt.hookResults);
console.log('- Hook Errors:', receipt.hookErrors);
</code></pre>
<h3 id="receipt-structure"><a class="header" href="#receipt-structure">Receipt Structure</a></h3>
<pre><code class="language-typescript">{
  id: string,              // Transaction UUID
  timestamp: number,       // Unix timestamp (ms)
  durationMs: number,      // Execution time
  actor: string,           // Who executed the transaction
  committed: boolean,      // Success/failure
  delta: {
    additions: Quad[],     // Quads added
    removals: Quad[]       // Quads removed
  },
  beforeHash: {
    sha3: string,          // Store hash before transaction
    blake3: string
  },
  afterHash: {
    sha3: string,          // Store hash after transaction
    blake3: string
  },
  storeHash: {
    sha3: string,          // Alias for afterHash
    blake3: string
  },
  hookResults: HookResult[], // Hook execution results
  hookErrors: string[]       // Hook errors
}
</code></pre>
<h2 id="transaction-hooks"><a class="header" href="#transaction-hooks">Transaction Hooks</a></h2>
<p>Hooks enable <strong>policy-driven transactions</strong> with validation and side effects:</p>
<h3 id="hook-types-1"><a class="header" href="#hook-types-1">Hook Types</a></h3>
<ol>
<li><strong>Pre-Hooks</strong> - Execute <strong>before</strong> changes (validation, veto)</li>
<li><strong>Post-Hooks</strong> - Execute <strong>after</strong> changes (notifications, side effects)</li>
</ol>
<h3 id="hook-effects"><a class="header" href="#hook-effects">Hook Effects</a></h3>
<ul>
<li><strong><code>veto</code></strong> - Block the transaction if condition fails</li>
<li><strong><code>log</code></strong> - Log information</li>
<li><strong><code>notify</code></strong> - Send notifications</li>
<li><strong><code>custom</code></strong> - Custom side effects</li>
</ul>
<h3 id="adding-hooks"><a class="header" href="#adding-hooks">Adding Hooks</a></h3>
<pre><code class="language-javascript">const txManager = new TransactionManager();

// Pre-hook: Veto transactions that add "Eve"
txManager.addHook({
  id: 'no-eve',
  mode: 'pre',
  condition: async (store, delta) =&gt; {
    // Return true to allow, false to veto
    const hasEve = delta.additions.some(q =&gt;
      q.object.value &amp;&amp; q.object.value.includes('Eve')
    );
    return !hasEve;
  },
  effect: 'veto',
  metadata: {
    description: 'Prevent adding Eve to the database',
    severity: 'high'
  }
});

// Post-hook: Log all transactions
txManager.addHook({
  id: 'audit-log',
  mode: 'post',
  condition: async () =&gt; true, // Always execute
  effect: 'log',
  metadata: {
    description: 'Audit trail for all transactions'
  }
});

// Try to add Eve (will be vetoed)
const delta = {
  additions: [
    quad(
      namedNode('http://example.org/eve'),
      namedNode('http://xmlns.com/foaf/0.1/name'),
      literal('Eve')
    )
  ],
  removals: []
};

const result = await txManager.apply(store, delta);

console.log('Committed:', result.receipt.committed);  // false
console.log('Hook results:', result.receipt.hookResults);
</code></pre>
<p><strong>Source Reference</strong> (<code>src/knowledge-engine/transaction.mjs:155-170</code>)</p>
<h3 id="hook-lifecycle-1"><a class="header" href="#hook-lifecycle-1">Hook Lifecycle</a></h3>
<pre><code class="language-javascript">// Pre-hook lifecycle
1. Transaction starts
2. Pre-hooks execute in order
3. If any pre-hook vetoes ‚Üí transaction fails
4. If all pre-hooks pass ‚Üí continue to apply changes

// Post-hook lifecycle
1. Changes applied to store
2. Post-hooks execute in order
3. Post-hook failures are logged but don't block transaction
4. Receipt generated with hook results
</code></pre>
<h3 id="managing-hooks-1"><a class="header" href="#managing-hooks-1">Managing Hooks</a></h3>
<pre><code class="language-javascript">// Add hook
txManager.addHook({
  id: 'validation-hook',
  mode: 'pre',
  condition: async (store, delta) =&gt; {
    // Validation logic
    return true;
  },
  effect: 'veto'
});

// Remove hook
const removed = txManager.removeHook('validation-hook');
console.log('Hook removed:', removed);

// Get all hooks
const hooks = txManager.getHooks();
console.log('Registered hooks:', hooks.length);

// Clear all hooks
txManager.clearHooks();
</code></pre>
<h2 id="cryptographic-hashing"><a class="header" href="#cryptographic-hashing">Cryptographic Hashing</a></h2>
<p>UNRDF uses <strong>dual hashing</strong> for maximum security:</p>
<ol>
<li><strong>SHA3-256</strong> - NIST-approved cryptographic hash</li>
<li><strong>BLAKE3</strong> - High-performance cryptographic hash</li>
</ol>
<h3 id="hash-generation"><a class="header" href="#hash-generation">Hash Generation</a></h3>
<pre><code class="language-javascript">import { canonicalize } from 'unrdf';
import { sha3_256 } from '@noble/hashes/sha3.js';
import { blake3 } from '@noble/hashes/blake3.js';
import { utf8ToBytes, bytesToHex } from '@noble/hashes/utils.js';

async function hashStore(store) {
  // Canonicalize store (deterministic ordering)
  const canonical = await canonicalize(store);

  // Convert to bytes
  const bytes = utf8ToBytes(canonical);

  // Generate hashes
  const sha3Hash = bytesToHex(sha3_256(bytes));
  const blake3Hash = bytesToHex(blake3(bytes));

  return {
    sha3: sha3Hash,
    blake3: blake3Hash
  };
}

const hashes = await hashStore(store);
console.log('SHA3:', hashes.sha3);
console.log('BLAKE3:', hashes.blake3);
</code></pre>
<p><strong>Source Reference</strong> (<code>src/knowledge-engine/transaction.mjs:60-82</code>)</p>
<h3 id="why-dual-hashing"><a class="header" href="#why-dual-hashing">Why Dual Hashing?</a></h3>
<ul>
<li><strong>SHA3-256</strong>: NIST standard, widely recognized, cryptographically secure</li>
<li><strong>BLAKE3</strong>: Faster, modern, resistant to length extension attacks</li>
<li><strong>Together</strong>: Defense in depth, future-proof against cryptanalysis</li>
</ul>
<h2 id="lockchain-git-based-audit-trail"><a class="header" href="#lockchain-git-based-audit-trail">Lockchain: Git-Based Audit Trail</a></h2>
<p>The <strong>Lockchain</strong> provides immutable, verifiable audit trails using Git:</p>
<h3 id="basic-lockchain-usage"><a class="header" href="#basic-lockchain-usage">Basic Lockchain Usage</a></h3>
<pre><code class="language-javascript">import { LockchainWriter } from 'unrdf';

const lockchain = new LockchainWriter({
  gitRepo: './audit-trail',
  refName: 'refs/notes/lockchain',
  enableMerkle: true,
  enableGitAnchoring: true,
  batchSize: 10
});

// Initialize lockchain
await lockchain.init();

// Write receipt
const entry = await lockchain.writeReceipt(receipt, {
  merkleRoot: '...'
});

console.log('Lockchain entry:', entry.id);
console.log('Signature:', entry.signature);
console.log('Merkle root:', entry.merkleRoot);

// Batch commit to Git
const commit = await lockchain.commitBatch();
console.log('Committed to Git:', commit.commitHash);

// Verify receipt
const isValid = await lockchain.verifyReceipt(entry.id);
console.log('Receipt valid:', isValid);
</code></pre>
<p><strong>Source Reference</strong> (<code>src/knowledge-engine/lockchain-writer.mjs:54-262</code>)</p>
<h3 id="lockchain-features"><a class="header" href="#lockchain-features">Lockchain Features</a></h3>
<ol>
<li><strong>Git Anchoring</strong> - Receipts stored in Git refs</li>
<li><strong>Merkle Trees</strong> - Batch verification via merkle roots</li>
<li><strong>Cryptographic Signatures</strong> - Ed25519, ECDSA, or RSA</li>
<li><strong>Tamper Detection</strong> - Verify integrity of entire chain</li>
<li><strong>Batch Commits</strong> - Efficient Git operations</li>
</ol>
<h3 id="lockchain-entry-structure"><a class="header" href="#lockchain-entry-structure">Lockchain Entry Structure</a></h3>
<pre><code class="language-typescript">{
  id: string,              // UUID
  timestamp: number,       // Unix timestamp
  receipt: Receipt,        // Transaction receipt
  signature: {
    algorithm: string,     // 'ed25519', 'ecdsa', 'rsa'
    value: string,         // Signature bytes (hex)
    publicKey?: string     // Optional public key
  },
  previousHash?: string,   // Previous entry hash (chain)
  merkleRoot?: string,     // Merkle root for batch
  gitCommit?: string,      // Git commit SHA
  gitRef?: string          // Git ref name
}
</code></pre>
<h3 id="verifying-lockchain-entries"><a class="header" href="#verifying-lockchain-entries">Verifying Lockchain Entries</a></h3>
<pre><code class="language-javascript">// Verify single entry
const result = await lockchain.verifyEntry(entryId);

if (result.valid) {
  console.log('‚úì Entry is valid');
  console.log('- Signature verified');
  console.log('- Git commit verified');
  console.log('- Merkle root verified');
} else {
  console.error('‚úó Entry invalid:', result.error);
}

// Verify receipt (simplified)
const isValid = await lockchain.verifyReceipt(receipt);
console.log('Receipt valid:', isValid);
</code></pre>
<h2 id="transaction-patterns"><a class="header" href="#transaction-patterns">Transaction Patterns</a></h2>
<h3 id="pattern-1-simple-data-update"><a class="header" href="#pattern-1-simple-data-update">Pattern 1: Simple Data Update</a></h3>
<pre><code class="language-javascript">import { TransactionManager } from 'unrdf';
import { Store, namedNode, literal, quad } from 'n3';

const txManager = new TransactionManager();
const store = new Store();

// Update person's age
const delta = {
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('31', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ],
  removals: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('30', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ]
};

const result = await txManager.apply(store, delta, {
  actor: 'system',
  timeoutMs: 5000
});

console.log('Update committed:', result.receipt.committed);
</code></pre>
<h3 id="pattern-2-validated-transaction"><a class="header" href="#pattern-2-validated-transaction">Pattern 2: Validated Transaction</a></h3>
<pre><code class="language-javascript">const txManager = new TransactionManager();

// Add validation hook
txManager.addHook({
  id: 'age-validation',
  mode: 'pre',
  condition: async (store, delta) =&gt; {
    // Validate that age is &gt;= 0 and &lt;= 150
    for (const quad of delta.additions) {
      if (quad.predicate.value === 'http://xmlns.com/foaf/0.1/age') {
        const age = parseInt(quad.object.value);
        if (age &lt; 0 || age &gt; 150) {
          return false; // Veto
        }
      }
    }
    return true; // Allow
  },
  effect: 'veto',
  metadata: {
    description: 'Validate age is between 0 and 150'
  }
});

// Valid transaction
const validDelta = {
  additions: [
    quad(
      namedNode('http://example.org/bob'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('28', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ],
  removals: []
};

const result1 = await txManager.apply(store, validDelta);
console.log('Valid transaction committed:', result1.receipt.committed); // true

// Invalid transaction (will be vetoed)
const invalidDelta = {
  additions: [
    quad(
      namedNode('http://example.org/charlie'),
      namedNode('http://xmlns.com/foaf/0.1/age'),
      literal('200', namedNode('http://www.w3.org/2001/XMLSchema#integer'))
    )
  ],
  removals: []
};

const result2 = await txManager.apply(store, invalidDelta);
console.log('Invalid transaction committed:', result2.receipt.committed); // false
</code></pre>
<h3 id="pattern-3-audited-transaction"><a class="header" href="#pattern-3-audited-transaction">Pattern 3: Audited Transaction</a></h3>
<pre><code class="language-javascript">const txManager = new TransactionManager({
  enableLockchain: true,
  lockchainConfig: {
    gitRepo: './audit-trail',
    enableMerkle: true,
    batchSize: 10
  }
});

// Transaction with full audit trail
const delta = {
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/salary'),
      literal('75000', namedNode('http://www.w3.org/2001/XMLSchema#decimal'))
    )
  ],
  removals: []
};

const result = await txManager.apply(store, delta, {
  actor: 'payroll@example.org'
});

// Receipt automatically written to lockchain
console.log('Transaction ID:', result.receipt.id);
console.log('Actor:', result.receipt.actor);
console.log('Timestamp:', new Date(result.receipt.timestamp));

// Later: Verify the transaction
const lockchain = txManager.lockchainWriter;
const isValid = await lockchain.verifyReceipt(result.receipt.id);
console.log('Audit trail valid:', isValid);
</code></pre>
<h3 id="pattern-4-multi-step-transaction"><a class="header" href="#pattern-4-multi-step-transaction">Pattern 4: Multi-Step Transaction</a></h3>
<pre><code class="language-javascript">import { useDelta, useStoreContext, initStore } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const ctx = useStoreContext();
  const delta = useDelta();

  // Step 1: Load data
  // ... load initial data ...

  // Step 2: Make changes
  const newData = // ... parse new data ...
  const changes = delta.compareWith(newData);

  // Step 3: Execute transaction
  const txManager = new TransactionManager();
  const result = await txManager.apply(ctx.store, changes, {
    actor: 'migration@example.org'
  });

  if (!result.receipt.committed) {
    console.error('Transaction failed');
    return;
  }

  // Step 4: Verify
  console.log('‚úì Transaction committed');
  console.log('- Added:', result.receipt.delta.additions.length);
  console.log('- Removed:', result.receipt.delta.removals.length);
  console.log('- Hash:', result.receipt.afterHash.sha3);
});
</code></pre>
<h2 id="error-handling-3"><a class="header" href="#error-handling-3">Error Handling</a></h2>
<pre><code class="language-javascript">const txManager = new TransactionManager();

try {
  const result = await txManager.apply(store, delta, {
    actor: 'alice@example.org',
    timeoutMs: 5000
  });

  if (!result.receipt.committed) {
    console.error('Transaction failed:');
    console.error('- Hook errors:', result.receipt.hookErrors);
    console.error('- Hook results:', result.receipt.hookResults);
    return;
  }

  console.log('‚úì Transaction successful');
} catch (error) {
  if (error.message.includes('timeout')) {
    console.error('Transaction timed out');
  } else if (error.message.includes('validation')) {
    console.error('Validation error:', error.message);
  } else {
    console.error('Transaction error:', error.message);
  }
}
</code></pre>
<h2 id="rollback-strategies"><a class="header" href="#rollback-strategies">Rollback Strategies</a></h2>
<pre><code class="language-javascript">import { useDelta } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const delta = useDelta();

  // Execute transaction
  const result = await txManager.apply(store, changes);

  if (!result.receipt.committed) {
    console.error('Transaction failed - no rollback needed');
    return;
  }

  // Later: Rollback by inverting the delta
  const inverted = delta.invert(result.receipt.delta);

  const rollbackResult = await txManager.apply(store, inverted, {
    actor: 'system-rollback'
  });

  console.log('Rollback committed:', rollbackResult.receipt.committed);
});
</code></pre>
<h2 id="performance-considerations"><a class="header" href="#performance-considerations">Performance Considerations</a></h2>
<h3 id="transaction-timeout"><a class="header" href="#transaction-timeout">Transaction Timeout</a></h3>
<pre><code class="language-javascript">const result = await txManager.apply(store, delta, {
  timeoutMs: 10000  // 10 seconds
});
</code></pre>
<h3 id="hook-limit"><a class="header" href="#hook-limit">Hook Limit</a></h3>
<pre><code class="language-javascript">const txManager = new TransactionManager({
  maxHooks: 50  // Limit number of hooks
});
</code></pre>
<h3 id="batch-lockchain-commits"><a class="header" href="#batch-lockchain-commits">Batch Lockchain Commits</a></h3>
<pre><code class="language-javascript">const lockchain = new LockchainWriter({
  batchSize: 20  // Commit every 20 receipts
});

// Receipts accumulate in memory
await lockchain.writeReceipt(receipt1);
await lockchain.writeReceipt(receipt2);
// ... 18 more ...

// Auto-commits when batch size reached
await lockchain.writeReceipt(receipt20);  // Triggers Git commit

// Or manually commit
await lockchain.commitBatch();
</code></pre>
<h3 id="fast-hashing"><a class="header" href="#fast-hashing">Fast Hashing</a></h3>
<pre><code class="language-javascript">// Skip canonicalization for performance (less secure)
const hashes = await hashStore(store, {
  afterHashOnly: true  // Skip canonicalization
});
</code></pre>
<h2 id="best-practices-5"><a class="header" href="#best-practices-5">Best Practices</a></h2>
<h3 id="1-always-specify-actor"><a class="header" href="#1-always-specify-actor">1. Always Specify Actor</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Track who made the change
const result = await txManager.apply(store, delta, {
  actor: 'alice@example.org'
});

// ‚ùå Avoid: No accountability
const result = await txManager.apply(store, delta);
</code></pre>
<h3 id="2-use-hooks-for-validation"><a class="header" href="#2-use-hooks-for-validation">2. Use Hooks for Validation</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Centralized validation
txManager.addHook({
  id: 'data-validation',
  mode: 'pre',
  condition: validateData,
  effect: 'veto'
});

// ‚ùå Avoid: Manual validation everywhere
if (!isValid(delta)) {
  throw new Error('Invalid');
}
</code></pre>
<h3 id="3-enable-lockchain-for-audit"><a class="header" href="#3-enable-lockchain-for-audit">3. Enable Lockchain for Audit</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Full audit trail
const txManager = new TransactionManager({
  enableLockchain: true
});

// ‚ùå Avoid: No audit trail for critical data
const txManager = new TransactionManager();
</code></pre>
<h3 id="4-handle-errors-gracefully"><a class="header" href="#4-handle-errors-gracefully">4. Handle Errors Gracefully</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Comprehensive error handling
try {
  const result = await txManager.apply(store, delta);
  if (!result.receipt.committed) {
    console.log('Transaction vetoed:', result.receipt.hookErrors);
  }
} catch (error) {
  console.error('Transaction failed:', error.message);
}

// ‚ùå Avoid: Ignoring failures
await txManager.apply(store, delta);  // No error handling
</code></pre>
<h2 id="summary-4"><a class="header" href="#summary-4">Summary</a></h2>
<ul>
<li><strong>Transactions</strong> provide ACID guarantees for RDF operations</li>
<li><strong>Deltas</strong> define additions and removals</li>
<li><strong>Receipts</strong> provide cryptographic proof of changes</li>
<li><strong>Hooks</strong> enable policy-driven validation and side effects</li>
<li><strong>Lockchain</strong> provides Git-based immutable audit trails</li>
<li><strong>Dual Hashing</strong> (SHA3 + BLAKE3) ensures integrity</li>
<li><strong>Error Handling</strong> prevents data corruption</li>
</ul>
<p>Transactions are essential for building reliable, auditable RDF applications with UNRDF.</p>
<h2 id="next-steps-7"><a class="header" href="#next-steps-7">Next Steps</a></h2>
<ul>
<li><strong><a href="concepts/./store-context.html">Store Context</a></strong> - Review context management</li>
<li><strong><a href="concepts/./composables.html">Composables</a></strong> - Learn about composable functions</li>
<li><strong><a href="concepts/./rdf-fundamentals.html">RDF Fundamentals</a></strong> - RDF basics</li>
<li><strong>Knowledge Hooks Guide</strong> - Policy-driven automation (coming soon)</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knowledge-hooks-introduction"><a class="header" href="#knowledge-hooks-introduction">Knowledge Hooks Introduction</a></h1>
<p>Knowledge Hooks are the heart of UNRDF's autonomic capabilities, transforming your knowledge graph from a passive data store into an intelligent, self-governing system.</p>
<h2 id="what-are-knowledge-hooks"><a class="header" href="#what-are-knowledge-hooks">What are Knowledge Hooks?</a></h2>
<p>A <strong>Knowledge Hook</strong> is a policy-driven trigger that:</p>
<ol>
<li><strong>Observes</strong> - Monitors the knowledge graph for specific conditions</li>
<li><strong>Evaluates</strong> - Checks if a condition is met using SPARQL, SHACL, or custom logic</li>
<li><strong>Reacts</strong> - Executes effects when triggered (validate, transform, notify, veto)</li>
</ol>
<pre><code class="language-javascript">import { defineHook, registerHook } from 'unrdf';

const hook = defineHook({
  meta: {
    name: 'person-name-required',
    description: 'Ensures all persons have names'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have a name');
    }
  }
});

await registerHook(hook);
</code></pre>
<h2 id="why-use-knowledge-hooks"><a class="header" href="#why-use-knowledge-hooks">Why Use Knowledge Hooks?</a></h2>
<h3 id="reactive-rdf"><a class="header" href="#reactive-rdf">Reactive RDF</a></h3>
<p>Traditional RDF systems are <strong>passive</strong>:</p>
<ul>
<li>Store data</li>
<li>Answer queries</li>
<li>No proactive behavior</li>
</ul>
<p>UNRDF with Knowledge Hooks is <strong>reactive</strong>:</p>
<ul>
<li>Enforces business rules automatically</li>
<li>Maintains data quality invariants</li>
<li>Responds to graph changes in real-time</li>
<li>Provides self-healing capabilities</li>
</ul>
<h3 id="benefits"><a class="header" href="#benefits">Benefits</a></h3>
<p><strong>üõ°Ô∏è Data Quality Enforcement</strong></p>
<pre><code class="language-javascript">// Automatically reject invalid data
defineHook({
  meta: { name: 'age-validation' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person ex:age ?age . FILTER (?age &lt; 0 || ?age &gt; 150) }'
  },
  run: async (event) =&gt; {
    if (event.result) throw new Error('Invalid age detected');
  }
});
</code></pre>
<p><strong>üìä Audit Trails</strong></p>
<pre><code class="language-javascript">// Log all person changes
defineHook({
  meta: { name: 'audit-person-changes' },
  when: {
    kind: 'delta',
    pattern: { predicate: 'rdf:type', object: 'foaf:Person' }
  },
  run: async (event) =&gt; {
    console.log(`Person modified: ${event.delta.additions.length} additions`);
  }
});
</code></pre>
<p><strong>‚ö° Real-Time Notifications</strong></p>
<pre><code class="language-javascript">// Alert on large transactions
defineHook({
  meta: { name: 'large-transaction-alert' },
  when: {
    kind: 'threshold',
    value: 10000,
    operator: 'gt'
  },
  run: async (event) =&gt; {
    await sendAlert(`Large transaction: ${event.value} triples`);
  }
});
</code></pre>
<p><strong>üîÑ Automatic Transformations</strong></p>
<pre><code class="language-javascript">// Normalize email addresses
defineHook({
  meta: { name: 'email-normalization' },
  when: {
    kind: 'delta',
    pattern: { predicate: 'foaf:mbox' }
  },
  run: async (event) =&gt; {
    // Transform email to lowercase
    return {
      result: 'normalized',
      assertions: [/* normalized triples */]
    };
  }
});
</code></pre>
<h2 id="hook-architecture"><a class="header" href="#hook-architecture">Hook Architecture</a></h2>
<p>Knowledge Hooks follow a <strong>declarative, file-based</strong> contract:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Knowledge Hook              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Meta                               ‚îÇ
‚îÇ  ‚Ä¢ name: "compliance:largeTx"       ‚îÇ
‚îÇ  ‚Ä¢ description: "..."               ‚îÇ
‚îÇ  ‚Ä¢ ontology: ["fibo"]               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  When (Condition)                   ‚îÇ
‚îÇ  ‚Ä¢ kind: "sparql-ask"               ‚îÇ
‚îÇ  ‚Ä¢ ref: file://hooks/largeTx.rq     ‚îÇ
‚îÇ  ‚Ä¢ sha256: "e3b0c44..."             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Lifecycle                          ‚îÇ
‚îÇ  ‚Ä¢ before(): gate/normalize         ‚îÇ
‚îÇ  ‚Ä¢ run(): main effect               ‚îÇ
‚îÇ  ‚Ä¢ after(): cleanup/audit           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h3 id="core-principles"><a class="header" href="#core-principles">Core Principles</a></h3>
<p><strong>1. Conditions are Addressed, Not Embedded</strong></p>
<pre><code class="language-javascript">// ‚ùå Bad: Inline query string
when: {
  kind: 'sparql-ask',
  query: 'ASK { ... }' // Hard to version and govern
}

// ‚úÖ Good: Content-addressed file reference
when: {
  kind: 'sparql-ask',
  ref: {
    uri: 'file://hooks/compliance/largeTx.ask.rq',
    sha256: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',
    mediaType: 'application/sparql-query'
  }
}
</code></pre>
<p><strong>2. Reflex Arc Lifecycle</strong></p>
<p>Hooks follow a three-phase lifecycle inspired by biological reflexes:</p>
<ul>
<li><strong>Before</strong>: Pre-condition gate (normalize payload, early cancellation)</li>
<li><strong>Run</strong>: Core effect execution</li>
<li><strong>After</strong>: Post-execution cleanup (audit, metrics)</li>
</ul>
<p><strong>3. Effect Sandboxing</strong></p>
<p>All hook effects run in isolated sandboxes for security:</p>
<ul>
<li>Limited filesystem access</li>
<li>No network access by default</li>
<li>Resource constraints (memory, CPU)</li>
<li>Timeout enforcement</li>
</ul>
<p><strong>4. Cryptographic Provenance</strong></p>
<p>Every hook execution is logged with cryptographic proof:</p>
<ul>
<li>SHA3-256 hashing of hook definitions</li>
<li>Git-based immutable receipts</li>
<li>Merkle tree verification</li>
</ul>
<h2 id="use-cases-1"><a class="header" href="#use-cases-1">Use Cases</a></h2>
<h3 id="1-compliance-enforcement"><a class="header" href="#1-compliance-enforcement">1. Compliance Enforcement</a></h3>
<pre><code class="language-javascript">// GDPR: Prevent storing personal data without consent
defineHook({
  meta: { name: 'gdpr:consent-required' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person ;
                ex:personalData ?data .
        FILTER NOT EXISTS { ?person ex:hasConsent true }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result) {
      throw new Error('GDPR violation: Personal data requires consent');
    }
  }
});
</code></pre>
<h3 id="2-data-quality-gates"><a class="header" href="#2-data-quality-gates">2. Data Quality Gates</a></h3>
<pre><code class="language-javascript">// Ensure data completeness
defineHook({
  meta: { name: 'completeness:person-profile' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS {
          ?person foaf:name ?name ;
                  foaf:mbox ?email
        }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result) {
      throw new Error('Incomplete person profile: name and email required');
    }
  }
});
</code></pre>
<h3 id="3-anomaly-detection"><a class="header" href="#3-anomaly-detection">3. Anomaly Detection</a></h3>
<pre><code class="language-javascript">// Detect suspicious patterns
defineHook({
  meta: { name: 'security:unusual-activity' },
  when: {
    kind: 'window',
    duration: '5m'
  },
  run: async (event) =&gt; {
    if (event.count &gt; 1000) {
      await sendSecurityAlert('Unusual activity detected');
    }
  }
});
</code></pre>
<h3 id="4-business-rule-automation"><a class="header" href="#4-business-rule-automation">4. Business Rule Automation</a></h3>
<pre><code class="language-javascript">// Auto-escalate high-value transactions
defineHook({
  meta: { name: 'business:auto-escalate' },
  when: {
    kind: 'threshold',
    value: 100000,
    operator: 'gte'
  },
  run: async (event) =&gt; {
    return {
      result: 'escalated',
      assertions: [
        quad(event.transaction, 'ex:requiresApproval', literal('true')),
        quad(event.transaction, 'ex:escalatedAt', literal(new Date().toISOString()))
      ]
    };
  }
});
</code></pre>
<h2 id="comparison-with-traditional-event-systems"><a class="header" href="#comparison-with-traditional-event-systems">Comparison with Traditional Event Systems</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Traditional Events</th><th>Knowledge Hooks</th></tr></thead><tbody>
<tr><td><strong>Condition Logic</strong></td><td>Imperative code</td><td>Declarative SPARQL/SHACL</td></tr>
<tr><td><strong>Provenance</strong></td><td>Manual logging</td><td>Cryptographic receipts</td></tr>
<tr><td><strong>Sandboxing</strong></td><td>None</td><td>Built-in isolation</td></tr>
<tr><td><strong>Graph-Native</strong></td><td>No</td><td>Yes (SPARQL queries)</td></tr>
<tr><td><strong>Versioning</strong></td><td>Code versions</td><td>Content-addressed files</td></tr>
<tr><td><strong>Audit Trails</strong></td><td>DIY</td><td>Automatic Merkle proofs</td></tr>
</tbody></table>
</div>
<h2 id="getting-started-1"><a class="header" href="#getting-started-1">Getting Started</a></h2>
<p>Continue to the next chapters to learn:</p>
<ol>
<li><strong><a href="hooks/lifecycle.html">Hook Lifecycle</a></strong> - Understanding before/run/after phases</li>
<li><strong><a href="hooks/predicates.html">Predicates</a></strong> - Different condition types</li>
<li><strong><a href="hooks/effects.html">Effects</a></strong> - What hooks can do</li>
<li><strong><a href="hooks/policy-packs.html">Policy Packs</a></strong> - Organizing hooks into reusable packages</li>
</ol>
<pre><code class="language-admonish tip">For hands-on practice, see [Your First Hook](../getting-started/first-hook.md) to build a complete example.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knowledge-hooks-introduction-1"><a class="header" href="#knowledge-hooks-introduction-1">Knowledge Hooks Introduction</a></h1>
<p>Knowledge Hooks are the heart of UNRDF's autonomic capabilities, transforming your knowledge graph from a passive data store into an intelligent, self-governing system.</p>
<h2 id="what-are-knowledge-hooks-1"><a class="header" href="#what-are-knowledge-hooks-1">What are Knowledge Hooks?</a></h2>
<p>A <strong>Knowledge Hook</strong> is a policy-driven trigger that:</p>
<ol>
<li><strong>Observes</strong> - Monitors the knowledge graph for specific conditions</li>
<li><strong>Evaluates</strong> - Checks if a condition is met using SPARQL, SHACL, or custom logic</li>
<li><strong>Reacts</strong> - Executes effects when triggered (validate, transform, notify, veto)</li>
</ol>
<pre><code class="language-javascript">import { defineHook, registerHook } from 'unrdf';

const hook = defineHook({
  meta: {
    name: 'person-name-required',
    description: 'Ensures all persons have names'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must have a name');
    }
  }
});

await registerHook(hook);
</code></pre>
<h2 id="why-use-knowledge-hooks-1"><a class="header" href="#why-use-knowledge-hooks-1">Why Use Knowledge Hooks?</a></h2>
<h3 id="reactive-rdf-1"><a class="header" href="#reactive-rdf-1">Reactive RDF</a></h3>
<p>Traditional RDF systems are <strong>passive</strong>:</p>
<ul>
<li>Store data</li>
<li>Answer queries</li>
<li>No proactive behavior</li>
</ul>
<p>UNRDF with Knowledge Hooks is <strong>reactive</strong>:</p>
<ul>
<li>Enforces business rules automatically</li>
<li>Maintains data quality invariants</li>
<li>Responds to graph changes in real-time</li>
<li>Provides self-healing capabilities</li>
</ul>
<h3 id="benefits-1"><a class="header" href="#benefits-1">Benefits</a></h3>
<p><strong>üõ°Ô∏è Data Quality Enforcement</strong></p>
<pre><code class="language-javascript">// Automatically reject invalid data
defineHook({
  meta: { name: 'age-validation' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person ex:age ?age . FILTER (?age &lt; 0 || ?age &gt; 150) }'
  },
  run: async (event) =&gt; {
    if (event.result) throw new Error('Invalid age detected');
  }
});
</code></pre>
<p><strong>üìä Audit Trails</strong></p>
<pre><code class="language-javascript">// Log all person changes
defineHook({
  meta: { name: 'audit-person-changes' },
  when: {
    kind: 'delta',
    pattern: { predicate: 'rdf:type', object: 'foaf:Person' }
  },
  run: async (event) =&gt; {
    console.log(`Person modified: ${event.delta.additions.length} additions`);
  }
});
</code></pre>
<p><strong>‚ö° Real-Time Notifications</strong></p>
<pre><code class="language-javascript">// Alert on large transactions
defineHook({
  meta: { name: 'large-transaction-alert' },
  when: {
    kind: 'threshold',
    value: 10000,
    operator: 'gt'
  },
  run: async (event) =&gt; {
    await sendAlert(`Large transaction: ${event.value} triples`);
  }
});
</code></pre>
<p><strong>üîÑ Automatic Transformations</strong></p>
<pre><code class="language-javascript">// Normalize email addresses
defineHook({
  meta: { name: 'email-normalization' },
  when: {
    kind: 'delta',
    pattern: { predicate: 'foaf:mbox' }
  },
  run: async (event) =&gt; {
    // Transform email to lowercase
    return {
      result: 'normalized',
      assertions: [/* normalized triples */]
    };
  }
});
</code></pre>
<h2 id="hook-architecture-1"><a class="header" href="#hook-architecture-1">Hook Architecture</a></h2>
<p>Knowledge Hooks follow a <strong>declarative, file-based</strong> contract:</p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         Knowledge Hook              ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Meta                               ‚îÇ
‚îÇ  ‚Ä¢ name: "compliance:largeTx"       ‚îÇ
‚îÇ  ‚Ä¢ description: "..."               ‚îÇ
‚îÇ  ‚Ä¢ ontology: ["fibo"]               ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  When (Condition)                   ‚îÇ
‚îÇ  ‚Ä¢ kind: "sparql-ask"               ‚îÇ
‚îÇ  ‚Ä¢ ref: file://hooks/largeTx.rq     ‚îÇ
‚îÇ  ‚Ä¢ sha256: "e3b0c44..."             ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ  Lifecycle                          ‚îÇ
‚îÇ  ‚Ä¢ before(): gate/normalize         ‚îÇ
‚îÇ  ‚Ä¢ run(): main effect               ‚îÇ
‚îÇ  ‚Ä¢ after(): cleanup/audit           ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h3 id="core-principles-1"><a class="header" href="#core-principles-1">Core Principles</a></h3>
<p><strong>1. Conditions are Addressed, Not Embedded</strong></p>
<pre><code class="language-javascript">// ‚ùå Bad: Inline query string
when: {
  kind: 'sparql-ask',
  query: 'ASK { ... }' // Hard to version and govern
}

// ‚úÖ Good: Content-addressed file reference
when: {
  kind: 'sparql-ask',
  ref: {
    uri: 'file://hooks/compliance/largeTx.ask.rq',
    sha256: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',
    mediaType: 'application/sparql-query'
  }
}
</code></pre>
<p><strong>2. Reflex Arc Lifecycle</strong></p>
<p>Hooks follow a three-phase lifecycle inspired by biological reflexes:</p>
<ul>
<li><strong>Before</strong>: Pre-condition gate (normalize payload, early cancellation)</li>
<li><strong>Run</strong>: Core effect execution</li>
<li><strong>After</strong>: Post-execution cleanup (audit, metrics)</li>
</ul>
<p><strong>3. Effect Sandboxing</strong></p>
<p>All hook effects run in isolated sandboxes for security:</p>
<ul>
<li>Limited filesystem access</li>
<li>No network access by default</li>
<li>Resource constraints (memory, CPU)</li>
<li>Timeout enforcement</li>
</ul>
<p><strong>4. Cryptographic Provenance</strong></p>
<p>Every hook execution is logged with cryptographic proof:</p>
<ul>
<li>SHA3-256 hashing of hook definitions</li>
<li>Git-based immutable receipts</li>
<li>Merkle tree verification</li>
</ul>
<h2 id="use-cases-2"><a class="header" href="#use-cases-2">Use Cases</a></h2>
<h3 id="1-compliance-enforcement-1"><a class="header" href="#1-compliance-enforcement-1">1. Compliance Enforcement</a></h3>
<pre><code class="language-javascript">// GDPR: Prevent storing personal data without consent
defineHook({
  meta: { name: 'gdpr:consent-required' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person ;
                ex:personalData ?data .
        FILTER NOT EXISTS { ?person ex:hasConsent true }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result) {
      throw new Error('GDPR violation: Personal data requires consent');
    }
  }
});
</code></pre>
<h3 id="2-data-quality-gates-1"><a class="header" href="#2-data-quality-gates-1">2. Data Quality Gates</a></h3>
<pre><code class="language-javascript">// Ensure data completeness
defineHook({
  meta: { name: 'completeness:person-profile' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS {
          ?person foaf:name ?name ;
                  foaf:mbox ?email
        }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result) {
      throw new Error('Incomplete person profile: name and email required');
    }
  }
});
</code></pre>
<h3 id="3-anomaly-detection-1"><a class="header" href="#3-anomaly-detection-1">3. Anomaly Detection</a></h3>
<pre><code class="language-javascript">// Detect suspicious patterns
defineHook({
  meta: { name: 'security:unusual-activity' },
  when: {
    kind: 'window',
    duration: '5m'
  },
  run: async (event) =&gt; {
    if (event.count &gt; 1000) {
      await sendSecurityAlert('Unusual activity detected');
    }
  }
});
</code></pre>
<h3 id="4-business-rule-automation-1"><a class="header" href="#4-business-rule-automation-1">4. Business Rule Automation</a></h3>
<pre><code class="language-javascript">// Auto-escalate high-value transactions
defineHook({
  meta: { name: 'business:auto-escalate' },
  when: {
    kind: 'threshold',
    value: 100000,
    operator: 'gte'
  },
  run: async (event) =&gt; {
    return {
      result: 'escalated',
      assertions: [
        quad(event.transaction, 'ex:requiresApproval', literal('true')),
        quad(event.transaction, 'ex:escalatedAt', literal(new Date().toISOString()))
      ]
    };
  }
});
</code></pre>
<h2 id="comparison-with-traditional-event-systems-1"><a class="header" href="#comparison-with-traditional-event-systems-1">Comparison with Traditional Event Systems</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Feature</th><th>Traditional Events</th><th>Knowledge Hooks</th></tr></thead><tbody>
<tr><td><strong>Condition Logic</strong></td><td>Imperative code</td><td>Declarative SPARQL/SHACL</td></tr>
<tr><td><strong>Provenance</strong></td><td>Manual logging</td><td>Cryptographic receipts</td></tr>
<tr><td><strong>Sandboxing</strong></td><td>None</td><td>Built-in isolation</td></tr>
<tr><td><strong>Graph-Native</strong></td><td>No</td><td>Yes (SPARQL queries)</td></tr>
<tr><td><strong>Versioning</strong></td><td>Code versions</td><td>Content-addressed files</td></tr>
<tr><td><strong>Audit Trails</strong></td><td>DIY</td><td>Automatic Merkle proofs</td></tr>
</tbody></table>
</div>
<h2 id="getting-started-2"><a class="header" href="#getting-started-2">Getting Started</a></h2>
<p>Continue to the next chapters to learn:</p>
<ol>
<li><strong><a href="hooks/lifecycle.html">Hook Lifecycle</a></strong> - Understanding before/run/after phases</li>
<li><strong><a href="hooks/predicates.html">Predicates</a></strong> - Different condition types</li>
<li><strong><a href="hooks/effects.html">Effects</a></strong> - What hooks can do</li>
<li><strong><a href="hooks/policy-packs.html">Policy Packs</a></strong> - Organizing hooks into reusable packages</li>
</ol>
<pre><code class="language-admonish tip">For hands-on practice, see [Your First Hook](../getting-started/first-hook.md) to build a complete example.
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hook-lifecycle-2"><a class="header" href="#hook-lifecycle-2">Hook Lifecycle</a></h1>
<p>Knowledge Hooks follow a three-phase lifecycle inspired by biological reflex arcs: <strong>Before ‚Üí Run ‚Üí After</strong>. This chapter explains each phase in detail.</p>
<h2 id="lifecycle-overview"><a class="header" href="#lifecycle-overview">Lifecycle Overview</a></h2>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ             Hook Execution Flow             ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

   Transaction Request
          ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ   BEFORE    ‚îÇ  Gate/Normalize
   ‚îÇ   Phase     ‚îÇ  ‚Ä¢ Validate payload
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚Ä¢ Normalize data
          ‚îÇ         ‚Ä¢ Early cancellation
          ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ  CONDITION  ‚îÇ  Evaluate
   ‚îÇ  Evaluation ‚îÇ  ‚Ä¢ SPARQL ASK/SELECT
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚Ä¢ SHACL validation
          ‚îÇ         ‚Ä¢ Custom predicates
          ‚Üì
          ?
      Satisfied?
          ‚îÇ
         Yes
          ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ     RUN     ‚îÇ  Main Effect
   ‚îÇ    Phase    ‚îÇ  ‚Ä¢ Core logic
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚Ä¢ Assertions
          ‚îÇ         ‚Ä¢ Transformations
          ‚Üì
   ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
   ‚îÇ    AFTER    ‚îÇ  Cleanup/Audit
   ‚îÇ    Phase    ‚îÇ  ‚Ä¢ Metrics
   ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò  ‚Ä¢ Logging
          ‚îÇ         ‚Ä¢ Receipts
          ‚Üì
   Transaction Complete
</code></pre>
<h2 id="phase-1-before-optional"><a class="header" href="#phase-1-before-optional">Phase 1: Before (Optional)</a></h2>
<p>The <strong>before</strong> phase is a pre-condition gate for:</p>
<ul>
<li>Payload validation and normalization</li>
<li>Early cancellation (avoid expensive condition evaluation)</li>
<li>Context enrichment</li>
</ul>
<h3 id="function-signature"><a class="header" href="#function-signature">Function Signature</a></h3>
<pre><code class="language-javascript">async before({ payload, context, name }) {
  // Return modified payload OR cancellation signal
  return {
    ...payload,
    normalized: true
  };
  // OR
  return {
    cancel: true,
    reason: 'Invalid payload'
  };
}
</code></pre>
<h3 id="example-payload-validation"><a class="header" href="#example-payload-validation">Example: Payload Validation</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'validate-transaction' },
  when: { kind: 'sparql-ask', query: '...' },

  async before({ payload }) {
    // Validate required fields
    if (!payload.actor) {
      return {
        cancel: true,
        reason: 'Transaction requires an actor'
      };
    }

    if (!payload.additions || payload.additions.length === 0) {
      return {
        cancel: true,
        reason: 'Transaction requires at least one addition'
      };
    }

    // Normalize payload
    return {
      ...payload,
      timestamp: new Date().toISOString(),
      validated: true
    };
  },

  run: async (event) =&gt; {
    // Payload now has timestamp and validated flag
    console.log(`Processing transaction at ${event.payload.timestamp}`);
  }
});
</code></pre>
<h3 id="example-early-cancellation"><a class="header" href="#example-early-cancellation">Example: Early Cancellation</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'rate-limiter' },
  when: { kind: 'window', duration: '1m' },

  async before({ payload, context }) {
    // Check rate limit before expensive SPARQL evaluation
    const actorRequestCount = context.rateLimitCache?.get(payload.actor) || 0;

    if (actorRequestCount &gt; 100) {
      return {
        cancel: true,
        reason: `Rate limit exceeded for actor ${payload.actor}`
      };
    }

    // Update cache
    context.rateLimitCache?.set(payload.actor, actorRequestCount + 1);

    return payload;
  },

  run: async (event) =&gt; {
    // Only runs if rate limit not exceeded
    console.log('Processing allowed transaction');
  }
});
</code></pre>
<h3 id="when-to-use-before"><a class="header" href="#when-to-use-before">When to Use Before</a></h3>
<p>‚úÖ <strong>Use before when:</strong></p>
<ul>
<li>Validating payload structure</li>
<li>Normalizing data formats</li>
<li>Checking simple conditions (avoid SPARQL for basic checks)</li>
<li>Enriching context</li>
<li>Implementing fast-path cancellation</li>
</ul>
<p>‚ùå <strong>Don't use before for:</strong></p>
<ul>
<li>Complex business logic (belongs in <code>run</code>)</li>
<li>SPARQL queries (use <code>when</code> condition)</li>
<li>Side effects (belongs in <code>run</code> or <code>after</code>)</li>
</ul>
<h2 id="phase-2-condition-evaluation-required"><a class="header" href="#phase-2-condition-evaluation-required">Phase 2: Condition Evaluation (Required)</a></h2>
<p>The <strong>when</strong> clause defines the trigger condition. This phase evaluates the condition against the knowledge graph.</p>
<h3 id="condition-types"><a class="header" href="#condition-types">Condition Types</a></h3>
<p>UNRDF supports multiple condition types (detailed in <a href="hooks/predicates.html">Predicates</a>):</p>
<ol>
<li><strong>sparql-ask</strong> - Boolean queries</li>
<li><strong>sparql-select</strong> - Result set queries</li>
<li><strong>shacl</strong> - Shape validation</li>
<li><strong>delta</strong> - Change pattern detection</li>
<li><strong>threshold</strong> - Numeric comparisons</li>
<li><strong>count</strong> - Cardinality constraints</li>
<li><strong>window</strong> - Time-based aggregations</li>
</ol>
<h3 id="evaluation-process"><a class="header" href="#evaluation-process">Evaluation Process</a></h3>
<pre><code class="language-javascript">// Condition evaluation happens automatically between before and run
const hook = defineHook({
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },
  run: async (event) =&gt; {
    // event.result contains the ASK query result (true/false)
    if (event.result === true) {
      throw new Error('Person without name detected');
    }
  }
});
</code></pre>
<h3 id="condition-result-structure"><a class="header" href="#condition-result-structure">Condition Result Structure</a></h3>
<p>The <code>event.result</code> passed to <code>run</code> contains:</p>
<pre><code class="language-javascript">// For sparql-ask
event.result = true | false

// For sparql-select
event.result = [
  { name: 'Alice', age: 30 },
  { name: 'Bob', age: 25 }
]

// For shacl
event.result = {
  conforms: false,
  results: [
    {
      path: 'ex:name',
      message: 'Name is required',
      severity: 'Violation'
    }
  ]
}

// For threshold
event.result = {
  value: 15000,
  threshold: 10000,
  operator: 'gt',
  satisfied: true
}
</code></pre>
<h2 id="phase-3-run-required"><a class="header" href="#phase-3-run-required">Phase 3: Run (Required)</a></h2>
<p>The <strong>run</strong> phase executes the main hook logic. This is where you:</p>
<ul>
<li>Enforce business rules</li>
<li>Transform data</li>
<li>Generate new assertions</li>
<li>Trigger external actions</li>
</ul>
<h3 id="function-signature-1"><a class="header" href="#function-signature-1">Function Signature</a></h3>
<pre><code class="language-javascript">async run({ result, payload, context, name }) {
  // Perform main logic
  // Return result object
  return {
    result: 'processed',
    assertions: [/* RDF quads */],
    deltas: { additions: [], removals: [] }
  };
}
</code></pre>
<h3 id="example-data-validation"><a class="header" href="#example-data-validation">Example: Data Validation</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'age-validation' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person ex:age ?age .
        FILTER (?age &lt; 18)
      }
    `
  },

  run: async (event) =&gt; {
    if (event.result === true) {
      // Throw error to reject transaction
      throw new Error('All persons must be 18 or older');
    }

    return { result: 'valid' };
  }
});
</code></pre>
<h3 id="example-data-transformation"><a class="header" href="#example-data-transformation">Example: Data Transformation</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'auto-generate-id' },
  when: {
    kind: 'delta',
    pattern: { predicate: 'rdf:type', object: 'foaf:Person' }
  },

  run: async (event) =&gt; {
    const newPersons = event.delta.additions.filter(
      quad =&gt; quad.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type'
    );

    const assertions = [];
    for (const quad of newPersons) {
      const personIri = quad.subject;
      const id = generateUUID();

      assertions.push(
        quad(personIri, namedNode('ex:id'), literal(id))
      );
    }

    return {
      result: `Generated ${assertions.length} IDs`,
      assertions
    };
  }
});
</code></pre>
<h3 id="example-external-notification"><a class="header" href="#example-external-notification">Example: External Notification</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'webhook-notification' },
  when: {
    kind: 'threshold',
    value: 10000,
    operator: 'gte'
  },

  run: async (event) =&gt; {
    await fetch('https://api.example.com/webhooks/large-transaction', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        value: event.result.value,
        timestamp: new Date().toISOString()
      })
    });

    return {
      result: 'notification-sent',
      timestamp: new Date().toISOString()
    };
  }
});
</code></pre>
<h3 id="veto-pattern"><a class="header" href="#veto-pattern">Veto Pattern</a></h3>
<p>Throwing an error in <code>run</code> <strong>vetoes</strong> the transaction:</p>
<pre><code class="language-javascript">run: async (event) =&gt; {
  if (event.result === true) {
    // Veto: reject the entire transaction
    throw new Error('Validation failed');
  }

  // Allow: transaction proceeds
  return { result: 'valid' };
}
</code></pre>
<h2 id="phase-4-after-optional"><a class="header" href="#phase-4-after-optional">Phase 4: After (Optional)</a></h2>
<p>The <strong>after</strong> phase is for cleanup, auditing, and metrics. It runs <strong>after</strong> the <code>run</code> phase completes, regardless of success or cancellation.</p>
<h3 id="function-signature-2"><a class="header" href="#function-signature-2">Function Signature</a></h3>
<pre><code class="language-javascript">async after({ result, cancelled, reason, payload, context, name }) {
  // Cleanup and audit logic
  // Return final result
  return {
    finalStatus: cancelled ? 'cancelled' : 'completed'
  };
}
</code></pre>
<h3 id="example-metrics-collection"><a class="header" href="#example-metrics-collection">Example: Metrics Collection</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'performance-tracking' },
  when: { kind: 'sparql-ask', query: '...' },

  run: async (event) =&gt; {
    const startTime = Date.now();
    // Main logic
    const result = await processTransaction(event);
    const duration = Date.now() - startTime;

    return { result, duration };
  },

  async after({ result, cancelled, reason }) {
    if (cancelled) {
      console.log(`‚ùå Hook cancelled: ${reason}`);
      await metrics.increment('hook.cancelled');
    } else {
      console.log(`‚úÖ Hook completed in ${result.duration}ms`);
      await metrics.histogram('hook.duration', result.duration);
    }

    return {
      finalStatus: cancelled ? 'cancelled' : 'completed',
      timestamp: new Date().toISOString()
    };
  }
});
</code></pre>
<h3 id="example-audit-logging"><a class="header" href="#example-audit-logging">Example: Audit Logging</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'audit-trail' },
  when: { kind: 'delta', pattern: {} },

  run: async (event) =&gt; {
    // Main processing
    return {
      result: 'processed',
      affectedTriples: event.delta.additions.length
    };
  },

  async after({ result, cancelled, payload }) {
    const auditEntry = {
      hookName: 'audit-trail',
      actor: payload.actor,
      timestamp: new Date().toISOString(),
      status: cancelled ? 'cancelled' : 'completed',
      affectedTriples: result?.affectedTriples || 0
    };

    await auditLog.write(auditEntry);

    return { auditRecorded: true };
  }
});
</code></pre>
<h3 id="when-to-use-after"><a class="header" href="#when-to-use-after">When to Use After</a></h3>
<p>‚úÖ <strong>Use after when:</strong></p>
<ul>
<li>Recording metrics</li>
<li>Writing audit logs</li>
<li>Cleanup operations</li>
<li>Final notifications</li>
<li>Collecting execution metadata</li>
</ul>
<p>‚ùå <strong>Don't use after for:</strong></p>
<ul>
<li>Main business logic (belongs in <code>run</code>)</li>
<li>Transaction validation (belongs in <code>run</code>)</li>
<li>Expensive operations (after runs even on failure)</li>
</ul>
<h2 id="context-isolation-1"><a class="header" href="#context-isolation-1">Context Isolation</a></h2>
<p>Each hook execution has an isolated context:</p>
<pre><code class="language-javascript">{
  name: 'hook-name',           // Hook identifier
  payload: {                   // Transaction data
    additions: [...],
    removals: [...],
    actor: 'user@example.org'
  },
  context: {                   // Execution context
    graph: Store,              // RDF graph
    env: {...},                // Environment variables
    metadata: {...}            // Custom metadata
  },
  result: ...,                 // Condition evaluation result
  cancelled: false,            // Cancellation flag
  reason: null                 // Cancellation reason
}
</code></pre>
<h2 id="error-handling-4"><a class="header" href="#error-handling-4">Error Handling</a></h2>
<h3 id="in-before-phase"><a class="header" href="#in-before-phase">In Before Phase</a></h3>
<pre><code class="language-javascript">before: async ({ payload }) =&gt; {
  try {
    validate(payload);
    return payload;
  } catch (error) {
    return {
      cancel: true,
      reason: error.message
    };
  }
}
</code></pre>
<h3 id="in-run-phase"><a class="header" href="#in-run-phase">In Run Phase</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  try {
    if (event.result === true) {
      throw new Error('Validation failed');
    }
    return { result: 'valid' };
  } catch (error) {
    // Error propagates to transaction (veto)
    throw error;
  }
}
</code></pre>
<h3 id="in-after-phase"><a class="header" href="#in-after-phase">In After Phase</a></h3>
<pre><code class="language-javascript">after: async ({ result, cancelled }) =&gt; {
  try {
    await recordMetrics(result);
  } catch (error) {
    // Errors in after don't fail the transaction
    console.error('Metrics recording failed:', error);
  }

  return { finalStatus: 'completed' };
}
</code></pre>
<h2 id="performance-considerations-1"><a class="header" href="#performance-considerations-1">Performance Considerations</a></h2>
<h3 id="optimize-before-phase"><a class="header" href="#optimize-before-phase">Optimize Before Phase</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Fast checks in before
before: async ({ payload }) =&gt; {
  if (!payload.actor) {
    return { cancel: true, reason: 'Missing actor' };
  }
  return payload;
}

// ‚ùå Bad: Slow operations in before
before: async ({ payload }) =&gt; {
  await complexDatabaseQuery(); // Slow!
  return payload;
}
</code></pre>
<h3 id="minimize-after-phase-work"><a class="header" href="#minimize-after-phase-work">Minimize After Phase Work</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Async fire-and-forget
after: async ({ result }) =&gt; {
  // Fire and forget (don't await)
  sendNotification(result).catch(console.error);
  return { status: 'completed' };
}

// ‚ùå Bad: Blocking operations
after: async ({ result }) =&gt; {
  await slowExternalAPI(result); // Blocks transaction!
  return { status: 'completed' };
}
</code></pre>
<h2 id="complete-lifecycle-example"><a class="header" href="#complete-lifecycle-example">Complete Lifecycle Example</a></h2>
<pre><code class="language-javascript">import { defineHook } from 'unrdf';

const comprehensiveHook = defineHook({
  meta: {
    name: 'comprehensive-example',
    description: 'Demonstrates full lifecycle'
  },

  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },

  // Phase 1: Before
  async before({ payload }) {
    // Validate payload
    if (!payload || !payload.actor) {
      return {
        cancel: true,
        reason: 'Transaction requires an actor'
      };
    }

    // Normalize payload
    return {
      ...payload,
      validatedAt: new Date().toISOString(),
      normalizedActor: payload.actor.toLowerCase()
    };
  },

  // Phase 2: When (automatic)
  // SPARQL ASK query evaluates automatically

  // Phase 3: Run
  async run({ result, payload }) {
    console.log(`Validating transaction by ${payload.normalizedActor}`);

    if (result === true) {
      // Veto: person without name detected
      throw new Error('All persons must have a name');
    }

    return {
      result: 'valid',
      validatedAt: payload.validatedAt,
      validator: 'comprehensive-example'
    };
  },

  // Phase 4: After
  async after({ result, cancelled, reason, payload }) {
    if (cancelled) {
      console.log(`‚ùå Validation cancelled: ${reason}`);
      await metrics.increment('validation.cancelled');
    } else {
      console.log(`‚úÖ Validation passed at ${result.validatedAt}`);
      await metrics.increment('validation.passed');
    }

    // Record audit trail
    await auditLog.write({
      hook: 'comprehensive-example',
      actor: payload.normalizedActor,
      status: cancelled ? 'cancelled' : 'completed',
      timestamp: new Date().toISOString()
    });

    return {
      finalStatus: cancelled ? 'cancelled' : 'completed',
      auditRecorded: true
    };
  }
});
</code></pre>
<h2 id="next-steps-8"><a class="header" href="#next-steps-8">Next Steps</a></h2>
<p>Continue to learn about:</p>
<ul>
<li><strong><a href="hooks/predicates.html">Predicates</a></strong> - Different condition types (ASK, THRESHOLD, DELTA, SHACL, etc.)</li>
<li><strong><a href="hooks/effects.html">Effects</a></strong> - What hooks can do (veto, log, notify, transform)</li>
<li><strong><a href="hooks/policy-packs.html">Policy Packs</a></strong> - Organizing hooks into reusable packages</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="hook-effects-1"><a class="header" href="#hook-effects-1">Hook Effects</a></h1>
<p>Effects are what Knowledge Hooks <strong>do</strong> when their predicates are satisfied. UNRDF provides a comprehensive effect system with security sandboxing and execution control.</p>
<h2 id="effect-types"><a class="header" href="#effect-types">Effect Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Purpose</th><th>Example</th></tr></thead><tbody>
<tr><td><strong>Veto</strong></td><td>Reject transactions</td><td>Block invalid data</td></tr>
<tr><td><strong>Log</strong></td><td>Record events</td><td>Audit trails</td></tr>
<tr><td><strong>Notify</strong></td><td>Send alerts</td><td>Email, webhook, Slack</td></tr>
<tr><td><strong>Transform</strong></td><td>Modify data</td><td>Normalize, enrich</td></tr>
<tr><td><strong>Assert</strong></td><td>Add knowledge</td><td>Inferred triples</td></tr>
<tr><td><strong>External</strong></td><td>Call APIs</td><td>Integration</td></tr>
</tbody></table>
</div>
<h2 id="basic-effect-patterns"><a class="header" href="#basic-effect-patterns">Basic Effect Patterns</a></h2>
<h3 id="veto-effect"><a class="header" href="#veto-effect">Veto Effect</a></h3>
<p>Reject transactions by throwing errors:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'veto-invalid-age' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person ex:age ?age . FILTER (?age &lt; 0) }'
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      // Veto: throws error, transaction fails
      throw new Error('Age cannot be negative');
    }
  }
});
</code></pre>
<h3 id="log-effect"><a class="header" href="#log-effect">Log Effect</a></h3>
<p>Record events for audit trails:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'audit-person-changes' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('rdf:type'), object: namedNode('foaf:Person') }
  },
  run: async (event) =&gt; {
    // Log effect: record to audit log
    await auditLog.write({
      timestamp: new Date().toISOString(),
      actor: event.payload.actor,
      action: 'person-change',
      additions: event.delta.additions.length,
      removals: event.delta.removals.length
    });

    console.log(`Audit: Person changed by ${event.payload.actor}`);

    return { result: 'logged' };
  }
});
</code></pre>
<h3 id="notify-effect"><a class="header" href="#notify-effect">Notify Effect</a></h3>
<p>Send notifications to external systems:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'large-transaction-alert' },
  when: {
    kind: 'threshold',
    value: 10000,
    operator: 'gt'
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      // Notify effect: send alert
      await fetch('https://api.example.com/alerts', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          type: 'large-transaction',
          value: event.result.value,
          threshold: event.result.threshold,
          timestamp: new Date().toISOString()
        })
      });

      return { result: 'alert-sent' };
    }
  }
});
</code></pre>
<h3 id="transform-effect"><a class="header" href="#transform-effect">Transform Effect</a></h3>
<p>Modify data before it's committed:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'normalize-email' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('foaf:mbox') }
  },
  run: async (event) =&gt; {
    const normalized = [];

    for (const quad of event.delta.additions) {
      const email = quad.object.value;
      const normalizedEmail = email.toLowerCase().trim();

      // Transform effect: replace with normalized email
      normalized.push(
        quad(
          quad.subject,
          quad.predicate,
          literal(normalizedEmail)
        )
      );
    }

    return {
      result: 'normalized',
      deltas: {
        removals: event.delta.additions,
        additions: normalized
      }
    };
  }
});
</code></pre>
<h3 id="assert-effect"><a class="header" href="#assert-effect">Assert Effect</a></h3>
<p>Add inferred knowledge:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'infer-reciprocal-friendship' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('foaf:knows') }
  },
  run: async (event) =&gt; {
    const assertions = [];

    for (const quad of event.delta.additions) {
      // Assert effect: add reciprocal relationship
      assertions.push(
        quad(
          quad.object, // Reverse: friend knows person back
          quad.predicate,
          quad.subject
        )
      );
    }

    return {
      result: 'reciprocals-added',
      assertions
    };
  }
});
</code></pre>
<h2 id="effect-sandboxing"><a class="header" href="#effect-sandboxing">Effect Sandboxing</a></h2>
<p>All hook effects run in <strong>isolated sandboxes</strong> for security:</p>
<pre><code class="language-javascript">// Sandbox automatically applied
defineHook({
  meta: { name: 'sandboxed-effect' },
  when: { kind: 'delta', pattern: {} },
  run: async (event) =&gt; {
    // ‚úÖ Allowed: Graph access
    const graph = event.context.graph;

    // ‚úÖ Allowed: Environment variables
    const apiKey = event.context.env.API_KEY;

    // ‚úÖ Allowed: Safe APIs
    await fetch('https://api.example.com/webhook');

    // ‚ùå Blocked: Filesystem access
    // await fs.readFile('./secret.txt'); // Error!

    // ‚ùå Blocked: Process manipulation
    // process.exit(1); // Error!

    // ‚ùå Blocked: Arbitrary code execution
    // eval('malicious code'); // Error!
  }
});
</code></pre>
<h3 id="sandbox-configuration"><a class="header" href="#sandbox-configuration">Sandbox Configuration</a></h3>
<p>Control sandbox restrictions:</p>
<pre><code class="language-javascript">import { createDarkMatterCore } from 'unrdf';

const system = await createDarkMatterCore({
  hooks: {
    sandbox: {
      // Allow network access
      allowNetwork: true,

      // Allow specific domains only
      allowedDomains: ['api.example.com', 'webhook.slack.com'],

      // Timeout for effects
      timeout: 30000, // 30 seconds

      // Memory limit
      maxMemory: '128MB',

      // CPU time limit
      maxCpuTime: 10000 // 10 seconds
    }
  }
});
</code></pre>
<h2 id="effect-execution-order"><a class="header" href="#effect-execution-order">Effect Execution Order</a></h2>
<p>Effects execute in this order:</p>
<pre><code>1. Before phase (all hooks)
2. Condition evaluation (all hooks)
3. Run phase (all hooks, parallel by default)
4. After phase (all hooks)
</code></pre>
<h3 id="sequential-execution"><a class="header" href="#sequential-execution">Sequential Execution</a></h3>
<p>Force hooks to run sequentially:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'sequential-effect',
    priority: 1, // Lower priority runs first
    sequential: true
  },
  when: { kind: 'delta', pattern: {} },
  run: async (event) =&gt; {
    // Runs sequentially with other sequential hooks
  }
});
</code></pre>
<h3 id="dependency-management"><a class="header" href="#dependency-management">Dependency Management</a></h3>
<p>Specify hook dependencies:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'dependent-effect',
    dependencies: ['prerequisite-hook']
  },
  when: { kind: 'delta', pattern: {} },
  run: async (event) =&gt; {
    // Runs after 'prerequisite-hook' completes
  }
});
</code></pre>
<h2 id="complete-effect-examples"><a class="header" href="#complete-effect-examples">Complete Effect Examples</a></h2>
<h3 id="example-1-multi-effect-hook"><a class="header" href="#example-1-multi-effect-hook">Example 1: Multi-Effect Hook</a></h3>
<p>Combine multiple effects:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'comprehensive-person-hook' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('rdf:type'), object: namedNode('foaf:Person') }
  },

  async before({ payload }) {
    // Effect 1: Validate
    if (!payload.actor) {
      return { cancel: true, reason: 'Actor required' };
    }
    return payload;
  },

  async run(event) {
    const additions = event.delta.additions;

    // Effect 2: Log
    await auditLog.write({
      action: 'person-added',
      count: additions.length,
      actor: event.payload.actor
    });

    // Effect 3: Transform (add timestamps)
    const timestamped = additions.map(quad =&gt;
      quad(
        quad.subject,
        namedNode('ex:createdAt'),
        literal(new Date().toISOString())
      )
    );

    // Effect 4: Assert (infer role)
    const roleAssertions = additions.map(quad =&gt;
      quad(
        quad.subject,
        namedNode('ex:role'),
        literal('user')
      )
    );

    // Effect 5: Notify
    await fetch('https://api.example.com/webhooks/new-person', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        count: additions.length,
        actor: event.payload.actor
      })
    });

    return {
      result: 'person-added',
      assertions: [...timestamped, ...roleAssertions]
    };
  },

  async after({ result, cancelled }) {
    // Effect 6: Metrics
    if (!cancelled) {
      await metrics.increment('person.added');
    }

    return { status: 'completed' };
  }
});
</code></pre>
<h3 id="example-2-conditional-effects"><a class="header" href="#example-2-conditional-effects">Example 2: Conditional Effects</a></h3>
<p>Apply effects based on conditions:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'conditional-pricing' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('ex:price') }
  },
  run: async (event) =&gt; {
    const effects = [];

    for (const quad of event.delta.additions) {
      const price = parseFloat(quad.object.value);

      // Conditional effect: different actions for different price ranges
      if (price &gt; 10000) {
        // High-value: require approval
        effects.push({
          type: 'assertion',
          quad: quad(
            quad.subject,
            namedNode('ex:requiresApproval'),
            literal('true')
          )
        });

        // High-value: notify management
        await sendNotification({
          to: 'management@example.com',
          subject: 'High-value product',
          price
        });
      } else if (price &gt; 1000) {
        // Medium-value: flag for review
        effects.push({
          type: 'assertion',
          quad: quad(
            quad.subject,
            namedNode('ex:flagged'),
            literal('review')
          )
        });
      }
      // Low-value: no special handling
    }

    const assertions = effects
      .filter(e =&gt; e.type === 'assertion')
      .map(e =&gt; e.quad);

    return {
      result: 'pricing-processed',
      assertions
    };
  }
});
</code></pre>
<h3 id="example-3-error-recovery-effect"><a class="header" href="#example-3-error-recovery-effect">Example 3: Error Recovery Effect</a></h3>
<p>Graceful degradation:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'resilient-notification' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('ex:status'), object: literal('published') }
  },
  run: async (event) =&gt; {
    const notifications = [];

    // Try primary notification channel
    try {
      await sendEmail(event.delta.additions);
      notifications.push({ channel: 'email', status: 'success' });
    } catch (error) {
      console.error('Email notification failed:', error);
      notifications.push({ channel: 'email', status: 'failed' });

      // Fallback to secondary channel
      try {
        await sendSlack(event.delta.additions);
        notifications.push({ channel: 'slack', status: 'success' });
      } catch (fallbackError) {
        console.error('Slack notification failed:', fallbackError);
        notifications.push({ channel: 'slack', status: 'failed' });

        // Last resort: queue for retry
        await retryQueue.add({
          type: 'notification',
          data: event.delta.additions
        });
        notifications.push({ channel: 'queue', status: 'queued' });
      }
    }

    return {
      result: 'notification-attempted',
      notifications
    };
  }
});
</code></pre>
<h3 id="example-4-batch-effect"><a class="header" href="#example-4-batch-effect">Example 4: Batch Effect</a></h3>
<p>Process changes in batches:</p>
<pre><code class="language-javascript">const batchQueue = [];
let batchTimer = null;

defineHook({
  meta: { name: 'batched-index-update' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('foaf:name') }
  },
  run: async (event) =&gt; {
    // Add to batch queue
    batchQueue.push(...event.delta.additions);

    // Clear existing timer
    if (batchTimer) {
      clearTimeout(batchTimer);
    }

    // Schedule batch processing
    batchTimer = setTimeout(async () =&gt; {
      if (batchQueue.length === 0) return;

      const batch = [...batchQueue];
      batchQueue.length = 0;

      // Process entire batch at once
      await searchIndex.batchUpdate(batch);

      console.log(`Batch processed: ${batch.length} items`);
    }, 5000); // 5 second delay

    return { result: 'queued-for-batch' };
  }
});
</code></pre>
<h2 id="effect-return-values"><a class="header" href="#effect-return-values">Effect Return Values</a></h2>
<p>Effects can return structured results:</p>
<pre><code class="language-javascript">return {
  result: any,              // Primary result
  assertions: [Quad],       // RDF quads to add
  deltas: {                 // Complex changes
    additions: [Quad],
    removals: [Quad]
  },
  cancelled: boolean,       // Cancel flag
  reason: string           // Cancellation reason
};
</code></pre>
<h2 id="error-handling-in-effects"><a class="header" href="#error-handling-in-effects">Error Handling in Effects</a></h2>
<h3 id="graceful-errors"><a class="header" href="#graceful-errors">Graceful Errors</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  try {
    await riskyOperation();
    return { result: 'success' };
  } catch (error) {
    console.error('Operation failed:', error);

    // Don't fail transaction, just log
    return {
      result: 'failed',
      error: error.message
    };
  }
}
</code></pre>
<h3 id="critical-errors"><a class="header" href="#critical-errors">Critical Errors</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  try {
    await criticalOperation();
    return { result: 'success' };
  } catch (error) {
    // Fail transaction on critical error
    throw new Error(`Critical failure: ${error.message}`);
  }
}
</code></pre>
<h2 id="performance-optimization"><a class="header" href="#performance-optimization">Performance Optimization</a></h2>
<h3 id="async-fire-and-forget"><a class="header" href="#async-fire-and-forget">Async Fire-and-Forget</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  // Don't await non-critical operations
  sendNotification(event).catch(console.error);

  // Continue immediately
  return { result: 'processing' };
}
</code></pre>
<h3 id="parallel-effects"><a class="header" href="#parallel-effects">Parallel Effects</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  // Run multiple effects in parallel
  const [logged, notified, indexed] = await Promise.all([
    auditLog.write(event),
    sendNotification(event),
    searchIndex.update(event)
  ]);

  return {
    result: 'all-effects-applied',
    logged,
    notified,
    indexed
  };
}
</code></pre>
<h2 id="best-practices-6"><a class="header" href="#best-practices-6">Best Practices</a></h2>
<h3 id="-dos"><a class="header" href="#-dos">‚úÖ Do's</a></h3>
<pre><code class="language-javascript">// ‚úÖ Use descriptive result objects
return {
  result: 'email-normalized',
  count: normalized.length,
  actor: event.payload.actor
};

// ‚úÖ Handle errors gracefully
try {
  await effect();
} catch (error) {
  console.error('Effect failed:', error);
  return { result: 'failed', error: error.message };
}

// ‚úÖ Return meaningful data
return {
  result: 'processed',
  assertions: newTriples,
  metadata: { timestamp: new Date().toISOString() }
};

// ‚úÖ Use appropriate effect types
// Veto for validation
// Log for audit
// Notify for alerts
// Transform for data modification
</code></pre>
<h3 id="-donts"><a class="header" href="#-donts">‚ùå Don'ts</a></h3>
<pre><code class="language-javascript">// ‚ùå Don't return just strings
return 'ok';

// ‚ùå Don't swallow errors silently
try {
  await effect();
} catch (error) {
  // Silent failure!
}

// ‚ùå Don't block on slow operations
await slowExternalAPI(); // Consider async

// ‚ùå Don't mutate event object
event.payload.modified = true; // Readonly!
</code></pre>
<h2 id="next-steps-9"><a class="header" href="#next-steps-9">Next Steps</a></h2>
<ul>
<li><strong><a href="hooks/policy-packs.html">Policy Packs</a></strong> - Organize hooks and effects into packages</li>
<li><strong><a href="hooks/lifecycle.html">Lifecycle</a></strong> - Understand hook execution phases</li>
<li><strong><a href="hooks/predicates.html">Predicates</a></strong> - Trigger conditions for effects</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="predicates-overview"><a class="header" href="#predicates-overview">Predicates Overview</a></h1>
<p>Predicates are the <strong>condition types</strong> that determine when a Knowledge Hook triggers. UNRDF supports multiple predicate types, each optimized for different use cases.</p>
<h2 id="predicate-types"><a class="header" href="#predicate-types">Predicate Types</a></h2>
<div class="table-wrapper"><table><thead><tr><th>Type</th><th>Purpose</th><th>Returns</th><th>Use Case</th></tr></thead><tbody>
<tr><td><strong>ASK</strong></td><td>Boolean condition</td><td><code>true|false</code></td><td>Existence checks, validation</td></tr>
<tr><td><strong>SELECT</strong></td><td>Result bindings</td><td><code>Array&lt;Object&gt;</code></td><td>Data queries, analysis</td></tr>
<tr><td><strong>SHACL</strong></td><td>Shape validation</td><td><code>{conforms, results}</code></td><td>Schema validation</td></tr>
<tr><td><strong>DELTA</strong></td><td>Change detection</td><td><code>{changed}</code></td><td>Reactive updates</td></tr>
<tr><td><strong>THRESHOLD</strong></td><td>Numeric comparison</td><td><code>{satisfied, value}</code></td><td>Limits, quotas</td></tr>
<tr><td><strong>COUNT</strong></td><td>Cardinality</td><td><code>{count, satisfied}</code></td><td>Size limits</td></tr>
<tr><td><strong>WINDOW</strong></td><td>Time-based</td><td><code>{count, duration}</code></td><td>Rate limiting</td></tr>
</tbody></table>
</div>
<h2 id="how-predicates-work"><a class="header" href="#how-predicates-work">How Predicates Work</a></h2>
<p>Predicates define the <code>when</code> clause of a hook:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'my-hook' },

  // Predicate: defines trigger condition
  when: {
    kind: 'sparql-ask',  // Predicate type
    query: 'ASK { ... }' // Condition logic
  },

  // Effect: executes when predicate is satisfied
  run: async (event) =&gt; {
    // event.result contains predicate evaluation result
  }
});
</code></pre>
<h2 id="inline-vs-file-based-predicates"><a class="header" href="#inline-vs-file-based-predicates">Inline vs. File-Based Predicates</a></h2>
<h3 id="inline-queries-development"><a class="header" href="#inline-queries-development">Inline Queries (Development)</a></h3>
<p>For rapid development and testing:</p>
<pre><code class="language-javascript">when: {
  kind: 'sparql-ask',
  query: `
    PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
    ASK {
      ?person a foaf:Person .
      FILTER NOT EXISTS { ?person foaf:name ?name }
    }
  `
}
</code></pre>
<p>‚úÖ <strong>Pros:</strong> Quick to write, easy to debug
‚ùå <strong>Cons:</strong> Not versioned, no cryptographic proof</p>
<h3 id="file-based-references-production"><a class="header" href="#file-based-references-production">File-Based References (Production)</a></h3>
<p>For production systems:</p>
<pre><code class="language-javascript">when: {
  kind: 'sparql-ask',
  ref: {
    uri: 'file://hooks/compliance/person-name-required.ask.rq',
    sha256: 'e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855',
    mediaType: 'application/sparql-query'
  }
}
</code></pre>
<p>‚úÖ <strong>Pros:</strong> Versioned, content-addressed, cryptographic proof
‚ùå <strong>Cons:</strong> Requires file management</p>
<pre><code class="language-admonish info">UNRDF supports both approaches. Use inline queries for development, migrate to file-based references for production.
</code></pre>
<h2 id="combining-predicates"><a class="header" href="#combining-predicates">Combining Predicates</a></h2>
<h3 id="sequential-evaluation-and"><a class="header" href="#sequential-evaluation-and">Sequential Evaluation (AND)</a></h3>
<p>Use multiple hooks for AND logic:</p>
<pre><code class="language-javascript">// Hook 1: Check age
defineHook({
  meta: { name: 'check-age' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person ex:age ?age . FILTER (?age &gt;= 18) }'
  },
  run: async (event) =&gt; {
    if (!event.result) throw new Error('Must be 18+');
  }
});

// Hook 2: Check consent
defineHook({
  meta: { name: 'check-consent' },
  when: {
    kind: 'sparql-ask',
    query: 'ASK { ?person ex:hasConsent true }'
  },
  run: async (event) =&gt; {
    if (!event.result) throw new Error('Consent required');
  }
});

// Both hooks must pass (AND logic)
</code></pre>
<h3 id="parallel-evaluation-or"><a class="header" href="#parallel-evaluation-or">Parallel Evaluation (OR)</a></h3>
<p>Use single hook with SPARQL UNION:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'check-age-or-guardian' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        {
          # Condition 1: Age &gt;= 18
          ?person ex:age ?age .
          FILTER (?age &gt;= 18)
        }
        UNION
        {
          # Condition 2: Has guardian
          ?person ex:hasGuardian ?guardian
        }
      }
    `
  },
  run: async (event) =&gt; {
    if (!event.result) {
      throw new Error('Must be 18+ or have a guardian');
    }
  }
});
</code></pre>
<h3 id="complex-logic"><a class="header" href="#complex-logic">Complex Logic</a></h3>
<p>Use SPARQL <code>FILTER</code> for advanced conditions:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'complex-validation' },
  when: {
    kind: 'sparql-ask',
    query: `
      ASK {
        ?person a foaf:Person ;
                ex:age ?age ;
                ex:country ?country .

        # Complex logic: (age &gt;= 18) OR (age &gt;= 16 AND country = 'UK')
        FILTER (
          ?age &gt;= 18 ||
          (?age &gt;= 16 &amp;&amp; ?country = 'UK')
        )
      }
    `
  },
  run: async (event) =&gt; {
    if (!event.result) {
      throw new Error('Age requirements not met');
    }
  }
});
</code></pre>
<h2 id="predicate-evaluation-order"><a class="header" href="#predicate-evaluation-order">Predicate Evaluation Order</a></h2>
<p>UNRDF evaluates predicates in this order:</p>
<ol>
<li><strong>Before phase</strong> (if defined)</li>
<li><strong>Predicate evaluation</strong> (when clause)</li>
<li><strong>Run phase</strong> (if predicate satisfied)</li>
<li><strong>After phase</strong> (if defined)</li>
</ol>
<pre><code>Transaction
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Before  ‚îÇ ‚Üê Fast validation, normalization
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ When    ‚îÇ ‚Üê Predicate evaluation (SPARQL, SHACL, etc.)
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚îÇ
   Satisfied?
     ‚îÇ
    Yes
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ  Run    ‚îÇ ‚Üê Main effect
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îò
     ‚Üì
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ After   ‚îÇ ‚Üê Cleanup, audit
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<h2 id="custom-predicate-creation"><a class="header" href="#custom-predicate-creation">Custom Predicate Creation</a></h2>
<p>You can create custom predicates by combining existing ones:</p>
<pre><code class="language-javascript">// Custom predicate: "large person dataset"
function createLargePersonDatasetPredicate(threshold = 10000) {
  return {
    kind: 'sparql-select',
    query: `
      SELECT (COUNT(?person) AS ?count)
      WHERE {
        ?person a foaf:Person
      }
    `,
    evaluator: async (result) =&gt; {
      const count = result[0]?.count?.value || 0;
      return {
        satisfied: count &gt; threshold,
        count: parseInt(count),
        threshold
      };
    }
  };
}

// Use custom predicate
defineHook({
  meta: { name: 'limit-person-dataset' },
  when: createLargePersonDatasetPredicate(10000),
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      throw new Error(`Dataset too large: ${event.result.count} persons`);
    }
  }
});
</code></pre>
<h2 id="performance-optimization-1"><a class="header" href="#performance-optimization-1">Performance Optimization</a></h2>
<h3 id="cache-predicate-results"><a class="header" href="#cache-predicate-results">Cache Predicate Results</a></h3>
<pre><code class="language-javascript">const predicateCache = new Map();

when: {
  kind: 'sparql-ask',
  query: 'ASK { ... }',
  cache: {
    enabled: true,
    ttl: 60000 // Cache for 60 seconds
  }
}
</code></pre>
<h3 id="use-early-termination"><a class="header" href="#use-early-termination">Use Early Termination</a></h3>
<pre><code class="language-javascript">before: async ({ payload }) =&gt; {
  // Fast check before expensive SPARQL
  if (!payload.additions || payload.additions.length === 0) {
    return { cancel: true, reason: 'No additions' };
  }
  return payload;
}
</code></pre>
<h3 id="optimize-sparql-queries"><a class="header" href="#optimize-sparql-queries">Optimize SPARQL Queries</a></h3>
<pre><code class="language-javascript">// ‚ùå Slow: Full graph scan
ASK {
  ?person a foaf:Person .
  FILTER NOT EXISTS { ?person foaf:name ?name }
}

// ‚úÖ Fast: Limited scope
ASK {
  ?person a foaf:Person .
  FILTER NOT EXISTS {
    ?person foaf:name ?name
  }
}
LIMIT 1
</code></pre>
<h2 id="predicate-examples"><a class="header" href="#predicate-examples">Predicate Examples</a></h2>
<h3 id="ask-existence-check"><a class="header" href="#ask-existence-check">ASK: Existence Check</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'sparql-ask',
  query: `
    ASK {
      ?person a foaf:Person .
      FILTER NOT EXISTS { ?person foaf:name ?name }
    }
  `
}
</code></pre>
<h3 id="select-data-query"><a class="header" href="#select-data-query">SELECT: Data Query</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'sparql-select',
  query: `
    SELECT ?person ?age
    WHERE {
      ?person a foaf:Person ;
              ex:age ?age .
      FILTER (?age &lt; 18)
    }
  `
}
</code></pre>
<h3 id="shacl-shape-validation"><a class="header" href="#shacl-shape-validation">SHACL: Shape Validation</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'shacl',
  shapes: personShapeStore // N3.Store with SHACL shapes
}
</code></pre>
<h3 id="delta-change-detection"><a class="header" href="#delta-change-detection">DELTA: Change Detection</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'delta',
  pattern: {
    predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
    object: namedNode('http://xmlns.com/foaf/0.1/Person')
  }
}
</code></pre>
<h3 id="threshold-numeric-comparison"><a class="header" href="#threshold-numeric-comparison">THRESHOLD: Numeric Comparison</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'threshold',
  value: 10000,
  operator: 'gt' // &gt;, &lt;, &gt;=, &lt;=, ==, !=
}
</code></pre>
<h3 id="count-cardinality"><a class="header" href="#count-cardinality">COUNT: Cardinality</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'count',
  min: 0,
  max: 10000
}
</code></pre>
<h3 id="window-time-based"><a class="header" href="#window-time-based">WINDOW: Time-Based</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'window',
  duration: '5m' // 5 minutes
}
</code></pre>
<h2 id="next-steps-10"><a class="header" href="#next-steps-10">Next Steps</a></h2>
<p>Explore each predicate type in detail:</p>
<ul>
<li><strong><a href="hooks/predicates/ask.html">ASK Predicates</a></strong> - Boolean existence checks</li>
<li><strong><a href="hooks/predicates/threshold.html">THRESHOLD Predicates</a></strong> - Numeric comparisons</li>
<li><strong><a href="hooks/predicates/delta.html">DELTA Predicates</a></strong> - Change detection</li>
<li><strong><a href="hooks/predicates/shacl.html">SHACL Predicates</a></strong> - Shape validation</li>
<li><strong><a href="hooks/predicates/custom.html">Custom Predicates</a></strong> - Build your own</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="ask-predicates"><a class="header" href="#ask-predicates">ASK Predicates</a></h1>
<p><strong>ASK predicates</strong> use SPARQL ASK queries to check for the existence of patterns in the knowledge graph. They return a boolean: <code>true</code> if the pattern exists, <code>false</code> otherwise.</p>
<h2 id="when-to-use-ask-predicates"><a class="header" href="#when-to-use-ask-predicates">When to Use ASK Predicates</a></h2>
<p>Use ASK predicates for:</p>
<ul>
<li>‚úÖ <strong>Existence checks</strong> - "Does a person without a name exist?"</li>
<li>‚úÖ <strong>Validation rules</strong> - "Are there any invalid email addresses?"</li>
<li>‚úÖ <strong>Constraint checking</strong> - "Is this invariant violated?"</li>
<li>‚úÖ <strong>Boolean conditions</strong> - "Is the age below the threshold?"</li>
</ul>
<h2 id="basic-syntax"><a class="header" href="#basic-syntax">Basic Syntax</a></h2>
<pre><code class="language-javascript">import { defineHook } from 'unrdf';

defineHook({
  meta: {
    name: 'person-name-required',
    description: 'Ensures all persons have names'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ASK {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Person without name detected');
    }
  }
});
</code></pre>
<p><strong>Explanation:</strong></p>
<ul>
<li>Query checks if any <code>foaf:Person</code> exists <strong>without</strong> a <code>foaf:name</code></li>
<li><code>event.result</code> is <code>true</code> if such a person exists</li>
<li>Hook vetoes the transaction by throwing an error</li>
</ul>
<h2 id="event-structure"><a class="header" href="#event-structure">Event Structure</a></h2>
<p>ASK predicates provide this structure to the <code>run</code> function:</p>
<pre><code class="language-javascript">{
  result: true | false,  // ASK query result
  payload: {
    additions: [...],    // Transaction additions
    removals: [...],     // Transaction removals
    actor: 'user@example.org'
  },
  context: {
    graph: Store,        // RDF graph
    env: {...}           // Environment variables
  },
  name: 'hook-name'
}
</code></pre>
<h2 id="complete-examples"><a class="header" href="#complete-examples">Complete Examples</a></h2>
<h3 id="example-1-data-quality---email-validation"><a class="header" href="#example-1-data-quality---email-validation">Example 1: Data Quality - Email Validation</a></h3>
<p>Ensure all email addresses are valid:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'email-validation',
    description: 'Ensure all email addresses are valid format'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ASK {
        ?person foaf:mbox ?email .
        # Check for invalid email format
        FILTER (!REGEX(STR(?email), "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$"))
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Invalid email address detected');
    }
    return { result: 'valid' };
  }
});
</code></pre>
<h3 id="example-2-business-rule---age-restriction"><a class="header" href="#example-2-business-rule---age-restriction">Example 2: Business Rule - Age Restriction</a></h3>
<p>Enforce minimum age requirement:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'age-restriction',
    description: 'Ensure all persons are 18 or older'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        ?person a foaf:Person ;
                ex:age ?age .
        FILTER (?age &lt; 18)
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('All persons must be 18 or older');
    }
    return { result: 'age-valid' };
  }
});
</code></pre>
<h3 id="example-3-relationship-validation"><a class="header" href="#example-3-relationship-validation">Example 3: Relationship Validation</a></h3>
<p>Ensure bidirectional friendships:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'symmetric-friendship',
    description: 'Ensure friendships are bidirectional'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ASK {
        # Check for one-way friendship
        ?person1 foaf:knows ?person2 .
        FILTER NOT EXISTS {
          ?person2 foaf:knows ?person1
        }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Friendship must be bidirectional');
    }
    return { result: 'friendship-valid' };
  }
});
</code></pre>
<h3 id="example-4-data-completeness"><a class="header" href="#example-4-data-completeness">Example 4: Data Completeness</a></h3>
<p>Ensure required fields are present:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'person-completeness',
    description: 'Ensure persons have all required fields'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        ?person a foaf:Person .

        # Missing required fields
        FILTER NOT EXISTS {
          ?person foaf:name ?name ;
                  foaf:mbox ?email ;
                  ex:age ?age
        }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Person profile incomplete: name, email, and age required');
    }
    return { result: 'complete' };
  }
});
</code></pre>
<h3 id="example-5-cycle-detection"><a class="header" href="#example-5-cycle-detection">Example 5: Cycle Detection</a></h3>
<p>Prevent cycles in hierarchies:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'prevent-cycles',
    description: 'Prevent cycles in organizational hierarchy'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX org: &lt;http://www.w3.org/ns/org#&gt;

      ASK {
        # Check if person is their own ancestor
        ?person org:reportsTo+ ?person
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Cycle detected in organizational hierarchy');
    }
    return { result: 'no-cycles' };
  }
});
</code></pre>
<h3 id="example-6-uniqueness-constraint"><a class="header" href="#example-6-uniqueness-constraint">Example 6: Uniqueness Constraint</a></h3>
<p>Ensure unique email addresses:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'unique-emails',
    description: 'Ensure email addresses are unique'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

      ASK {
        # Find duplicate emails
        ?person1 foaf:mbox ?email .
        ?person2 foaf:mbox ?email .
        FILTER (?person1 != ?person2)
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Duplicate email address detected');
    }
    return { result: 'unique' };
  }
});
</code></pre>
<h3 id="example-7-temporal-constraint"><a class="header" href="#example-7-temporal-constraint">Example 7: Temporal Constraint</a></h3>
<p>Ensure dates are logical:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'valid-date-range',
    description: 'Ensure end date is after start date'
  },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        ?event ex:startDate ?start ;
               ex:endDate ?end .
        FILTER (?end &lt; ?start)
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('End date must be after start date');
    }
    return { result: 'valid-dates' };
  }
});
</code></pre>
<h2 id="advanced-patterns"><a class="header" href="#advanced-patterns">Advanced Patterns</a></h2>
<h3 id="pattern-1-conditional-validation"><a class="header" href="#pattern-1-conditional-validation">Pattern 1: Conditional Validation</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'conditional-email-required' },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        # Email required only for employees
        ?person ex:role "employee" .
        FILTER NOT EXISTS { ?person foaf:mbox ?email }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Employees must have email addresses');
    }
  }
});
</code></pre>
<h3 id="pattern-2-multi-condition-check"><a class="header" href="#pattern-2-multi-condition-check">Pattern 2: Multi-Condition Check</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'multi-condition-validation' },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      ASK {
        ?person a foaf:Person ;
                ex:age ?age ;
                ex:salary ?salary .

        # Complex validation: age and salary must be consistent
        FILTER (
          (?age &lt; 18 &amp;&amp; ?salary &gt; 0) ||
          (?age &gt;= 65 &amp;&amp; ?salary &gt; 100000)
        )
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Age and salary combination is invalid');
    }
  }
});
</code></pre>
<h3 id="pattern-3-aggregation-check"><a class="header" href="#pattern-3-aggregation-check">Pattern 3: Aggregation Check</a></h3>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'team-size-limit' },
  when: {
    kind: 'sparql-ask',
    query: `
      PREFIX org: &lt;http://www.w3.org/ns/org#&gt;

      ASK {
        {
          SELECT ?team (COUNT(?member) AS ?count)
          WHERE {
            ?team a org:Team .
            ?member org:memberOf ?team .
          }
          GROUP BY ?team
        }
        FILTER (?count &gt; 10)
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result === true) {
      throw new Error('Team size exceeds maximum of 10 members');
    }
  }
});
</code></pre>
<h2 id="performance-optimization-2"><a class="header" href="#performance-optimization-2">Performance Optimization</a></h2>
<h3 id="use-limit-for-early-termination"><a class="header" href="#use-limit-for-early-termination">Use LIMIT for Early Termination</a></h3>
<pre><code class="language-javascript">// ‚ùå Slow: Scans entire graph
ASK {
  ?person a foaf:Person .
  FILTER NOT EXISTS { ?person foaf:name ?name }
}

// ‚úÖ Fast: Stops at first match
ASK {
  {
    SELECT ?person
    WHERE {
      ?person a foaf:Person .
      FILTER NOT EXISTS { ?person foaf:name ?name }
    }
    LIMIT 1
  }
}
</code></pre>
<h3 id="use-indexes-effectively"><a class="header" href="#use-indexes-effectively">Use Indexes Effectively</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Uses predicate index
ASK {
  ?person foaf:name ?name .  # Indexed predicate first
  ?person a foaf:Person .
}

// ‚ùå Less efficient: Type filter first
ASK {
  ?person a foaf:Person .    # Broader filter first
  ?person foaf:name ?name .
}
</code></pre>
<h3 id="cache-ask-results"><a class="header" href="#cache-ask-results">Cache ASK Results</a></h3>
<pre><code class="language-javascript">const askCache = new Map();

before: async ({ payload }) =&gt; {
  const cacheKey = `person-${payload.additions[0]?.subject.value}`;
  if (askCache.has(cacheKey)) {
    return { cancel: true, reason: 'Cached result available' };
  }
  return payload;
}
</code></pre>
<h2 id="error-handling-5"><a class="header" href="#error-handling-5">Error Handling</a></h2>
<h3 id="provide-detailed-error-messages"><a class="header" href="#provide-detailed-error-messages">Provide Detailed Error Messages</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  if (event.result === true) {
    // Query to get details
    const details = await select(event.context.graph, `
      SELECT ?person
      WHERE {
        ?person a foaf:Person .
        FILTER NOT EXISTS { ?person foaf:name ?name }
      }
      LIMIT 5
    `);

    const personList = details.map(d =&gt; d.person.value).join(', ');
    throw new Error(`Persons without names detected: ${personList}`);
  }
}
</code></pre>
<h2 id="testing-ask-predicates"><a class="header" href="#testing-ask-predicates">Testing ASK Predicates</a></h2>
<pre><code class="language-javascript">import { createDarkMatterCore, defineHook, registerHook } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';
import { describe, it, expect } from 'vitest';

describe('ASK Predicate: person-name-required', () =&gt; {
  it('should reject person without name', async () =&gt; {
    const system = await createDarkMatterCore();

    const hook = defineHook({
      meta: { name: 'person-name-required' },
      when: {
        kind: 'sparql-ask',
        query: `
          ASK {
            ?person a &lt;http://xmlns.com/foaf/0.1/Person&gt; .
            FILTER NOT EXISTS { ?person &lt;http://xmlns.com/foaf/0.1/name&gt; ?name }
          }
        `
      },
      run: async (event) =&gt; {
        if (event.result === true) {
          throw new Error('Person without name detected');
        }
      }
    });

    await registerHook(hook);

    await expect(
      system.executeTransaction({
        additions: [
          quad(
            namedNode('http://example.org/alice'),
            namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
            namedNode('http://xmlns.com/foaf/0.1/Person')
          )
        ],
        removals: [],
        actor: 'test'
      })
    ).rejects.toThrow('Person without name detected');

    await system.cleanup();
  });

  it('should allow person with name', async () =&gt; {
    const system = await createDarkMatterCore();

    // Register hook (same as above)

    await system.executeTransaction({
      additions: [
        quad(
          namedNode('http://example.org/bob'),
          namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
          namedNode('http://xmlns.com/foaf/0.1/Person')
        ),
        quad(
          namedNode('http://example.org/bob'),
          namedNode('http://xmlns.com/foaf/0.1/name'),
          literal('Bob')
        )
      ],
      removals: [],
      actor: 'test'
    });

    // Should not throw
    await system.cleanup();
  });
});
</code></pre>
<h2 id="best-practices-7"><a class="header" href="#best-practices-7">Best Practices</a></h2>
<h3 id="-dos-1"><a class="header" href="#-dos-1">‚úÖ Do's</a></h3>
<pre><code class="language-javascript">// ‚úÖ Use descriptive hook names
meta: { name: 'person-name-required' }

// ‚úÖ Add comments to complex queries
query: `
  # Check for persons without names
  ASK {
    ?person a foaf:Person .
    FILTER NOT EXISTS { ?person foaf:name ?name }
  }
`

// ‚úÖ Provide helpful error messages
if (event.result === true) {
  throw new Error('Person without name detected. All persons must have foaf:name.');
}

// ‚úÖ Use PREFIX declarations
query: `
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  ASK { ... }
`
</code></pre>
<h3 id="-donts-1"><a class="header" href="#-donts-1">‚ùå Don'ts</a></h3>
<pre><code class="language-javascript">// ‚ùå Don't use vague hook names
meta: { name: 'hook1' }

// ‚ùå Don't write unreadable queries
query: `ASK{?s&lt;http://xmlns.com/foaf/0.1/name&gt;?o}`

// ‚ùå Don't use generic error messages
if (event.result === true) {
  throw new Error('Validation failed');
}

// ‚ùå Don't hardcode long URIs
query: `
  ASK {
    ?person a &lt;http://xmlns.com/foaf/0.1/Person&gt; .
  }
`
</code></pre>
<h2 id="next-steps-11"><a class="header" href="#next-steps-11">Next Steps</a></h2>
<ul>
<li><strong><a href="hooks/predicates/threshold.html">THRESHOLD Predicates</a></strong> - Numeric comparisons and limits</li>
<li><strong><a href="hooks/predicates/delta.html">DELTA Predicates</a></strong> - React to specific changes</li>
<li><strong><a href="hooks/predicates/shacl.html">SHACL Predicates</a></strong> - Shape-based validation</li>
<li><strong><a href="hooks/predicates/custom.html">Custom Predicates</a></strong> - Build your own predicate types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="shacl-predicates"><a class="header" href="#shacl-predicates">SHACL Predicates</a></h1>
<p><strong>SHACL predicates</strong> use SHACL (Shapes Constraint Language) shapes to validate RDF data structure and constraints. They're perfect for schema validation and data quality enforcement.</p>
<h2 id="when-to-use-shacl-predicates"><a class="header" href="#when-to-use-shacl-predicates">When to Use SHACL Predicates</a></h2>
<p>Use SHACL predicates for:</p>
<ul>
<li>‚úÖ <strong>Schema validation</strong> - "Does data match the expected shape?"</li>
<li>‚úÖ <strong>Structural constraints</strong> - "Required properties, cardinality, datatypes"</li>
<li>‚úÖ <strong>Data quality</strong> - "Value ranges, patterns, uniqueness"</li>
<li>‚úÖ <strong>Complex validation</strong> - "Multi-property constraints, dependencies"</li>
</ul>
<h2 id="basic-syntax-1"><a class="header" href="#basic-syntax-1">Basic Syntax</a></h2>
<pre><code class="language-javascript">import { defineHook } from 'unrdf';
import { parseTurtle } from 'unrdf';

// Define SHACL shape
const personShape = await parseTurtle(`
  @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
  @prefix ex: &lt;http://example.org/&gt; .

  ex:PersonShape
    a sh:NodeShape ;
    sh:targetClass foaf:Person ;
    sh:property [
      sh:path foaf:name ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:string ;
    ] ;
    sh:property [
      sh:path foaf:mbox ;
      sh:minCount 1 ;
      sh:pattern "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$" ;
    ] .
`);

defineHook({
  meta: {
    name: 'person-shape-validation',
    description: 'Validate person data against SHACL shape'
  },
  when: {
    kind: 'shacl',
    shapes: personShape
  },
  run: async (event) =&gt; {
    if (!event.result.conforms) {
      const violations = event.result.results.map(r =&gt;
        `${r.path}: ${r.message}`
      ).join(', ');

      throw new Error(`SHACL validation failed: ${violations}`);
    }
  }
});
</code></pre>
<h2 id="event-structure-1"><a class="header" href="#event-structure-1">Event Structure</a></h2>
<p>SHACL predicates provide this structure to the <code>run</code> function:</p>
<pre><code class="language-javascript">{
  result: {
    conforms: false,      // Whether data conforms to shapes
    results: [            // Validation results (if !conforms)
      {
        path: 'foaf:name',
        message: 'Property needs to have at least 1 value',
        severity: 'Violation',
        focusNode: 'http://example.org/alice',
        sourceConstraintComponent: 'MinCountConstraintComponent'
      }
    ]
  },
  payload: {
    additions: [...],
    removals: [...],
    actor: 'user@example.org'
  },
  context: {
    graph: Store,
    env: {...}
  },
  name: 'hook-name'
}
</code></pre>
<h2 id="complete-examples-1"><a class="header" href="#complete-examples-1">Complete Examples</a></h2>
<h3 id="example-1-person-profile-validation"><a class="header" href="#example-1-person-profile-validation">Example 1: Person Profile Validation</a></h3>
<p>Validate complete person profiles:</p>
<pre><code class="language-javascript">const personProfileShape = await parseTurtle(`
  @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
  @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
  @prefix ex: &lt;http://example.org/&gt; .
  @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

  ex:PersonProfileShape
    a sh:NodeShape ;
    sh:targetClass foaf:Person ;

    # Name (required, string, 1-100 chars)
    sh:property [
      sh:path foaf:name ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:string ;
      sh:minLength 1 ;
      sh:maxLength 100 ;
    ] ;

    # Email (required, valid format)
    sh:property [
      sh:path foaf:mbox ;
      sh:minCount 1 ;
      sh:pattern "^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$" ;
    ] ;

    # Age (optional, 0-150)
    sh:property [
      sh:path ex:age ;
      sh:maxCount 1 ;
      sh:datatype xsd:integer ;
      sh:minInclusive 0 ;
      sh:maxInclusive 150 ;
    ] ;

    # Phone (optional, E.164 format)
    sh:property [
      sh:path foaf:phone ;
      sh:maxCount 1 ;
      sh:pattern "^\\+[1-9]\\d{1,14}$" ;
    ] .
`);

defineHook({
  meta: {
    name: 'person-profile-validation',
    description: 'Validate person profile completeness and correctness'
  },
  when: {
    kind: 'shacl',
    shapes: personProfileShape
  },
  run: async (event) =&gt; {
    if (!event.result.conforms) {
      const violations = event.result.results.map(r =&gt;
        `  - ${r.path || 'unknown'}: ${r.message} (focus: ${r.focusNode})`
      ).join('\n');

      throw new Error(
        `Person profile validation failed:\n${violations}`
      );
    }

    return { result: 'valid', violations: 0 };
  }
});
</code></pre>
<h3 id="example-2-organization-structure-validation"><a class="header" href="#example-2-organization-structure-validation">Example 2: Organization Structure Validation</a></h3>
<p>Validate organizational hierarchy:</p>
<pre><code class="language-javascript">const orgStructureShape = await parseTurtle(`
  @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
  @prefix org: &lt;http://www.w3.org/ns/org#&gt; .
  @prefix ex: &lt;http://example.org/&gt; .

  ex:OrganizationShape
    a sh:NodeShape ;
    sh:targetClass org:Organization ;

    # Every organization must have a name
    sh:property [
      sh:path org:identifier ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:string ;
    ] ;

    # Organizations can have members
    sh:property [
      sh:path org:hasMember ;
      sh:class foaf:Person ;
    ] ;

    # Organizations can have sub-organizations
    sh:property [
      sh:path org:hasSubOrganization ;
      sh:class org:Organization ;
    ] .

  ex:EmployeeShape
    a sh:NodeShape ;
    sh:targetClass ex:Employee ;

    # Every employee must belong to exactly one organization
    sh:property [
      sh:path org:memberOf ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:class org:Organization ;
    ] ;

    # Every employee must have an employee ID
    sh:property [
      sh:path ex:employeeId ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:string ;
      sh:pattern "^EMP\\d{6}$" ;
    ] .
`);

defineHook({
  meta: {
    name: 'org-structure-validation',
    description: 'Validate organizational structure and employee data'
  },
  when: {
    kind: 'shacl',
    shapes: orgStructureShape
  },
  run: async (event) =&gt; {
    if (!event.result.conforms) {
      const violations = event.result.results;

      throw new Error(
        `Organization structure validation failed: ${violations.length} violations`
      );
    }
  }
});
</code></pre>
<h3 id="example-3-product-catalog-validation"><a class="header" href="#example-3-product-catalog-validation">Example 3: Product Catalog Validation</a></h3>
<p>Validate product data:</p>
<pre><code class="language-javascript">const productShape = await parseTurtle(`
  @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
  @prefix ex: &lt;http://example.org/&gt; .
  @prefix xsd: &lt;http://www.w3.org/2001/XMLSchema#&gt; .

  ex:ProductShape
    a sh:NodeShape ;
    sh:targetClass ex:Product ;

    # Product name
    sh:property [
      sh:path ex:name ;
      sh:minCount 1 ;
      sh:datatype xsd:string ;
      sh:minLength 1 ;
      sh:maxLength 200 ;
    ] ;

    # SKU (unique identifier)
    sh:property [
      sh:path ex:sku ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:string ;
      sh:pattern "^[A-Z]{3}-\\d{6}$" ;
    ] ;

    # Price (must be positive)
    sh:property [
      sh:path ex:price ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:decimal ;
      sh:minExclusive 0 ;
    ] ;

    # Stock quantity (non-negative integer)
    sh:property [
      sh:path ex:stock ;
      sh:minCount 1 ;
      sh:maxCount 1 ;
      sh:datatype xsd:integer ;
      sh:minInclusive 0 ;
    ] ;

    # Category (must be IRI)
    sh:property [
      sh:path ex:category ;
      sh:minCount 1 ;
      sh:nodeKind sh:IRI ;
    ] .
`);

defineHook({
  meta: {
    name: 'product-catalog-validation',
    description: 'Validate product data for catalog integrity'
  },
  when: {
    kind: 'shacl',
    shapes: productShape
  },
  run: async (event) =&gt; {
    if (!event.result.conforms) {
      const violationsByProduct = new Map();

      for (const violation of event.result.results) {
        const product = violation.focusNode;
        if (!violationsByProduct.has(product)) {
          violationsByProduct.set(product, []);
        }
        violationsByProduct.get(product).push(violation);
      }

      const details = Array.from(violationsByProduct.entries())
        .map(([product, violations]) =&gt;
          `${product}:\n${violations.map(v =&gt; `  - ${v.path}: ${v.message}`).join('\n')}`
        )
        .join('\n\n');

      throw new Error(
        `Product catalog validation failed:\n${details}`
      );
    }
  }
});
</code></pre>
<h2 id="shacl-constraint-types"><a class="header" href="#shacl-constraint-types">SHACL Constraint Types</a></h2>
<h3 id="property-constraints"><a class="header" href="#property-constraints">Property Constraints</a></h3>
<pre><code class="language-turtle"># Cardinality
sh:minCount 1 ;
sh:maxCount 1 ;

# Datatype
sh:datatype xsd:string ;

# Value range
sh:minInclusive 0 ;
sh:maxInclusive 100 ;
sh:minExclusive 0 ;
sh:maxExclusive 100 ;

# String length
sh:minLength 1 ;
sh:maxLength 100 ;

# Pattern matching
sh:pattern "^[A-Z]{3}-\\d{6}$" ;

# Value constraints
sh:in ( "active" "inactive" "pending" ) ;

# Node kind
sh:nodeKind sh:IRI ;
sh:nodeKind sh:Literal ;
sh:nodeKind sh:BlankNode ;

# Class constraint
sh:class foaf:Person ;
</code></pre>
<h3 id="property-pair-constraints"><a class="header" href="#property-pair-constraints">Property Pair Constraints</a></h3>
<pre><code class="language-turtle"># Less than
sh:property [
  sh:path ex:startDate ;
  sh:lessThan ex:endDate ;
] ;

# Less than or equal
sh:property [
  sh:path ex:minAge ;
  sh:lessThanOrEquals ex:maxAge ;
] ;

# Equals
sh:property [
  sh:path ex:primaryEmail ;
  sh:equals ex:contactEmail ;
] ;

# Disjoint
sh:property [
  sh:path ex:firstName ;
  sh:disjoint ex:lastName ;
] ;
</code></pre>
<h3 id="logical-constraints"><a class="header" href="#logical-constraints">Logical Constraints</a></h3>
<pre><code class="language-turtle"># AND (all must conform)
sh:and (
  ex:PersonShape
  ex:EmployeeShape
) ;

# OR (at least one must conform)
sh:or (
  ex:EmailContactShape
  ex:PhoneContactShape
) ;

# XOR (exactly one must conform)
sh:xone (
  ex:IndividualShape
  ex:OrganizationShape
) ;

# NOT (must not conform)
sh:not ex:BannedUserShape ;
</code></pre>
<h3 id="qualified-value-shapes"><a class="header" href="#qualified-value-shapes">Qualified Value Shapes</a></h3>
<pre><code class="language-turtle"># At least 2 friends who are also Persons
sh:property [
  sh:path foaf:knows ;
  sh:qualifiedMinCount 2 ;
  sh:qualifiedValueShape [
    sh:class foaf:Person ;
  ] ;
] ;
</code></pre>
<h2 id="advanced-patterns-1"><a class="header" href="#advanced-patterns-1">Advanced Patterns</a></h2>
<h3 id="pattern-1-conditional-validation-1"><a class="header" href="#pattern-1-conditional-validation-1">Pattern 1: Conditional Validation</a></h3>
<pre><code class="language-turtle"># Validate email only if person is an employee
ex:ConditionalEmailShape
  a sh:NodeShape ;
  sh:targetClass foaf:Person ;
  sh:property [
    sh:path ex:role ;
    sh:equals "employee" ;
    sh:property [
      sh:path foaf:mbox ;
      sh:minCount 1 ;
    ] ;
  ] .
</code></pre>
<h3 id="pattern-2-custom-sparql-constraints"><a class="header" href="#pattern-2-custom-sparql-constraints">Pattern 2: Custom SPARQL Constraints</a></h3>
<pre><code class="language-turtle">ex:UniqueEmailShape
  a sh:NodeShape ;
  sh:targetClass foaf:Person ;
  sh:sparql [
    sh:message "Email must be unique" ;
    sh:select """
      SELECT $this
      WHERE {
        $this foaf:mbox ?email .
        ?other foaf:mbox ?email .
        FILTER ($this != ?other)
      }
    """ ;
  ] .
</code></pre>
<h3 id="pattern-3-multi-language-support"><a class="header" href="#pattern-3-multi-language-support">Pattern 3: Multi-Language Support</a></h3>
<pre><code class="language-turtle">ex:MultilingualNameShape
  a sh:NodeShape ;
  sh:targetClass ex:Product ;
  sh:property [
    sh:path ex:name ;
    sh:minCount 1 ;
    sh:uniqueLang true ;
  ] .
</code></pre>
<h2 id="performance-optimization-3"><a class="header" href="#performance-optimization-3">Performance Optimization</a></h2>
<h3 id="scope-shapes-narrowly"><a class="header" href="#scope-shapes-narrowly">Scope Shapes Narrowly</a></h3>
<pre><code class="language-turtle"># ‚úÖ Good: Specific target
sh:targetClass foaf:Person ;

# ‚ùå Slow: Validates everything
sh:targetSubjectsOf foaf:name ;
</code></pre>
<h3 id="use-simple-constraints-first"><a class="header" href="#use-simple-constraints-first">Use Simple Constraints First</a></h3>
<pre><code class="language-javascript">before: async ({ payload }) =&gt; {
  // Quick check before SHACL
  const hasPerson = payload.additions.some(
    q =&gt; q.predicate.value === 'rdf:type' &amp;&amp;
         q.object.value === 'foaf:Person'
  );

  if (!hasPerson) {
    return { cancel: true, reason: 'No persons to validate' };
  }

  return payload;
}
</code></pre>
<h2 id="error-handling-6"><a class="header" href="#error-handling-6">Error Handling</a></h2>
<h3 id="provide-detailed-error-reports"><a class="header" href="#provide-detailed-error-reports">Provide Detailed Error Reports</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  if (!event.result.conforms) {
    const report = {
      totalViolations: event.result.results.length,
      violations: event.result.results.map(v =&gt; ({
        focusNode: v.focusNode,
        path: v.path,
        message: v.message,
        severity: v.severity,
        value: v.value
      }))
    };

    console.error('SHACL Validation Report:', JSON.stringify(report, null, 2));

    throw new Error(
      `SHACL validation failed with ${report.totalViolations} violations`
    );
  }
}
</code></pre>
<h2 id="testing-shacl-predicates"><a class="header" href="#testing-shacl-predicates">Testing SHACL Predicates</a></h2>
<pre><code class="language-javascript">import { createDarkMatterCore, defineHook, registerHook, parseTurtle } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';
import { describe, it, expect } from 'vitest';

describe('SHACL Predicate: person-shape-validation', () =&gt; {
  it('should reject person without required name', async () =&gt; {
    const system = await createDarkMatterCore();

    const shapes = await parseTurtle(`
      @prefix sh: &lt;http://www.w3.org/ns/shacl#&gt; .
      @prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .
      @prefix ex: &lt;http://example.org/&gt; .

      ex:PersonShape
        a sh:NodeShape ;
        sh:targetClass foaf:Person ;
        sh:property [
          sh:path foaf:name ;
          sh:minCount 1 ;
        ] .
    `);

    const hook = defineHook({
      meta: { name: 'person-shape-validation' },
      when: {
        kind: 'shacl',
        shapes
      },
      run: async (event) =&gt; {
        if (!event.result.conforms) {
          throw new Error('SHACL validation failed');
        }
      }
    });

    await registerHook(hook);

    await expect(
      system.executeTransaction({
        additions: [
          quad(
            namedNode('http://example.org/alice'),
            namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
            namedNode('http://xmlns.com/foaf/0.1/Person')
          )
        ],
        removals: [],
        actor: 'test'
      })
    ).rejects.toThrow('SHACL validation failed');

    await system.cleanup();
  });
});
</code></pre>
<h2 id="best-practices-8"><a class="header" href="#best-practices-8">Best Practices</a></h2>
<h3 id="-dos-2"><a class="header" href="#-dos-2">‚úÖ Do's</a></h3>
<pre><code class="language-turtle"># ‚úÖ Use descriptive shape names
ex:PersonShape

# ‚úÖ Add helpful messages
sh:message "Name must be between 1 and 100 characters" ;

# ‚úÖ Use appropriate severity
sh:severity sh:Violation ;  # Blocks transaction
sh:severity sh:Warning ;    # Logs warning

# ‚úÖ Scope shapes appropriately
sh:targetClass foaf:Person ;
</code></pre>
<h3 id="-donts-2"><a class="header" href="#-donts-2">‚ùå Don'ts</a></h3>
<pre><code class="language-turtle"># ‚ùå Don't use vague messages
sh:message "Invalid" ;

# ‚ùå Don't over-constrain
sh:minLength 1 ;
sh:maxLength 10000 ;  # Too restrictive

# ‚ùå Don't validate everything
# (Use specific target classes)
</code></pre>
<h2 id="next-steps-12"><a class="header" href="#next-steps-12">Next Steps</a></h2>
<ul>
<li><strong><a href="hooks/predicates/custom.html">Custom Predicates</a></strong> - Build your own predicate types</li>
<li><strong><a href="hooks/predicates/../effects.html">Effects</a></strong> - What hooks can do with validation results</li>
<li><strong><a href="hooks/predicates/../policy-packs.html">Policy Packs</a></strong> - Bundle SHACL shapes with hooks</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="delta-predicates"><a class="header" href="#delta-predicates">DELTA Predicates</a></h1>
<p><strong>DELTA predicates</strong> detect specific changes in your knowledge graph by monitoring additions and removals. They're perfect for reactive behavior and change tracking.</p>
<h2 id="when-to-use-delta-predicates"><a class="header" href="#when-to-use-delta-predicates">When to Use DELTA Predicates</a></h2>
<p>Use DELTA predicates for:</p>
<ul>
<li>‚úÖ <strong>Change tracking</strong> - "A new person was added"</li>
<li>‚úÖ <strong>Reactive updates</strong> - "When price changes, update cache"</li>
<li>‚úÖ <strong>Audit logging</strong> - "Record all relationship changes"</li>
<li>‚úÖ <strong>Event sourcing</strong> - "Trigger workflow on status change"</li>
</ul>
<h2 id="basic-syntax-2"><a class="header" href="#basic-syntax-2">Basic Syntax</a></h2>
<pre><code class="language-javascript">import { defineHook } from 'unrdf';
import { namedNode } from '@rdfjs/data-model';

defineHook({
  meta: {
    name: 'track-person-changes',
    description: 'Log when persons are added or modified'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      object: namedNode('http://xmlns.com/foaf/0.1/Person')
    }
  },
  run: async (event) =&gt; {
    console.log(`Person change detected:`);
    console.log(`  Additions: ${event.delta.additions.length}`);
    console.log(`  Removals: ${event.delta.removals.length}`);
  }
});
</code></pre>
<h2 id="pattern-matching"><a class="header" href="#pattern-matching">Pattern Matching</a></h2>
<p>DELTA predicates match quads using patterns. You can specify any combination of subject, predicate, object, or graph:</p>
<pre><code class="language-javascript">// Match specific predicate
when: {
  kind: 'delta',
  pattern: {
    predicate: namedNode('foaf:name')
  }
}

// Match specific subject and predicate
when: {
  kind: 'delta',
  pattern: {
    subject: namedNode('http://example.org/alice'),
    predicate: namedNode('foaf:knows')
  }
}

// Match all changes (empty pattern)
when: {
  kind: 'delta',
  pattern: {}
}
</code></pre>
<h2 id="event-structure-2"><a class="header" href="#event-structure-2">Event Structure</a></h2>
<p>DELTA predicates provide this structure to the <code>run</code> function:</p>
<pre><code class="language-javascript">{
  delta: {
    additions: [
      /* RDF quads that were added */
    ],
    removals: [
      /* RDF quads that were removed */
    ]
  },
  payload: {
    additions: [...],
    removals: [...],
    actor: 'user@example.org'
  },
  context: {
    graph: Store,
    env: {...}
  },
  name: 'hook-name'
}
</code></pre>
<h2 id="complete-examples-2"><a class="header" href="#complete-examples-2">Complete Examples</a></h2>
<h3 id="example-1-audit-logging"><a class="header" href="#example-1-audit-logging">Example 1: Audit Logging</a></h3>
<p>Log all person changes:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'audit-person-changes',
    description: 'Log all person additions and modifications'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
      object: namedNode('http://xmlns.com/foaf/0.1/Person')
    }
  },
  run: async (event) =&gt; {
    const auditEntry = {
      timestamp: new Date().toISOString(),
      actor: event.payload.actor,
      additions: event.delta.additions.map(q =&gt; ({
        subject: q.subject.value,
        predicate: q.predicate.value,
        object: q.object.value
      })),
      removals: event.delta.removals.map(q =&gt; ({
        subject: q.subject.value,
        predicate: q.predicate.value,
        object: q.object.value
      }))
    };

    await auditLog.write(auditEntry);
    console.log(`Audit entry created for ${event.payload.actor}`);
  }
});
</code></pre>
<h3 id="example-2-cache-invalidation"><a class="header" href="#example-2-cache-invalidation">Example 2: Cache Invalidation</a></h3>
<p>Clear cache when data changes:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'invalidate-person-cache',
    description: 'Clear cache when person data changes'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('foaf:name')
    }
  },
  run: async (event) =&gt; {
    // Extract affected persons
    const affectedPersons = new Set();

    for (const quad of [...event.delta.additions, ...event.delta.removals]) {
      affectedPersons.add(quad.subject.value);
    }

    // Invalidate cache for each person
    for (const personIri of affectedPersons) {
      await cache.delete(`person:${personIri}`);
    }

    console.log(`Cache invalidated for ${affectedPersons.size} persons`);
  }
});
</code></pre>
<h3 id="example-3-auto-indexing"><a class="header" href="#example-3-auto-indexing">Example 3: Auto-Indexing</a></h3>
<p>Automatically update search index:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'update-search-index',
    description: 'Update search index when person names change'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('foaf:name')
    }
  },
  run: async (event) =&gt; {
    // Index new names
    for (const quad of event.delta.additions) {
      await searchIndex.add({
        iri: quad.subject.value,
        name: quad.object.value,
        type: 'person'
      });
    }

    // Remove old names
    for (const quad of event.delta.removals) {
      await searchIndex.remove(quad.subject.value);
    }

    return { indexed: event.delta.additions.length };
  }
});
</code></pre>
<h3 id="example-4-relationship-validation"><a class="header" href="#example-4-relationship-validation">Example 4: Relationship Validation</a></h3>
<p>Ensure bidirectional relationships:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'symmetric-friendship',
    description: 'Automatically create reciprocal friendships'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('foaf:knows')
    }
  },
  run: async (event) =&gt; {
    const reciprocalTriples = [];

    // For each new friendship, create reciprocal
    for (const quad of event.delta.additions) {
      const person1 = quad.subject;
      const person2 = quad.object;

      // Check if reciprocal exists
      const hasReciprocal = event.context.graph.getQuads(
        person2,
        quad.predicate,
        person1,
        null
      ).length &gt; 0;

      if (!hasReciprocal) {
        reciprocalTriples.push(
          quad(person2, quad.predicate, person1)
        );
      }
    }

    return {
      result: 'reciprocals-added',
      assertions: reciprocalTriples
    };
  }
});
</code></pre>
<h3 id="example-5-status-change-notifications"><a class="header" href="#example-5-status-change-notifications">Example 5: Status Change Notifications</a></h3>
<p>Send notifications on status changes:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'status-change-notification',
    description: 'Notify when user status changes'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('ex:status')
    }
  },
  run: async (event) =&gt; {
    for (const quad of event.delta.additions) {
      const userId = quad.subject.value;
      const newStatus = quad.object.value;

      // Find old status (in removals)
      const oldStatusQuad = event.delta.removals.find(
        q =&gt; q.subject.equals(quad.subject) &amp;&amp;
             q.predicate.equals(quad.predicate)
      );

      const oldStatus = oldStatusQuad?.object.value || 'unknown';

      await sendNotification({
        userId,
        message: `Status changed from ${oldStatus} to ${newStatus}`,
        timestamp: new Date().toISOString()
      });
    }
  }
});
</code></pre>
<h3 id="example-6-workflow-trigger"><a class="header" href="#example-6-workflow-trigger">Example 6: Workflow Trigger</a></h3>
<p>Trigger workflow on state transitions:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'order-workflow-trigger',
    description: 'Trigger workflow when order status changes to "paid"'
  },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('ex:orderStatus'),
      object: literal('paid')
    }
  },
  run: async (event) =&gt; {
    for (const quad of event.delta.additions) {
      const orderId = quad.subject.value;

      // Trigger fulfillment workflow
      await workflowEngine.start({
        workflow: 'order-fulfillment',
        input: { orderId },
        actor: event.payload.actor
      });

      console.log(`Fulfillment workflow started for order ${orderId}`);
    }
  }
});
</code></pre>
<h2 id="advanced-patterns-2"><a class="header" href="#advanced-patterns-2">Advanced Patterns</a></h2>
<h3 id="pattern-1-hash-based-change-detection"><a class="header" href="#pattern-1-hash-based-change-detection">Pattern 1: Hash-Based Change Detection</a></h3>
<p>Track content changes using hashes:</p>
<pre><code class="language-javascript">import { createHash } from 'crypto';

const contentHashes = new Map();

defineHook({
  meta: { name: 'detect-content-changes' },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('ex:description')
    }
  },
  run: async (event) =&gt; {
    for (const quad of event.delta.additions) {
      const content = quad.object.value;
      const hash = createHash('sha256').update(content).digest('hex');
      const previousHash = contentHashes.get(quad.subject.value);

      if (previousHash &amp;&amp; previousHash !== hash) {
        console.log(`Content changed for ${quad.subject.value}`);
        await notifyContentChange(quad.subject.value);
      }

      contentHashes.set(quad.subject.value, hash);
    }
  }
});
</code></pre>
<h3 id="pattern-2-aggregated-change-notifications"><a class="header" href="#pattern-2-aggregated-change-notifications">Pattern 2: Aggregated Change Notifications</a></h3>
<p>Batch notifications for multiple changes:</p>
<pre><code class="language-javascript">const changeBatch = new Map();
let batchTimer = null;

defineHook({
  meta: { name: 'batched-notifications' },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('foaf:name')
    }
  },
  run: async (event) =&gt; {
    // Add changes to batch
    for (const quad of event.delta.additions) {
      const existing = changeBatch.get(quad.subject.value) || [];
      existing.push(quad);
      changeBatch.set(quad.subject.value, existing);
    }

    // Schedule batch notification
    if (batchTimer) clearTimeout(batchTimer);

    batchTimer = setTimeout(async () =&gt; {
      const changes = Array.from(changeBatch.entries());
      await sendBatchNotification(changes);
      changeBatch.clear();
    }, 5000); // 5 second delay
  }
});
</code></pre>
<h3 id="pattern-3-conditional-reactions"><a class="header" href="#pattern-3-conditional-reactions">Pattern 3: Conditional Reactions</a></h3>
<p>React only to specific change patterns:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'price-increase-alert' },
  when: {
    kind: 'delta',
    pattern: {
      predicate: namedNode('ex:price')
    }
  },
  run: async (event) =&gt; {
    for (const addition of event.delta.additions) {
      // Find corresponding removal (old price)
      const removal = event.delta.removals.find(
        q =&gt; q.subject.equals(addition.subject) &amp;&amp;
             q.predicate.equals(addition.predicate)
      );

      if (removal) {
        const oldPrice = parseFloat(removal.object.value);
        const newPrice = parseFloat(addition.object.value);

        // Alert only on price increases &gt; 10%
        const increase = ((newPrice - oldPrice) / oldPrice) * 100;

        if (increase &gt; 10) {
          await sendAlert(
            `Price increased by ${increase.toFixed(1)}% for ${addition.subject.value}`
          );
        }
      }
    }
  }
});
</code></pre>
<h2 id="monitoring-specific-properties"><a class="header" href="#monitoring-specific-properties">Monitoring Specific Properties</a></h2>
<p>Track changes to specific predicates:</p>
<pre><code class="language-javascript">// Monitor email changes
defineHook({
  meta: { name: 'email-change-audit' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('foaf:mbox') }
  },
  run: async (event) =&gt; {
    for (const quad of event.delta.additions) {
      await auditLog.write({
        type: 'email-change',
        subject: quad.subject.value,
        newEmail: quad.object.value,
        actor: event.payload.actor,
        timestamp: new Date().toISOString()
      });
    }
  }
});

// Monitor relationship changes
defineHook({
  meta: { name: 'relationship-change-tracker' },
  when: {
    kind: 'delta',
    pattern: { predicate: namedNode('foaf:knows') }
  },
  run: async (event) =&gt; {
    console.log(`New relationships: ${event.delta.additions.length}`);
    console.log(`Removed relationships: ${event.delta.removals.length}`);
  }
});
</code></pre>
<h2 id="performance-optimization-4"><a class="header" href="#performance-optimization-4">Performance Optimization</a></h2>
<h3 id="filter-early"><a class="header" href="#filter-early">Filter Early</a></h3>
<pre><code class="language-javascript">before: async ({ payload }) =&gt; {
  // Skip if no relevant changes
  const hasPersonChanges = payload.additions.some(
    q =&gt; q.predicate.value === 'http://www.w3.org/1999/02/22-rdf-syntax-ns#type' &amp;&amp;
         q.object.value === 'http://xmlns.com/foaf/0.1/Person'
  );

  if (!hasPersonChanges) {
    return { cancel: true, reason: 'No person changes' };
  }

  return payload;
}
</code></pre>
<h3 id="batch-processing"><a class="header" href="#batch-processing">Batch Processing</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  // Process all changes in one batch
  const changes = event.delta.additions.map(quad =&gt; ({
    subject: quad.subject.value,
    predicate: quad.predicate.value,
    object: quad.object.value
  }));

  await database.batchInsert(changes);
}
</code></pre>
<h2 id="testing-delta-predicates"><a class="header" href="#testing-delta-predicates">Testing DELTA Predicates</a></h2>
<pre><code class="language-javascript">import { createDarkMatterCore, defineHook, registerHook } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';
import { describe, it, expect, vi } from 'vitest';

describe('DELTA Predicate: track-person-changes', () =&gt; {
  it('should detect person additions', async () =&gt; {
    const system = await createDarkMatterCore();
    const logSpy = vi.spyOn(console, 'log');

    const hook = defineHook({
      meta: { name: 'track-person-changes' },
      when: {
        kind: 'delta',
        pattern: {
          predicate: namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
          object: namedNode('http://xmlns.com/foaf/0.1/Person')
        }
      },
      run: async (event) =&gt; {
        console.log(`Persons added: ${event.delta.additions.length}`);
      }
    });

    await registerHook(hook);

    await system.executeTransaction({
      additions: [
        quad(
          namedNode('http://example.org/alice'),
          namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),
          namedNode('http://xmlns.com/foaf/0.1/Person')
        )
      ],
      removals: [],
      actor: 'test'
    });

    expect(logSpy).toHaveBeenCalledWith('Persons added: 1');

    await system.cleanup();
  });
});
</code></pre>
<h2 id="best-practices-9"><a class="header" href="#best-practices-9">Best Practices</a></h2>
<h3 id="-dos-3"><a class="header" href="#-dos-3">‚úÖ Do's</a></h3>
<pre><code class="language-javascript">// ‚úÖ Be specific with patterns
pattern: {
  predicate: namedNode('foaf:name')
}

// ‚úÖ Process additions and removals
for (const quad of event.delta.additions) { /* ... */ }
for (const quad of event.delta.removals) { /* ... */ }

// ‚úÖ Log meaningful information
console.log(`Person ${quad.subject.value} name changed`);

// ‚úÖ Use batch operations
await database.batchUpdate(changes);
</code></pre>
<h3 id="-donts-3"><a class="header" href="#-donts-3">‚ùå Don'ts</a></h3>
<pre><code class="language-javascript">// ‚ùå Don't use empty patterns unnecessarily
pattern: {} // Matches ALL changes!

// ‚ùå Don't ignore removals
// Only processing additions can lead to inconsistencies

// ‚ùå Don't make expensive API calls per change
for (const quad of event.delta.additions) {
  await expensiveAPI(quad); // Slow!
}

// ‚ùå Don't mutate event object
event.delta.additions.push(...); // Readonly!
</code></pre>
<h2 id="next-steps-13"><a class="header" href="#next-steps-13">Next Steps</a></h2>
<ul>
<li><strong><a href="hooks/predicates/shacl.html">SHACL Predicates</a></strong> - Shape-based validation</li>
<li><strong><a href="hooks/predicates/custom.html">Custom Predicates</a></strong> - Build your own predicate types</li>
<li><strong><a href="hooks/predicates/../effects.html">Effects</a></strong> - What hooks can do with detected changes</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="threshold-predicates"><a class="header" href="#threshold-predicates">THRESHOLD Predicates</a></h1>
<p><strong>THRESHOLD predicates</strong> evaluate numeric conditions against values in your knowledge graph. They're perfect for enforcing limits, quotas, and business rules based on quantities.</p>
<h2 id="when-to-use-threshold-predicates"><a class="header" href="#when-to-use-threshold-predicates">When to Use THRESHOLD Predicates</a></h2>
<p>Use THRESHOLD predicates for:</p>
<ul>
<li>‚úÖ <strong>Numeric limits</strong> - "Transaction amount exceeds $10,000"</li>
<li>‚úÖ <strong>Quotas</strong> - "Storage usage above 90%"</li>
<li>‚úÖ <strong>Business rules</strong> - "Discount only if purchases &gt; 100"</li>
<li>‚úÖ <strong>Monitoring</strong> - "CPU usage above threshold"</li>
</ul>
<h2 id="basic-syntax-3"><a class="header" href="#basic-syntax-3">Basic Syntax</a></h2>
<pre><code class="language-javascript">import { defineHook } from 'unrdf';

defineHook({
  meta: {
    name: 'large-transaction-alert',
    description: 'Alert on transactions exceeding $10,000'
  },
  when: {
    kind: 'threshold',
    value: 10000,
    operator: 'gt', // greater than
    query: `
      SELECT (SUM(?amount) AS ?total)
      WHERE {
        ?transaction ex:amount ?amount
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      console.log(`Large transaction alert: $${event.result.value}`);
    }
  }
});
</code></pre>
<h2 id="operators"><a class="header" href="#operators">Operators</a></h2>
<p>THRESHOLD predicates support these comparison operators:</p>
<div class="table-wrapper"><table><thead><tr><th>Operator</th><th>Meaning</th><th>Example</th></tr></thead><tbody>
<tr><td><code>gt</code></td><td>Greater than (<code>&gt;</code>)</td><td><code>value &gt; 1000</code></td></tr>
<tr><td><code>gte</code></td><td>Greater than or equal (<code>&gt;=</code>)</td><td><code>value &gt;= 1000</code></td></tr>
<tr><td><code>lt</code></td><td>Less than (<code>&lt;</code>)</td><td><code>value &lt; 100</code></td></tr>
<tr><td><code>lte</code></td><td>Less than or equal (<code>&lt;=</code>)</td><td><code>value &lt;= 100</code></td></tr>
<tr><td><code>eq</code></td><td>Equal (<code>==</code>)</td><td><code>value == 42</code></td></tr>
<tr><td><code>neq</code></td><td>Not equal (<code>!=</code>)</td><td><code>value != 0</code></td></tr>
</tbody></table>
</div>
<h2 id="event-structure-3"><a class="header" href="#event-structure-3">Event Structure</a></h2>
<p>THRESHOLD predicates provide this structure to the <code>run</code> function:</p>
<pre><code class="language-javascript">{
  result: {
    satisfied: true,     // Whether threshold condition is met
    value: 15000,        // Actual value
    threshold: 10000,    // Configured threshold
    operator: 'gt'       // Comparison operator
  },
  payload: {
    additions: [...],
    removals: [...],
    actor: 'user@example.org'
  },
  context: {
    graph: Store,
    env: {...}
  },
  name: 'hook-name'
}
</code></pre>
<h2 id="complete-examples-3"><a class="header" href="#complete-examples-3">Complete Examples</a></h2>
<h3 id="example-1-transaction-limit"><a class="header" href="#example-1-transaction-limit">Example 1: Transaction Limit</a></h3>
<p>Reject transactions exceeding a limit:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'transaction-limit',
    description: 'Reject transactions over $50,000'
  },
  when: {
    kind: 'threshold',
    value: 50000,
    operator: 'gt',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT (SUM(?amount) AS ?total)
      WHERE {
        ?transaction ex:amount ?amount
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      throw new Error(
        `Transaction exceeds limit: $${event.result.value} &gt; $${event.result.threshold}`
      );
    }
  }
});
</code></pre>
<h3 id="example-2-storage-quota"><a class="header" href="#example-2-storage-quota">Example 2: Storage Quota</a></h3>
<p>Alert when storage usage exceeds quota:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'storage-quota-alert',
    description: 'Alert when storage exceeds 90% capacity'
  },
  when: {
    kind: 'threshold',
    value: 0.9, // 90%
    operator: 'gte',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT (?used / ?total AS ?usage)
      WHERE {
        ex:system ex:storageUsed ?used ;
                  ex:storageTotal ?total
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      const percentage = (event.result.value * 100).toFixed(1);
      await sendAlert(`Storage at ${percentage}% capacity`);
    }
  }
});
</code></pre>
<h3 id="example-3-minimum-age-requirement"><a class="header" href="#example-3-minimum-age-requirement">Example 3: Minimum Age Requirement</a></h3>
<p>Ensure minimum age:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'minimum-age',
    description: 'Ensure persons are at least 18 years old'
  },
  when: {
    kind: 'threshold',
    value: 18,
    operator: 'lt',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT (MIN(?age) AS ?minAge)
      WHERE {
        ?person a foaf:Person ;
                ex:age ?age
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      throw new Error(
        `Minimum age not met: ${event.result.value} &lt; ${event.result.threshold}`
      );
    }
  }
});
</code></pre>
<h3 id="example-4-team-size-limit"><a class="header" href="#example-4-team-size-limit">Example 4: Team Size Limit</a></h3>
<p>Enforce maximum team size:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'max-team-size',
    description: 'Limit teams to 20 members'
  },
  when: {
    kind: 'threshold',
    value: 20,
    operator: 'gt',
    query: `
      PREFIX org: &lt;http://www.w3.org/ns/org#&gt;

      SELECT (COUNT(?member) AS ?count)
      WHERE {
        ?team a org:Team .
        ?member org:memberOf ?team
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      throw new Error(
        `Team size limit exceeded: ${event.result.value} members (max ${event.result.threshold})`
      );
    }
  }
});
</code></pre>
<h3 id="example-5-price-range-validation"><a class="header" href="#example-5-price-range-validation">Example 5: Price Range Validation</a></h3>
<p>Ensure prices are within acceptable range:</p>
<pre><code class="language-javascript">defineHook({
  meta: {
    name: 'price-range-validation',
    description: 'Ensure all prices are between $0.01 and $999,999.99'
  },
  when: {
    kind: 'threshold',
    value: 0,
    operator: 'lte',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT (MIN(?price) AS ?minPrice)
      WHERE {
        ?product ex:price ?price
      }
    `
  },
  run: async (event) =&gt; {
    // Check minimum price
    if (event.result.satisfied) {
      throw new Error('Price must be greater than $0');
    }
  }
});

// Companion hook for maximum price
defineHook({
  meta: {
    name: 'max-price-validation',
    description: 'Ensure prices do not exceed $999,999.99'
  },
  when: {
    kind: 'threshold',
    value: 999999.99,
    operator: 'gt',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT (MAX(?price) AS ?maxPrice)
      WHERE {
        ?product ex:price ?price
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      throw new Error(
        `Price exceeds maximum: $${event.result.value} &gt; $${event.result.threshold}`
      );
    }
  }
});
</code></pre>
<h2 id="aggregation-functions"><a class="header" href="#aggregation-functions">Aggregation Functions</a></h2>
<p>THRESHOLD predicates work with SPARQL aggregation functions:</p>
<h3 id="count"><a class="header" href="#count">COUNT</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'threshold',
  value: 1000,
  operator: 'gt',
  query: `
    SELECT (COUNT(?person) AS ?count)
    WHERE {
      ?person a foaf:Person
    }
  `
}
</code></pre>
<h3 id="sum"><a class="header" href="#sum">SUM</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'threshold',
  value: 100000,
  operator: 'gte',
  query: `
    SELECT (SUM(?amount) AS ?total)
    WHERE {
      ?transaction ex:amount ?amount
    }
  `
}
</code></pre>
<h3 id="avg"><a class="header" href="#avg">AVG</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'threshold',
  value: 3.5,
  operator: 'lt',
  query: `
    SELECT (AVG(?rating) AS ?avgRating)
    WHERE {
      ?product ex:rating ?rating
    }
  `
}
</code></pre>
<h3 id="min"><a class="header" href="#min">MIN</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'threshold',
  value: 18,
  operator: 'lt',
  query: `
    SELECT (MIN(?age) AS ?minAge)
    WHERE {
      ?person ex:age ?age
    }
  `
}
</code></pre>
<h3 id="max"><a class="header" href="#max">MAX</a></h3>
<pre><code class="language-javascript">when: {
  kind: 'threshold',
  value: 65,
  operator: 'gt',
  query: `
    SELECT (MAX(?age) AS ?maxAge)
    WHERE {
      ?person ex:age ?age
    }
  `
}
</code></pre>
<h2 id="advanced-patterns-3"><a class="header" href="#advanced-patterns-3">Advanced Patterns</a></h2>
<h3 id="pattern-1-dynamic-thresholds"><a class="header" href="#pattern-1-dynamic-thresholds">Pattern 1: Dynamic Thresholds</a></h3>
<p>Use graph data for threshold values:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'dynamic-quota' },
  when: {
    kind: 'sparql-select',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT ?currentUsage ?limit
      WHERE {
        ex:system ex:currentUsage ?currentUsage ;
                  ex:usageLimit ?limit
      }
    `
  },
  run: async (event) =&gt; {
    const { currentUsage, limit } = event.result[0];

    if (currentUsage.value &gt; limit.value) {
      throw new Error(
        `Usage ${currentUsage.value} exceeds limit ${limit.value}`
      );
    }
  }
});
</code></pre>
<h3 id="pattern-2-multi-threshold-alerts"><a class="header" href="#pattern-2-multi-threshold-alerts">Pattern 2: Multi-Threshold Alerts</a></h3>
<p>Different actions at different thresholds:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'multi-level-alerts' },
  when: {
    kind: 'sparql-select',
    query: `
      SELECT (SUM(?amount) AS ?total)
      WHERE {
        ?transaction ex:amount ?amount
      }
    `
  },
  run: async (event) =&gt; {
    const total = event.result[0]?.total?.value || 0;

    if (total &gt; 100000) {
      // Critical threshold
      await sendCriticalAlert(`Critical: Transaction total $${total}`);
      throw new Error('Transaction exceeds critical threshold');
    } else if (total &gt; 50000) {
      // Warning threshold
      await sendWarning(`Warning: Transaction total $${total}`);
    } else if (total &gt; 10000) {
      // Info threshold
      await log(`Info: Large transaction $${total}`);
    }
  }
});
</code></pre>
<h3 id="pattern-3-percentage-based-thresholds"><a class="header" href="#pattern-3-percentage-based-thresholds">Pattern 3: Percentage-Based Thresholds</a></h3>
<p>Calculate percentages for comparison:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'percentage-threshold' },
  when: {
    kind: 'threshold',
    value: 0.8, // 80%
    operator: 'gte',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT ((?active / ?total) AS ?percentage)
      WHERE {
        {
          SELECT (COUNT(?active) AS ?active)
          WHERE {
            ?person a foaf:Person ;
                    ex:status "active"
          }
        }
        {
          SELECT (COUNT(?person) AS ?total)
          WHERE {
            ?person a foaf:Person
          }
        }
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      const pct = (event.result.value * 100).toFixed(1);
      console.log(`Active users at ${pct}%`);
    }
  }
});
</code></pre>
<h2 id="time-series-monitoring"><a class="header" href="#time-series-monitoring">Time-Series Monitoring</a></h2>
<p>Monitor values over time:</p>
<pre><code class="language-javascript">defineHook({
  meta: { name: 'cpu-usage-monitor' },
  when: {
    kind: 'threshold',
    value: 80, // 80% CPU
    operator: 'gt',
    query: `
      PREFIX ex: &lt;http://example.org/&gt;

      SELECT (AVG(?cpu) AS ?avgCpu)
      WHERE {
        ?measurement ex:timestamp ?time ;
                     ex:cpuUsage ?cpu .

        # Last 5 minutes
        FILTER (?time &gt; NOW() - "PT5M"^^xsd:duration)
      }
    `
  },
  run: async (event) =&gt; {
    if (event.result.satisfied) {
      await sendAlert(
        `High CPU usage: ${event.result.value.toFixed(1)}% (5min avg)`
      );
    }
  }
});
</code></pre>
<h2 id="performance-optimization-5"><a class="header" href="#performance-optimization-5">Performance Optimization</a></h2>
<h3 id="use-efficient-aggregations"><a class="header" href="#use-efficient-aggregations">Use Efficient Aggregations</a></h3>
<pre><code class="language-javascript">// ‚úÖ Good: Single aggregation
SELECT (COUNT(?person) AS ?count)
WHERE {
  ?person a foaf:Person
}

// ‚ùå Slow: Multiple passes
SELECT ?person
WHERE {
  ?person a foaf:Person
}
# Then count in application code
</code></pre>
<h3 id="cache-threshold-queries"><a class="header" href="#cache-threshold-queries">Cache Threshold Queries</a></h3>
<pre><code class="language-javascript">const thresholdCache = new Map();
const CACHE_TTL = 60000; // 60 seconds

before: async ({ payload }) =&gt; {
  const cacheKey = 'transaction-total';
  const cached = thresholdCache.get(cacheKey);

  if (cached &amp;&amp; Date.now() - cached.timestamp &lt; CACHE_TTL) {
    // Use cached value, skip SPARQL query
    return {
      cancel: true,
      reason: 'Using cached threshold result'
    };
  }

  return payload;
}
</code></pre>
<h3 id="use-incremental-calculations"><a class="header" href="#use-incremental-calculations">Use Incremental Calculations</a></h3>
<pre><code class="language-javascript">// Track running total instead of recalculating
let runningTotal = 0;

before: async ({ payload }) =&gt; {
  // Update running total
  for (const quad of payload.additions) {
    if (quad.predicate.value === 'ex:amount') {
      runningTotal += parseFloat(quad.object.value);
    }
  }

  return { ...payload, runningTotal };
},

run: async (event) =&gt; {
  if (event.payload.runningTotal &gt; 10000) {
    throw new Error('Total exceeds threshold');
  }
}
</code></pre>
<h2 id="error-handling-7"><a class="header" href="#error-handling-7">Error Handling</a></h2>
<h3 id="provide-context-in-error-messages"><a class="header" href="#provide-context-in-error-messages">Provide Context in Error Messages</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  if (event.result.satisfied) {
    throw new Error(
      `Threshold exceeded: ${event.result.value} ${event.result.operator} ${event.result.threshold}\n` +
      `Transaction by: ${event.payload.actor}\n` +
      `Timestamp: ${new Date().toISOString()}`
    );
  }
}
</code></pre>
<h3 id="handle-missing-values"><a class="header" href="#handle-missing-values">Handle Missing Values</a></h3>
<pre><code class="language-javascript">run: async (event) =&gt; {
  // SPARQL might return undefined for aggregations with no data
  const value = event.result[0]?.total?.value;

  if (value === undefined) {
    console.warn('No data available for threshold check');
    return { result: 'skipped' };
  }

  if (value &gt; 10000) {
    throw new Error(`Threshold exceeded: ${value}`);
  }
}
</code></pre>
<h2 id="testing-threshold-predicates"><a class="header" href="#testing-threshold-predicates">Testing THRESHOLD Predicates</a></h2>
<pre><code class="language-javascript">import { createDarkMatterCore, defineHook, registerHook } from 'unrdf';
import { namedNode, quad, literal } from '@rdfjs/data-model';
import { describe, it, expect } from 'vitest';

describe('THRESHOLD Predicate: transaction-limit', () =&gt; {
  it('should reject transactions over $10,000', async () =&gt; {
    const system = await createDarkMatterCore();

    const hook = defineHook({
      meta: { name: 'transaction-limit' },
      when: {
        kind: 'threshold',
        value: 10000,
        operator: 'gt',
        query: `
          SELECT (SUM(?amount) AS ?total)
          WHERE {
            ?transaction &lt;http://example.org/amount&gt; ?amount
          }
        `
      },
      run: async (event) =&gt; {
        if (event.result.satisfied) {
          throw new Error('Transaction exceeds limit');
        }
      }
    });

    await registerHook(hook);

    await expect(
      system.executeTransaction({
        additions: [
          quad(
            namedNode('http://example.org/tx1'),
            namedNode('http://example.org/amount'),
            literal('15000', namedNode('http://www.w3.org/2001/XMLSchema#decimal'))
          )
        ],
        removals: [],
        actor: 'test'
      })
    ).rejects.toThrow('Transaction exceeds limit');

    await system.cleanup();
  });

  it('should allow transactions under $10,000', async () =&gt; {
    const system = await createDarkMatterCore();
    // ... (register hook as above)

    await system.executeTransaction({
      additions: [
        quad(
          namedNode('http://example.org/tx2'),
          namedNode('http://example.org/amount'),
          literal('5000', namedNode('http://www.w3.org/2001/XMLSchema#decimal'))
        )
      ],
      removals: [],
      actor: 'test'
    });

    // Should not throw
    await system.cleanup();
  });
});
</code></pre>
<h2 id="best-practices-10"><a class="header" href="#best-practices-10">Best Practices</a></h2>
<h3 id="-dos-4"><a class="header" href="#-dos-4">‚úÖ Do's</a></h3>
<pre><code class="language-javascript">// ‚úÖ Use meaningful threshold values
value: 10000  // Clear business meaning

// ‚úÖ Document why threshold exists
meta: {
  name: 'transaction-limit',
  description: 'Enforce regulatory limit of $10,000 per transaction'
}

// ‚úÖ Provide detailed error messages
throw new Error(
  `Transaction $${event.result.value} exceeds limit $${event.result.threshold}`
);

// ‚úÖ Use appropriate operators
operator: 'gt'  // Explicit and correct
</code></pre>
<h3 id="-donts-4"><a class="header" href="#-donts-4">‚ùå Don'ts</a></h3>
<pre><code class="language-javascript">// ‚ùå Don't use magic numbers
value: 42  // What does this mean?

// ‚ùå Don't use vague error messages
throw new Error('Limit exceeded');

// ‚ùå Don't forget to handle edge cases
// Missing check for undefined values

// ‚ùå Don't use wrong operators
operator: '&gt;'  // Should be 'gt'
</code></pre>
<h2 id="next-steps-14"><a class="header" href="#next-steps-14">Next Steps</a></h2>
<ul>
<li><strong><a href="hooks/predicates/delta.html">DELTA Predicates</a></strong> - React to specific changes in the graph</li>
<li><strong><a href="hooks/predicates/shacl.html">SHACL Predicates</a></strong> - Shape-based validation</li>
<li><strong><a href="hooks/predicates/custom.html">Custom Predicates</a></strong> - Build your own predicate types</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="custom-predicates"><a class="header" href="#custom-predicates">Custom Predicates</a></h1>
<p>Build your own predicate types to extend UNRDF's knowledge hook system with domain-specific logic.</p>
<h2 id="when-to-create-custom-predicates"><a class="header" href="#when-to-create-custom-predicates">When to Create Custom Predicates</a></h2>
<p>Create custom predicates when:</p>
<ul>
<li>‚úÖ Built-in predicates don't fit your use case</li>
<li>‚úÖ You need complex, reusable logic</li>
<li>‚úÖ Domain-specific validation is required</li>
<li>‚úÖ Integration with external systems is needed</li>
</ul>
<h2 id="predicate-interface"><a class="header" href="#predicate-interface">Predicate Interface</a></h2>
<p>All predicates must implement this interface:</p>
<pre><code class="language-javascript">{
  kind: string,           // Predicate type identifier
  evaluate: (graph, context) =&gt; Promise&lt;any&gt;, // Evaluation function
  isSatisfied: (result) =&gt; boolean            // Satisfaction check
}
</code></pre>
<h2 id="creating-a-basic-custom-predicate"><a class="header" href="#creating-a-basic-custom-predicate">Creating a Basic Custom Predicate</a></h2>
<h3 id="example-word-count-predicate"><a class="header" href="#example-word-count-predicate">Example: Word Count Predicate</a></h3>
<p>Check if text exceeds a word count:</p>
<pre><code class="language-javascript">function createWordCountPredicate(minWords, maxWords) {
  return {
    kind: 'custom:word-count',

    async evaluate(graph, context) {
      const { select } = await import('unrdf');

      // Query text content
      const results = await select(graph, `
        SELECT ?text
        WHERE {
          ?subject ex:description ?text
        }
      `);

      const totalWords = results.reduce((sum, row) =&gt; {
        const text = row.text.value;
        const wordCount = text.trim().split(/\s+/).length;
        return sum + wordCount;
      }, 0);

      return {
        totalWords,
        minWords,
        maxWords,
        satisfied: totalWords &gt;= minWords &amp;&amp; totalWords &lt;= maxWords
      };
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}

// Use the custom predicate
defineHook({
  meta: {
    name: 'word-count-validation',
    description: 'Ensure description has 100-500 words'
  },
  when: createWordCountPredicate(100, 500),
  run: async (event) =&gt; {
    if (!event.result.satisfied) {
      throw new Error(
        `Word count ${event.result.totalWords} outside range ${event.result.minWords}-${event.result.maxWords}`
      );
    }
  }
});
</code></pre>
<h2 id="complete-examples-4"><a class="header" href="#complete-examples-4">Complete Examples</a></h2>
<h3 id="example-1-geographic-distance-predicate"><a class="header" href="#example-1-geographic-distance-predicate">Example 1: Geographic Distance Predicate</a></h3>
<p>Check if locations are within a certain distance:</p>
<pre><code class="language-javascript">import { distance } from 'geo-distance';

function createGeoDistancePredicate(maxDistanceKm) {
  return {
    kind: 'custom:geo-distance',

    async evaluate(graph, context) {
      const { select } = await import('unrdf');

      // Get all location pairs
      const results = await select(graph, `
        PREFIX geo: &lt;http://www.w3.org/2003/01/geo/wgs84_pos#&gt;

        SELECT ?loc1 ?lat1 ?lon1 ?loc2 ?lat2 ?lon2
        WHERE {
          ?loc1 geo:lat ?lat1 ; geo:long ?lon1 .
          ?loc2 geo:lat ?lat2 ; geo:long ?lon2 .
          FILTER (?loc1 != ?loc2)
        }
      `);

      const violations = [];

      for (const row of results) {
        const dist = distance(
          { lat: row.lat1.value, lon: row.lon1.value },
          { lat: row.lat2.value, lon: row.lon2.value }
        );

        if (dist &gt; maxDistanceKm) {
          violations.push({
            loc1: row.loc1.value,
            loc2: row.loc2.value,
            distance: dist
          });
        }
      }

      return {
        violations,
        satisfied: violations.length === 0
      };
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}

defineHook({
  meta: {
    name: 'geo-proximity-check',
    description: 'Ensure related locations are within 100km'
  },
  when: createGeoDistancePredicate(100),
  run: async (event) =&gt; {
    if (!event.result.satisfied) {
      const details = event.result.violations
        .map(v =&gt; `${v.loc1} and ${v.loc2}: ${v.distance.toFixed(1)}km`)
        .join('\n');

      throw new Error(
        `Locations exceed 100km limit:\n${details}`
      );
    }
  }
});
</code></pre>
<h3 id="example-2-time-based-predicate"><a class="header" href="#example-2-time-based-predicate">Example 2: Time-Based Predicate</a></h3>
<p>Check if events occur within business hours:</p>
<pre><code class="language-javascript">function createBusinessHoursPredicate() {
  return {
    kind: 'custom:business-hours',

    async evaluate(graph, context) {
      const { select } = await import('unrdf');

      const results = await select(graph, `
        PREFIX ex: &lt;http://example.org/&gt;

        SELECT ?event ?timestamp
        WHERE {
          ?event ex:scheduledAt ?timestamp
        }
      `);

      const violations = [];

      for (const row of results) {
        const timestamp = new Date(row.timestamp.value);
        const hour = timestamp.getHours();
        const day = timestamp.getDay();

        // Business hours: Mon-Fri, 9am-5pm
        if (day === 0 || day === 6 || hour &lt; 9 || hour &gt;= 17) {
          violations.push({
            event: row.event.value,
            timestamp: row.timestamp.value,
            reason: day === 0 || day === 6 ? 'weekend' : 'outside hours'
          });
        }
      }

      return {
        violations,
        satisfied: violations.length === 0
      };
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}

defineHook({
  meta: {
    name: 'business-hours-check',
    description: 'Ensure events are scheduled during business hours'
  },
  when: createBusinessHoursPredicate(),
  run: async (event) =&gt; {
    if (!event.result.satisfied) {
      throw new Error(
        `${event.result.violations.length} events scheduled outside business hours`
      );
    }
  }
});
</code></pre>
<h3 id="example-3-external-api-validation"><a class="header" href="#example-3-external-api-validation">Example 3: External API Validation</a></h3>
<p>Validate data against external service:</p>
<pre><code class="language-javascript">function createEmailValidationPredicate(apiKey) {
  return {
    kind: 'custom:email-validation',

    async evaluate(graph, context) {
      const { select } = await import('unrdf');

      const results = await select(graph, `
        PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;

        SELECT ?person ?email
        WHERE {
          ?person foaf:mbox ?email
        }
      `);

      const invalidEmails = [];

      for (const row of results) {
        const email = row.email.value.replace('mailto:', '');

        // Call external email validation API
        const response = await fetch(
          `https://api.emailvalidation.com/verify?email=${email}`,
          { headers: { 'X-API-Key': apiKey } }
        );

        const data = await response.json();

        if (!data.valid) {
          invalidEmails.push({
            person: row.person.value,
            email,
            reason: data.reason
          });
        }
      }

      return {
        invalidEmails,
        satisfied: invalidEmails.length === 0
      };
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}

defineHook({
  meta: {
    name: 'external-email-validation',
    description: 'Validate emails via external API'
  },
  when: createEmailValidationPredicate(process.env.EMAIL_API_KEY),
  run: async (event) =&gt; {
    if (!event.result.satisfied) {
      const details = event.result.invalidEmails
        .map(e =&gt; `${e.email}: ${e.reason}`)
        .join('\n');

      throw new Error(
        `Invalid emails detected:\n${details}`
      );
    }
  }
});
</code></pre>
<h3 id="example-4-graph-pattern-matching"><a class="header" href="#example-4-graph-pattern-matching">Example 4: Graph Pattern Matching</a></h3>
<p>Complex pattern matching beyond SPARQL:</p>
<pre><code class="language-javascript">function createCyclicDependencyPredicate() {
  return {
    kind: 'custom:cyclic-dependency',

    async evaluate(graph, context) {
      const { select } = await import('unrdf');

      // Get all dependencies
      const results = await select(graph, `
        PREFIX ex: &lt;http://example.org/&gt;

        SELECT ?from ?to
        WHERE {
          ?from ex:dependsOn ?to
        }
      `);

      // Build dependency graph
      const dependencies = new Map();

      for (const row of results) {
        const from = row.from.value;
        const to = row.to.value;

        if (!dependencies.has(from)) {
          dependencies.set(from, new Set());
        }
        dependencies.get(from).add(to);
      }

      // Detect cycles using DFS
      const cycles = [];
      const visited = new Set();
      const recStack = new Set();

      function detectCycle(node, path = []) {
        visited.add(node);
        recStack.add(node);
        path.push(node);

        const deps = dependencies.get(node) || new Set();

        for (const dep of deps) {
          if (!visited.has(dep)) {
            if (detectCycle(dep, [...path])) {
              return true;
            }
          } else if (recStack.has(dep)) {
            // Cycle detected
            cycles.push([...path, dep]);
            return true;
          }
        }

        recStack.delete(node);
        return false;
      }

      for (const node of dependencies.keys()) {
        if (!visited.has(node)) {
          detectCycle(node);
        }
      }

      return {
        cycles,
        satisfied: cycles.length === 0
      };
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}

defineHook({
  meta: {
    name: 'prevent-cyclic-dependencies',
    description: 'Detect and prevent cyclic dependencies'
  },
  when: createCyclicDependencyPredicate(),
  run: async (event) =&gt; {
    if (!event.result.satisfied) {
      const cycleDetails = event.result.cycles
        .map(cycle =&gt; cycle.join(' ‚Üí '))
        .join('\n');

      throw new Error(
        `Cyclic dependencies detected:\n${cycleDetails}`
      );
    }
  }
});
</code></pre>
<h2 id="advanced-patterns-4"><a class="header" href="#advanced-patterns-4">Advanced Patterns</a></h2>
<h3 id="pattern-1-caching-predicate-results"><a class="header" href="#pattern-1-caching-predicate-results">Pattern 1: Caching Predicate Results</a></h3>
<pre><code class="language-javascript">const predicateCache = new Map();

function createCachedPredicate(basePredicate, ttl = 60000) {
  return {
    kind: `cached:${basePredicate.kind}`,

    async evaluate(graph, context) {
      const cacheKey = `${basePredicate.kind}:${graph.size}`;
      const cached = predicateCache.get(cacheKey);

      if (cached &amp;&amp; Date.now() - cached.timestamp &lt; ttl) {
        return cached.result;
      }

      const result = await basePredicate.evaluate(graph, context);

      predicateCache.set(cacheKey, {
        result,
        timestamp: Date.now()
      });

      return result;
    },

    isSatisfied(result) {
      return basePredicate.isSatisfied(result);
    }
  };
}

// Use cached predicate
const expensivePredicate = createExpensiveValidationPredicate();
const cached = createCachedPredicate(expensivePredicate, 30000);

defineHook({
  meta: { name: 'cached-validation' },
  when: cached,
  run: async (event) =&gt; {
    // Uses cached result if available
  }
});
</code></pre>
<h3 id="pattern-2-composable-predicates"><a class="header" href="#pattern-2-composable-predicates">Pattern 2: Composable Predicates</a></h3>
<pre><code class="language-javascript">function createComposedPredicate(predicates, operator = 'AND') {
  return {
    kind: 'custom:composed',

    async evaluate(graph, context) {
      const results = await Promise.all(
        predicates.map(p =&gt; p.evaluate(graph, context))
      );

      let satisfied;
      if (operator === 'AND') {
        satisfied = results.every(r =&gt; predicates[results.indexOf(r)].isSatisfied(r));
      } else if (operator === 'OR') {
        satisfied = results.some(r =&gt; predicates[results.indexOf(r)].isSatisfied(r));
      }

      return {
        results,
        operator,
        satisfied
      };
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}

// Compose predicates
const ageCheck = createAgePredicate(18);
const emailCheck = createEmailPredicate();
const combined = createComposedPredicate([ageCheck, emailCheck], 'AND');

defineHook({
  meta: { name: 'combined-validation' },
  when: combined,
  run: async (event) =&gt; {
    if (!event.result.satisfied) {
      throw new Error('Validation failed');
    }
  }
});
</code></pre>
<h3 id="pattern-3-predicate-factory"><a class="header" href="#pattern-3-predicate-factory">Pattern 3: Predicate Factory</a></h3>
<pre><code class="language-javascript">class PredicateFactory {
  static threshold(property, operator, value) {
    return {
      kind: 'custom:threshold',
      async evaluate(graph, context) {
        const { select } = await import('unrdf');

        const results = await select(graph, `
          SELECT (${operator.toUpperCase()}(?value) AS ?result)
          WHERE {
            ?s &lt;${property}&gt; ?value
          }
        `);

        const result = results[0]?.result?.value;
        const passes = this._compare(result, operator, value);

        return { result, operator, value, satisfied: passes };
      },
      isSatisfied(result) {
        return result.satisfied;
      },
      _compare(a, op, b) {
        switch (op) {
          case 'gt': return a &gt; b;
          case 'gte': return a &gt;= b;
          case 'lt': return a &lt; b;
          case 'lte': return a &lt;= b;
          case 'eq': return a === b;
          default: return false;
        }
      }
    };
  }

  static pattern(subject, predicate, object) {
    return {
      kind: 'custom:pattern',
      async evaluate(graph, context) {
        const quads = graph.getQuads(subject, predicate, object, null);
        return {
          matches: quads.length,
          satisfied: quads.length &gt; 0
        };
      },
      isSatisfied(result) {
        return result.satisfied;
      }
    };
  }
}

// Use factory
defineHook({
  meta: { name: 'factory-predicate' },
  when: PredicateFactory.threshold('ex:price', 'gt', 100),
  run: async (event) =&gt; {
    // ...
  }
});
</code></pre>
<h2 id="testing-custom-predicates"><a class="header" href="#testing-custom-predicates">Testing Custom Predicates</a></h2>
<pre><code class="language-javascript">import { describe, it, expect } from 'vitest';
import { Store } from 'n3';
import { namedNode, quad, literal } from '@rdfjs/data-model';

describe('Custom Predicate: word-count', () =&gt; {
  it('should detect word count violations', async () =&gt; {
    const predicate = createWordCountPredicate(10, 50);

    const graph = new Store([
      quad(
        namedNode('http://example.org/doc1'),
        namedNode('http://example.org/description'),
        literal('This is a very short text')
      )
    ]);

    const result = await predicate.evaluate(graph, {});

    expect(result.totalWords).toBe(6);
    expect(result.satisfied).toBe(false);
  });

  it('should pass for valid word count', async () =&gt; {
    const predicate = createWordCountPredicate(5, 50);

    const graph = new Store([
      quad(
        namedNode('http://example.org/doc1'),
        namedNode('http://example.org/description'),
        literal('This is a text with exactly twenty words that should pass the validation check successfully')
      )
    ]);

    const result = await predicate.evaluate(graph, {});

    expect(result.satisfied).toBe(true);
  });
});
</code></pre>
<h2 id="best-practices-11"><a class="header" href="#best-practices-11">Best Practices</a></h2>
<h3 id="-dos-5"><a class="header" href="#-dos-5">‚úÖ Do's</a></h3>
<pre><code class="language-javascript">// ‚úÖ Use descriptive kind identifiers
kind: 'custom:word-count'

// ‚úÖ Handle errors gracefully
async evaluate(graph, context) {
  try {
    // Evaluation logic
  } catch (error) {
    return {
      error: error.message,
      satisfied: false
    };
  }
}

// ‚úÖ Provide detailed results
return {
  totalWords: 42,
  minWords: 10,
  maxWords: 50,
  satisfied: true,
  details: { /* additional info */ }
};

// ‚úÖ Document parameters
/**
 * Creates a word count predicate
 * @param {number} minWords - Minimum word count
 * @param {number} maxWords - Maximum word count
 * @returns {Predicate} Custom predicate
 */
function createWordCountPredicate(minWords, maxWords) {
  // ...
}
</code></pre>
<h3 id="-donts-5"><a class="header" href="#-donts-5">‚ùå Don'ts</a></h3>
<pre><code class="language-javascript">// ‚ùå Don't use generic kind names
kind: 'custom'

// ‚ùå Don't swallow errors silently
async evaluate(graph, context) {
  try {
    // ...
  } catch (error) {
    return { satisfied: true }; // Wrong!
  }
}

// ‚ùå Don't return only booleans
return true; // Should return detailed object

// ‚ùå Don't block on expensive operations
async evaluate(graph, context) {
  await slowExternalAPI(); // Consider caching
}
</code></pre>
<h2 id="integration-with-condition-evaluator"><a class="header" href="#integration-with-condition-evaluator">Integration with Condition Evaluator</a></h2>
<p>Custom predicates integrate seamlessly:</p>
<pre><code class="language-javascript">// condition-evaluator.mjs will call your predicate
import { createConditionEvaluator } from 'unrdf';

const evaluator = createConditionEvaluator();

// Register custom predicate type
evaluator.registerPredicateType('custom:word-count', createWordCountPredicate);

// Now hooks can use it
defineHook({
  meta: { name: 'word-count-check' },
  when: createWordCountPredicate(100, 500),
  run: async (event) =&gt; {
    // ...
  }
});
</code></pre>
<h2 id="performance-optimization-6"><a class="header" href="#performance-optimization-6">Performance Optimization</a></h2>
<h3 id="use-incremental-evaluation"><a class="header" href="#use-incremental-evaluation">Use Incremental Evaluation</a></h3>
<pre><code class="language-javascript">function createIncrementalPredicate() {
  let previousResult = null;

  return {
    kind: 'custom:incremental',

    async evaluate(graph, context) {
      // Only re-evaluate changed data
      if (previousResult &amp;&amp; !context.delta) {
        return previousResult;
      }

      const result = await expensiveEvaluation(graph);
      previousResult = result;
      return result;
    },

    isSatisfied(result) {
      return result.satisfied;
    }
  };
}
</code></pre>
<h3 id="parallel-processing"><a class="header" href="#parallel-processing">Parallel Processing</a></h3>
<pre><code class="language-javascript">async evaluate(graph, context) {
  const [result1, result2, result3] = await Promise.all([
    checkConstraint1(graph),
    checkConstraint2(graph),
    checkConstraint3(graph)
  ]);

  return {
    results: [result1, result2, result3],
    satisfied: result1 &amp;&amp; result2 &amp;&amp; result3
  };
}
</code></pre>
<h2 id="next-steps-15"><a class="header" href="#next-steps-15">Next Steps</a></h2>
<ul>
<li><strong><a href="hooks/predicates/../effects.html">Effects</a></strong> - What hooks can do with predicate results</li>
<li><strong><a href="hooks/predicates/../policy-packs.html">Policy Packs</a></strong> - Package custom predicates for reuse</li>
<li><strong><a href="hooks/predicates/../lifecycle.html">Lifecycle</a></strong> - Understand hook execution phases</li>
</ul>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-api-reference"><a class="header" href="#core-api-reference">Core API Reference</a></h1>
<p>This chapter documents UNRDF's core API for store context management and RDF operations.</p>
<h2 id="store-context-api"><a class="header" href="#store-context-api">Store Context API</a></h2>
<h3 id="initstoreinitialquads-options"><a class="header" href="#initstoreinitialquads-options"><code>initStore(initialQuads, options)</code></a></h3>
<p>Initialize the root store context for your application. This must be called at the application root.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>initialQuads</code> (Array<Quad>, optional): Initial RDF quads to populate the store. Default: <code>[]</code></li>
<li><code>options</code> (Object, optional): Store configuration options</li>
</ul>
<p><strong>Returns:</strong> <code>Function</code> - A runner function that accepts your application logic</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

// Initialize store at application root
const runApp = initStore([], { baseIRI: 'http://example.org/' });

runApp(() =&gt; {
  // Your application code here
  const store = useStoreContext();
  // All composables will use the same store
});
</code></pre>
<hr />
<h3 id="usestorecontext-1"><a class="header" href="#usestorecontext-1"><code>useStoreContext()</code></a></h3>
<p>Access the current store context. Must be called within an <code>initStore()</code> runner.</p>
<p><strong>Returns:</strong> <code>StoreContext</code> - The current store context instance</p>
<p><strong>Throws:</strong> <code>Error</code> - If store context is not initialized</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store = useStoreContext();
console.log('Store size:', store.stats().quads);
</code></pre>
<hr />
<h3 id="createstorecontextinitialquads-options"><a class="header" href="#createstorecontextinitialquads-options"><code>createStoreContext(initialQuads, options)</code></a></h3>
<p>Create a store context instance without setting it as the active context. Useful for creating isolated stores.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>initialQuads</code> (Array<Quad>, optional): Initial quads. Default: <code>[]</code></li>
<li><code>options</code> (Object, optional): Store options</li>
</ul>
<p><strong>Returns:</strong> <code>StoreContext</code> - A new store context instance</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If initialQuads is not an array</li>
<li><code>TypeError</code> - If options is not an object</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const isolatedStore = createStoreContext([quad1, quad2], {
  baseIRI: 'http://example.org/'
});
</code></pre>
<hr />
<h2 id="storecontext-operations"><a class="header" href="#storecontext-operations">StoreContext Operations</a></h2>
<h3 id="sender-operations-primary-1"><a class="header" href="#sender-operations-primary-1">Sender Operations (PRIMARY)</a></h3>
<p>These operations modify the store state and are the primary way to interact with UNRDF.</p>
<h4 id="addquads"><a class="header" href="#addquads"><code>add(...quads)</code></a></h4>
<p>Add quads to the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...quads</code> (Quad[]): One or more quads to add</li>
</ul>
<p><strong>Returns:</strong> <code>StoreContext</code> - The context for chaining</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If any quad is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store = useStoreContext();

store.add(
  quad(
    namedNode('http://example.org/alice'),
    namedNode('http://xmlns.com/foaf/0.1/knows'),
    namedNode('http://example.org/bob')
  )
);

// Chaining
store
  .add(quad1)
  .add(quad2)
  .add(quad3);
</code></pre>
<hr />
<h4 id="removequads"><a class="header" href="#removequads"><code>remove(...quads)</code></a></h4>
<p>Remove quads from the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...quads</code> (Quad[]): One or more quads to remove</li>
</ul>
<p><strong>Returns:</strong> <code>StoreContext</code> - The context for chaining</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If any quad is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">store.remove(
  quad(
    namedNode('http://example.org/alice'),
    namedNode('http://xmlns.com/foaf/0.1/knows'),
    namedNode('http://example.org/charlie')
  )
);
</code></pre>
<hr />
<h4 id="clear"><a class="header" href="#clear"><code>clear()</code></a></h4>
<p>Clear all quads from the store.</p>
<p><strong>Returns:</strong> <code>StoreContext</code> - The context for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">store.clear();
console.log('Store cleared, size:', store.stats().quads); // 0
</code></pre>
<hr />
<h3 id="term-creation-1"><a class="header" href="#term-creation-1">Term Creation</a></h3>
<h4 id="namednodevalue"><a class="header" href="#namednodevalue"><code>namedNode(value)</code></a></h4>
<p>Create a named node (IRI).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> (string): The IRI value</li>
</ul>
<p><strong>Returns:</strong> <code>NamedNode</code> - Named node term</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If value is not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const alice = store.namedNode('http://example.org/alice');
const foafKnows = store.namedNode('http://xmlns.com/foaf/0.1/knows');
</code></pre>
<hr />
<h4 id="literalvalue-datatype"><a class="header" href="#literalvalue-datatype"><code>literal(value, datatype)</code></a></h4>
<p>Create a literal value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> (string): The literal value</li>
<li><code>datatype</code> (string, optional): Datatype IRI or language tag</li>
</ul>
<p><strong>Returns:</strong> <code>Literal</code> - Literal term</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If value is not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Plain literal
const name = store.literal('Alice');

// Typed literal
const age = store.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');

// Language-tagged literal
const greeting = store.literal('Hello', 'en');
</code></pre>
<hr />
<h4 id="blanknodevalue"><a class="header" href="#blanknodevalue"><code>blankNode(value)</code></a></h4>
<p>Create a blank node.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> (string, optional): Blank node identifier</li>
</ul>
<p><strong>Returns:</strong> <code>BlankNode</code> - Blank node term</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If value is provided but not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Auto-generated identifier
const person = store.blankNode();

// Specific identifier
const person2 = store.blankNode('person1');
</code></pre>
<hr />
<h4 id="quadsubject-predicate-object-graph"><a class="header" href="#quadsubject-predicate-object-graph"><code>quad(subject, predicate, object, graph)</code></a></h4>
<p>Create a quad.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>subject</code> (Term): Subject term</li>
<li><code>predicate</code> (Term): Predicate term</li>
<li><code>object</code> (Term): Object term</li>
<li><code>graph</code> (Term, optional): Graph term (defaults to default graph)</li>
</ul>
<p><strong>Returns:</strong> <code>Quad</code> - Quad object</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If any required parameter is missing</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const q = store.quad(
  store.namedNode('http://example.org/alice'),
  store.namedNode('http://xmlns.com/foaf/0.1/name'),
  store.literal('Alice'),
  store.namedNode('http://example.org/graph1')
);

store.add(q);
</code></pre>
<hr />
<h3 id="reader-operations-optional-1"><a class="header" href="#reader-operations-optional-1">Reader Operations (OPTIONAL)</a></h3>
<p>These operations read from the store without modifying it. Use sparingly in sender-only mode.</p>
<h4 id="serializeoptions"><a class="header" href="#serializeoptions"><code>serialize(options)</code></a></h4>
<p>Serialize the store to a string format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Serialization options
<ul>
<li><code>format</code> (string): Output format ('Turtle' or 'N-Quads'). Default: 'Turtle'</li>
<li><code>prefixes</code> (Object): Prefix mappings for Turtle format</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;string&gt;</code> - Serialized string</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If options is not an object</li>
<li><code>Error</code> - If format is unsupported</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Serialize to Turtle with prefixes
const turtle = await store.serialize({
  format: 'Turtle',
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  }
});
console.log(turtle);

// Serialize to N-Quads
const nquads = await store.serialize({ format: 'N-Quads' });
</code></pre>
<hr />
<h4 id="stats"><a class="header" href="#stats"><code>stats()</code></a></h4>
<p>Get statistics about the store.</p>
<p><strong>Returns:</strong> <code>Object</code> - Store statistics</p>
<ul>
<li><code>quads</code> (number): Total number of quads</li>
<li><code>subjects</code> (number): Unique subjects count</li>
<li><code>predicates</code> (number): Unique predicates count</li>
<li><code>objects</code> (number): Unique objects count</li>
<li><code>graphs</code> (number): Unique graphs count</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const stats = store.stats();
console.log(`Store contains ${stats.quads} quads`);
console.log(`Unique subjects: ${stats.subjects}`);
console.log(`Unique predicates: ${stats.predicates}`);
</code></pre>
<hr />
<h4 id="querysparql-options"><a class="header" href="#querysparql-options"><code>query(sparql, options)</code></a></h4>
<p>Execute a SPARQL query against the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL query string</li>
<li><code>options</code> (Object, optional): Query options
<ul>
<li><code>limit</code> (number): Result limit</li>
<li><code>signal</code> (AbortSignal): Abort signal</li>
<li><code>deterministic</code> (boolean): Enable deterministic results</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Query result object</p>
<ul>
<li><code>type</code> (string): Query type ('select', 'ask', 'construct', 'describe', 'update')</li>
<li><code>rows</code> (Array, for SELECT): Result bindings</li>
<li><code>boolean</code> (boolean, for ASK): Boolean result</li>
<li><code>store</code> (Store, for CONSTRUCT/DESCRIBE): Result store</li>
</ul>
<p><strong>Throws:</strong> <code>Error</code> - If query is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// SELECT query
const result = await store.query(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  SELECT ?person ?name WHERE {
    ?person foaf:name ?name .
  }
`);
console.log('Results:', result.rows);

// ASK query
const hasAlice = await store.query(`
  ASK { ?s foaf:name "Alice" }
`);
console.log('Has Alice:', hasAlice.boolean);

// UPDATE query
await store.query(`
  PREFIX ex: &lt;http://example.org/&gt;
  INSERT DATA {
    ex:alice ex:age "30" .
  }
`);
</code></pre>
<hr />
<h4 id="canonicalizeoptions"><a class="header" href="#canonicalizeoptions"><code>canonicalize(options)</code></a></h4>
<p>Canonicalize the store using URDNA2015 algorithm.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Canonicalization options
<ul>
<li><code>timeoutMs</code> (number): Timeout in milliseconds. Default: 30000</li>
<li><code>onMetric</code> (Function): Metrics callback</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;string&gt;</code> - Canonicalized N-Quads string</p>
<p><strong>Throws:</strong> <code>Error</code> - If canonicalization fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const canonical = await store.canonicalize({
  timeoutMs: 10000,
  onMetric: (name, data) =&gt; {
    console.log(`Metric ${name}:`, data);
  }
});
</code></pre>
<hr />
<h4 id="isisomorphicstore1-store2-options"><a class="header" href="#isisomorphicstore1-store2-options"><code>isIsomorphic(store1, store2, options)</code></a></h4>
<p>Check if two stores are isomorphic (structurally equivalent).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store1</code> (Store): First store</li>
<li><code>store2</code> (Store): Second store</li>
<li><code>options</code> (Object, optional): Isomorphism options</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;boolean&gt;</code> - True if stores are isomorphic</p>
<p><strong>Throws:</strong> <code>Error</code> - If isomorphism check fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store1 = new Store();
const store2 = new Store();

// Add quads to stores...

const isEqual = await store.isIsomorphic(store1, store2);
console.log('Stores are isomorphic:', isEqual);
</code></pre>
<hr />
<h4 id="hashoptions"><a class="header" href="#hashoptions"><code>hash(options)</code></a></h4>
<p>Generate a canonical hash of the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Hash options
<ul>
<li><code>algorithm</code> (string): Hash algorithm. Default: 'SHA-256'</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;string&gt;</code> - Hexadecimal hash string</p>
<p><strong>Throws:</strong> <code>Error</code> - If hashing fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const storeHash = await store.hash({ algorithm: 'SHA-256' });
console.log('Store hash:', storeHash);

// Compare stores by hash
const hash1 = await store1.hash();
const hash2 = await store2.hash();
console.log('Stores identical:', hash1 === hash2);
</code></pre>
<hr />
<h2 id="best-practices-12"><a class="header" href="#best-practices-12">Best Practices</a></h2>
<h3 id="sender-only-pattern"><a class="header" href="#sender-only-pattern">Sender-Only Pattern</a></h3>
<p>UNRDF enforces a sender-only model for optimal performance:</p>
<pre><code class="language-javascript">// ‚úÖ GOOD: Sender operations
store
  .add(quad1)
  .add(quad2)
  .remove(quad3);

// ‚ö†Ô∏è USE SPARINGLY: Reader operations
const stats = store.stats();
const turtle = await store.serialize();
</code></pre>
<h3 id="chaining-operations"><a class="header" href="#chaining-operations">Chaining Operations</a></h3>
<p>All sender operations return the context for chaining:</p>
<pre><code class="language-javascript">store
  .clear()
  .add(quad(alice, knows, bob))
  .add(quad(bob, knows, charlie))
  .add(quad(charlie, knows, alice));
</code></pre>
<h3 id="error-handling-8"><a class="header" href="#error-handling-8">Error Handling</a></h3>
<p>Always handle errors from async operations:</p>
<pre><code class="language-javascript">try {
  const result = await store.query(sparqlQuery);
  console.log('Query results:', result);
} catch (error) {
  console.error('Query failed:', error.message);
}
</code></pre>
<h3 id="context-isolation-2"><a class="header" href="#context-isolation-2">Context Isolation</a></h3>
<p>Use <code>createStoreContext</code> for isolated stores:</p>
<pre><code class="language-javascript">// Main application store
const runApp = initStore();

runApp(async () =&gt; {
  const mainStore = useStoreContext();

  // Isolated temporary store
  const tempStore = createStoreContext();
  tempStore.add(quad1);

  // Main store is unaffected
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="cli-api-reference"><a class="header" href="#cli-api-reference">CLI API Reference</a></h1>
<p>UNRDF provides a comprehensive command-line interface for RDF graph management, knowledge hooks, policy packs, and SPARQL operations.</p>
<h2 id="installation--setup"><a class="header" href="#installation--setup">Installation &amp; Setup</a></h2>
<pre><code class="language-bash"># Install UNRDF
npm install unrdf

# Verify installation
npx unrdf --version

# Generate shell completion
npx unrdf completion bash &gt; ~/.unrdf-completion.bash
source ~/.unrdf-completion.bash
</code></pre>
<hr />
<h2 id="global-options"><a class="header" href="#global-options">Global Options</a></h2>
<p>All commands support these global options:</p>
<pre><code class="language-bash">--fast           # Fast mode - skip heavy initialization
--help, -h       # Show help
--version, -v    # Show version
</code></pre>
<hr />
<h2 id="graph-commands"><a class="header" href="#graph-commands">Graph Commands</a></h2>
<p>Manage RDF graphs with CRUD operations.</p>
<h3 id="unrdf-graph-update-options"><a class="header" href="#unrdf-graph-update-options"><code>unrdf graph update [OPTIONS]</code></a></h3>
<p>Update a graph with new data.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--graph, -g &lt;uri&gt;</code> - Graph URI (required)</li>
<li><code>--file, -f &lt;path&gt;</code> - Input file path</li>
<li><code>--format &lt;format&gt;</code> - Input format (turtle, nquads, jsonld)</li>
<li><code>--merge</code> - Merge with existing graph (default: replace)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Update graph from Turtle file
unrdf graph update -g http://example.org/graph1 -f data.ttl

# Merge N-Quads data
unrdf graph update -g ex:graph2 -f data.nq --format nquads --merge
</code></pre>
<hr />
<h3 id="unrdf-graph-delete-options"><a class="header" href="#unrdf-graph-delete-options"><code>unrdf graph delete [OPTIONS]</code></a></h3>
<p>Delete a graph or specific triples.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--graph, -g &lt;uri&gt;</code> - Graph URI (required)</li>
<li><code>--pattern &lt;pattern&gt;</code> - Triple pattern to delete (optional)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Delete entire graph
unrdf graph delete -g http://example.org/graph1

# Delete triples matching pattern
unrdf graph delete -g ex:graph1 --pattern "?s foaf:knows ?o"
</code></pre>
<hr />
<h3 id="unrdf-graph-describe-options"><a class="header" href="#unrdf-graph-describe-options"><code>unrdf graph describe [OPTIONS]</code></a></h3>
<p>Describe a graph or resource.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--graph, -g &lt;uri&gt;</code> - Graph URI</li>
<li><code>--resource, -r &lt;uri&gt;</code> - Resource URI to describe</li>
<li><code>--format &lt;format&gt;</code> - Output format (turtle, nquads, json)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Describe a graph
unrdf graph describe -g http://example.org/graph1

# Describe a specific resource
unrdf graph describe -r http://example.org/alice --format turtle
</code></pre>
<hr />
<h2 id="hook-commands"><a class="header" href="#hook-commands">Hook Commands</a></h2>
<p>Manage knowledge hooks for graph governance.</p>
<h3 id="unrdf-hook-list-options"><a class="header" href="#unrdf-hook-list-options"><code>unrdf hook list [OPTIONS]</code></a></h3>
<p>List all registered knowledge hooks.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--format &lt;format&gt;</code> - Output format (table, json, yaml)</li>
<li><code>--filter &lt;pattern&gt;</code> - Filter by hook name pattern</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># List all hooks
unrdf hook list

# List hooks as JSON
unrdf hook list --format json

# Filter hooks
unrdf hook list --filter "validate-*"
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üìã Knowledge Hooks
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Name                   ‚îÇ Version ‚îÇ Status       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ validate-schema        ‚îÇ 1.0.0   ‚îÇ ‚úÖ Active    ‚îÇ
‚îÇ check-permissions      ‚îÇ 1.2.0   ‚îÇ ‚úÖ Active    ‚îÇ
‚îÇ audit-changes          ‚îÇ 2.0.0   ‚îÇ ‚è∏ Disabled  ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h3 id="unrdf-hook-get-name"><a class="header" href="#unrdf-hook-get-name"><code>unrdf hook get &lt;NAME&gt;</code></a></h3>
<p>Get details about a specific hook.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Hook name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--format &lt;format&gt;</code> - Output format (yaml, json)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Get hook details
unrdf hook get validate-schema

# Get hook as JSON
unrdf hook get validate-schema --format json
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-yaml">name: validate-schema
version: 1.0.0
description: Validate RDF data against SHACL shapes
status: active
when:
  sparql-ask: |
    ASK { ?s ?p ?o }
priority: 80
last_executed: 2024-01-15T10:30:00Z
execution_count: 142
</code></pre>
<hr />
<h3 id="unrdf-hook-create-options"><a class="header" href="#unrdf-hook-create-options"><code>unrdf hook create [OPTIONS]</code></a></h3>
<p>Create a new knowledge hook.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--name, -n &lt;name&gt;</code> - Hook name (required)</li>
<li><code>--file, -f &lt;path&gt;</code> - Hook implementation file</li>
<li><code>--template &lt;template&gt;</code> - Use template (validation, audit, transform)</li>
<li><code>--interactive, -i</code> - Interactive mode</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Create hook from file
unrdf hook create -n my-validator -f validator.mjs

# Create from template
unrdf hook create -n schema-check --template validation

# Interactive mode
unrdf hook create --interactive
</code></pre>
<hr />
<h3 id="unrdf-hook-update-name-options"><a class="header" href="#unrdf-hook-update-name-options"><code>unrdf hook update &lt;NAME&gt; [OPTIONS]</code></a></h3>
<p>Update an existing hook.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Hook name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--file, -f &lt;path&gt;</code> - New implementation file</li>
<li><code>--enable</code> - Enable hook</li>
<li><code>--disable</code> - Disable hook</li>
<li><code>--priority &lt;n&gt;</code> - Set priority (0-100)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Update hook implementation
unrdf hook update validate-schema -f new-validator.mjs

# Change priority
unrdf hook update validate-schema --priority 90

# Disable hook
unrdf hook update validate-schema --disable
</code></pre>
<hr />
<h3 id="unrdf-hook-delete-name"><a class="header" href="#unrdf-hook-delete-name"><code>unrdf hook delete &lt;NAME&gt;</code></a></h3>
<p>Delete a knowledge hook.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Hook name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--force, -f</code> - Skip confirmation</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Delete hook (with confirmation)
unrdf hook delete old-validator

# Force delete
unrdf hook delete old-validator --force
</code></pre>
<hr />
<h3 id="unrdf-hook-history-name-options"><a class="header" href="#unrdf-hook-history-name-options"><code>unrdf hook history &lt;NAME&gt; [OPTIONS]</code></a></h3>
<p>Show hook execution history.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Hook name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--limit &lt;n&gt;</code> - Limit results (default: 50)</li>
<li><code>--format &lt;format&gt;</code> - Output format (table, json)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Show recent executions
unrdf hook history validate-schema

# Show last 10 executions as JSON
unrdf hook history validate-schema --limit 10 --format json
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üìä Execution History: validate-schema
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Timestamp           ‚îÇ Result  ‚îÇ Duration ‚îÇ Actor    ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ 2024-01-15 10:30:00 ‚îÇ ‚úÖ Pass ‚îÇ 42ms     ‚îÇ system   ‚îÇ
‚îÇ 2024-01-15 10:25:00 ‚îÇ ‚úÖ Pass ‚îÇ 38ms     ‚îÇ user:123 ‚îÇ
‚îÇ 2024-01-15 10:20:00 ‚îÇ ‚ùå Fail ‚îÇ 15ms     ‚îÇ system   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h3 id="unrdf-hook-describe-name"><a class="header" href="#unrdf-hook-describe-name"><code>unrdf hook describe &lt;NAME&gt;</code></a></h3>
<p>Show detailed hook information.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Hook name (required)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf hook describe validate-schema
</code></pre>
<hr />
<h2 id="policy-commands"><a class="header" href="#policy-commands">Policy Commands</a></h2>
<p>Manage policy packs for versioned governance.</p>
<h3 id="unrdf-policy-list-options"><a class="header" href="#unrdf-policy-list-options"><code>unrdf policy list [OPTIONS]</code></a></h3>
<p>List all policy packs.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--active</code> - Show only active packs</li>
<li><code>--format &lt;format&gt;</code> - Output format (table, json)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># List all policy packs
unrdf policy list

# List active packs only
unrdf policy list --active
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üì¶ Policy Packs
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Name             ‚îÇ Version ‚îÇ Status  ‚îÇ Hooks  ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ governance:core  ‚îÇ 1.0.0   ‚îÇ ‚úÖ Active ‚îÇ 5      ‚îÇ
‚îÇ security:basic   ‚îÇ 2.1.0   ‚îÇ ‚úÖ Active ‚îÇ 3      ‚îÇ
‚îÇ compliance:gdpr  ‚îÇ 1.5.0   ‚îÇ ‚è∏ Inactive ‚îÇ 8      ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h3 id="unrdf-policy-get-name"><a class="header" href="#unrdf-policy-get-name"><code>unrdf policy get &lt;NAME&gt;</code></a></h3>
<p>Get policy pack details.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Policy pack name (required)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf policy get governance:core
</code></pre>
<hr />
<h3 id="unrdf-policy-apply-name"><a class="header" href="#unrdf-policy-apply-name"><code>unrdf policy apply &lt;NAME&gt;</code></a></h3>
<p>Activate a policy pack.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Policy pack name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--force, -f</code> - Force activation even if incompatible</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Activate policy pack
unrdf policy apply governance:core

# Force activation
unrdf policy apply governance:core --force
</code></pre>
<hr />
<h3 id="unrdf-policy-test-name-options"><a class="header" href="#unrdf-policy-test-name-options"><code>unrdf policy test &lt;NAME&gt; [OPTIONS]</code></a></h3>
<p>Test a policy pack against sample data.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Policy pack name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--data, -d &lt;path&gt;</code> - Test data file</li>
<li><code>--verbose, -v</code> - Verbose output</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Test policy pack
unrdf policy test governance:core -d test-data.ttl

# Verbose testing
unrdf policy test governance:core -d test-data.ttl --verbose
</code></pre>
<hr />
<h3 id="unrdf-policy-validate-name"><a class="header" href="#unrdf-policy-validate-name"><code>unrdf policy validate &lt;NAME&gt;</code></a></h3>
<p>Validate a policy pack manifest and hooks.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Policy pack name or path to manifest (required)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Validate installed pack
unrdf policy validate governance:core

# Validate manifest file
unrdf policy validate ./policy-packs/my-pack/manifest.json
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>‚úÖ Policy Pack Validation: governance:core

Manifest:
  ‚úÖ Valid JSON structure
  ‚úÖ All required fields present
  ‚úÖ Version format valid (1.0.0)

Hooks:
  ‚úÖ validate-schema.mjs - valid
  ‚úÖ check-permissions.mjs - valid
  ‚ö†Ô∏è  audit-changes.mjs - missing dependency

Resources:
  ‚úÖ All referenced files exist

Overall: ‚ö†Ô∏è Valid with warnings
</code></pre>
<hr />
<h3 id="unrdf-policy-describe-name"><a class="header" href="#unrdf-policy-describe-name"><code>unrdf policy describe &lt;NAME&gt;</code></a></h3>
<p>Show detailed policy pack information.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Policy pack name (required)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf policy describe governance:core
</code></pre>
<hr />
<h2 id="store-commands"><a class="header" href="#store-commands">Store Commands</a></h2>
<p>Manage the RDF store directly.</p>
<h3 id="unrdf-store-import-file-options"><a class="header" href="#unrdf-store-import-file-options"><code>unrdf store import &lt;FILE&gt; [OPTIONS]</code></a></h3>
<p>Import data into the store.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;FILE&gt;</code> - Input file path (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--format &lt;format&gt;</code> - Input format (turtle, nquads, jsonld)</li>
<li><code>--graph &lt;uri&gt;</code> - Target graph URI</li>
<li><code>--clear</code> - Clear existing data first</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Import Turtle data
unrdf store import data.ttl

# Import into specific graph
unrdf store import data.nq --format nquads --graph ex:graph1

# Clear and import
unrdf store import data.ttl --clear
</code></pre>
<hr />
<h3 id="unrdf-store-export-options"><a class="header" href="#unrdf-store-export-options"><code>unrdf store export [OPTIONS]</code></a></h3>
<p>Export data from the store.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--output, -o &lt;file&gt;</code> - Output file path (default: stdout)</li>
<li><code>--format &lt;format&gt;</code> - Output format (turtle, nquads, jsonld)</li>
<li><code>--graph &lt;uri&gt;</code> - Source graph URI</li>
<li><code>--pretty</code> - Pretty-print output</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Export to stdout
unrdf store export --format turtle

# Export to file
unrdf store export -o export.ttl --format turtle --pretty

# Export specific graph
unrdf store export -o graph1.nq --graph ex:graph1 --format nquads
</code></pre>
<hr />
<h3 id="unrdf-store-query-sparql-options"><a class="header" href="#unrdf-store-query-sparql-options"><code>unrdf store query &lt;SPARQL&gt; [OPTIONS]</code></a></h3>
<p>Execute a SPARQL query against the store.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;SPARQL&gt;</code> - SPARQL query string or file path (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--file, -f</code> - Treat argument as file path</li>
<li><code>--format &lt;format&gt;</code> - Output format (table, json, csv, xml)</li>
<li><code>--limit &lt;n&gt;</code> - Result limit</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Query from command line
unrdf store query "SELECT ?s ?p ?o WHERE { ?s ?p ?o } LIMIT 10"

# Query from file
unrdf store query query.sparql --file

# JSON output
unrdf store query query.sparql -f --format json

# CSV output with limit
unrdf store query "SELECT * WHERE { ?s ?p ?o }" --format csv --limit 100
</code></pre>
<p><strong>Output (table format):</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ s                           ‚îÇ p                    ‚îÇ o       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ http://example.org/alice    ‚îÇ foaf:name            ‚îÇ "Alice" ‚îÇ
‚îÇ http://example.org/alice    ‚îÇ foaf:knows           ‚îÇ ex:bob  ‚îÇ
‚îÇ http://example.org/bob      ‚îÇ foaf:name            ‚îÇ "Bob"   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h3 id="unrdf-store-stats-options"><a class="header" href="#unrdf-store-stats-options"><code>unrdf store stats [OPTIONS]</code></a></h3>
<p>Show store statistics.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--format &lt;format&gt;</code> - Output format (table, json)</li>
<li><code>--verbose, -v</code> - Include detailed statistics</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Basic stats
unrdf store stats

# Detailed stats
unrdf store stats --verbose

# JSON output
unrdf store stats --format json
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üìä Store Statistics

Overview:
  Total Quads:      12,345
  Unique Subjects:  1,234
  Unique Predicates: 45
  Unique Objects:   3,456
  Named Graphs:     8

Performance:
  Last Query:       42ms
  Avg Query Time:   35ms
  Cache Hit Rate:   85%

Disk Usage:
  Store Size:       2.4 MB
  Index Size:       0.8 MB
  Total:            3.2 MB
</code></pre>
<hr />
<h2 id="context-commands"><a class="header" href="#context-commands">Context Commands</a></h2>
<p>Manage CLI contexts for different environments.</p>
<h3 id="unrdf-context-list"><a class="header" href="#unrdf-context-list"><code>unrdf context list</code></a></h3>
<p>List all contexts.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf context list
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üìã CLI Contexts
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Name        ‚îÇ Endpoint               ‚îÇ Active ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ development ‚îÇ http://localhost:3030  ‚îÇ ‚úÖ     ‚îÇ
‚îÇ staging     ‚îÇ https://stage.api.com  ‚îÇ        ‚îÇ
‚îÇ production  ‚îÇ https://prod.api.com   ‚îÇ        ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h3 id="unrdf-context-create-name-options"><a class="header" href="#unrdf-context-create-name-options"><code>unrdf context create &lt;NAME&gt; [OPTIONS]</code></a></h3>
<p>Create a new context.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Context name (required)</li>
</ul>
<p><strong>Options:</strong></p>
<ul>
<li><code>--endpoint, -e &lt;url&gt;</code> - SPARQL endpoint URL</li>
<li><code>--auth &lt;token&gt;</code> - Authentication token</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf context create staging --endpoint https://stage.api.com
</code></pre>
<hr />
<h3 id="unrdf-context-use-name"><a class="header" href="#unrdf-context-use-name"><code>unrdf context use &lt;NAME&gt;</code></a></h3>
<p>Switch to a different context.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Context name (required)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf context use production
</code></pre>
<hr />
<h3 id="unrdf-context-current"><a class="header" href="#unrdf-context-current"><code>unrdf context current</code></a></h3>
<p>Show current context.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf context current
</code></pre>
<hr />
<h2 id="sidecar-commands"><a class="header" href="#sidecar-commands">Sidecar Commands</a></h2>
<p>Manage the Knowledge Graph Coordinator (KGC) sidecar.</p>
<h3 id="unrdf-sidecar-status"><a class="header" href="#unrdf-sidecar-status"><code>unrdf sidecar status</code></a></h3>
<p>Get sidecar status.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf sidecar status
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üîß KGC Sidecar Status

Status:        ‚úÖ Running
Uptime:        2 days, 14 hours
Version:       2.0.0
PID:           12345

Connections:
  Active:      5
  Total:       128

Memory:
  Used:        245 MB
  Available:   512 MB
</code></pre>
<hr />
<h3 id="unrdf-sidecar-health"><a class="header" href="#unrdf-sidecar-health"><code>unrdf sidecar health</code></a></h3>
<p>Check sidecar health.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf sidecar health
</code></pre>
<hr />
<h3 id="unrdf-sidecar-restart"><a class="header" href="#unrdf-sidecar-restart"><code>unrdf sidecar restart</code></a></h3>
<p>Restart the sidecar.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf sidecar restart
</code></pre>
<hr />
<h2 id="plugin-commands"><a class="header" href="#plugin-commands">Plugin Commands</a></h2>
<p>Manage CLI plugins.</p>
<h3 id="unrdf-plugin-list"><a class="header" href="#unrdf-plugin-list"><code>unrdf plugin list</code></a></h3>
<p>List installed plugins.</p>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf plugin list
</code></pre>
<hr />
<h3 id="unrdf-plugin-install-name"><a class="header" href="#unrdf-plugin-install-name"><code>unrdf plugin install &lt;NAME&gt;</code></a></h3>
<p>Install a plugin.</p>
<p><strong>Arguments:</strong></p>
<ul>
<li><code>&lt;NAME&gt;</code> - Plugin name (required)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash">unrdf plugin install unrdf-plugin-visualizer
</code></pre>
<hr />
<h2 id="repl"><a class="header" href="#repl">REPL</a></h2>
<h3 id="unrdf-repl-options"><a class="header" href="#unrdf-repl-options"><code>unrdf repl [OPTIONS]</code></a></h3>
<p>Start interactive SPARQL REPL.</p>
<p><strong>Options:</strong></p>
<ul>
<li><code>--endpoint, -e &lt;url&gt;</code> - SPARQL endpoint</li>
<li><code>--timeout &lt;ms&gt;</code> - Query timeout (default: 30000)</li>
</ul>
<p><strong>Examples:</strong></p>
<pre><code class="language-bash"># Start REPL
unrdf repl

# Connect to endpoint
unrdf repl -e http://localhost:3030/dataset
</code></pre>
<p><strong>REPL Commands:</strong></p>
<pre><code>unrdf&gt; SELECT * WHERE { ?s ?p ?o } LIMIT 5
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ s                           ‚îÇ p            ‚îÇ o       ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ http://example.org/alice    ‚îÇ foaf:name    ‚îÇ "Alice" ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò

unrdf&gt; .help
Available commands:
  .help          Show this help
  .quit          Exit REPL
  .clear         Clear screen
  .prefixes      Show loaded prefixes
  .load &lt;file&gt;   Load and execute SPARQL file
  .export &lt;file&gt; Export last results

unrdf&gt; .quit
Goodbye!
</code></pre>
<hr />
<h2 id="shell-completion"><a class="header" href="#shell-completion">Shell Completion</a></h2>
<p>Generate shell completion scripts:</p>
<pre><code class="language-bash"># Bash
unrdf completion bash &gt; ~/.unrdf-completion.bash
echo "source ~/.unrdf-completion.bash" &gt;&gt; ~/.bashrc

# Zsh
unrdf completion zsh &gt; ~/.unrdf-completion.zsh
echo "source ~/.unrdf-completion.zsh" &gt;&gt; ~/.zshrc

# Fish
unrdf completion fish &gt; ~/.config/fish/completions/unrdf.fish
</code></pre>
<hr />
<h2 id="configuration-file"><a class="header" href="#configuration-file">Configuration File</a></h2>
<p>UNRDF reads configuration from <code>.unrdfrc.json</code>:</p>
<pre><code class="language-json">{
  "defaultContext": "development",
  "contexts": {
    "development": {
      "endpoint": "http://localhost:3030",
      "timeout": 30000
    },
    "production": {
      "endpoint": "https://api.example.com",
      "auth": "${UNRDF_AUTH_TOKEN}"
    }
  },
  "plugins": [
    "unrdf-plugin-visualizer"
  ],
  "hooks": {
    "basePath": "./hooks",
    "autoLoad": true
  }
}
</code></pre>
<hr />
<h2 id="environment-variables"><a class="header" href="#environment-variables">Environment Variables</a></h2>
<pre><code class="language-bash">UNRDF_ENDPOINT       # Default SPARQL endpoint
UNRDF_AUTH_TOKEN     # Authentication token
UNRDF_CONFIG         # Config file path
UNRDF_LOG_LEVEL      # Log level (debug, info, warn, error)
UNRDF_TIMEOUT        # Default timeout (ms)
</code></pre>
<hr />
<h2 id="best-practices-13"><a class="header" href="#best-practices-13">Best Practices</a></h2>
<h3 id="scripting"><a class="header" href="#scripting">Scripting</a></h3>
<p>Use JSON output for scripting:</p>
<pre><code class="language-bash">#!/bin/bash

# Get hook status
status=$(unrdf hook get validate-schema --format json | jq -r '.status')

if [ "$status" = "active" ]; then
  echo "Hook is active"
fi
</code></pre>
<h3 id="batch-operations"><a class="header" href="#batch-operations">Batch Operations</a></h3>
<p>Use batch mode for multiple operations:</p>
<pre><code class="language-bash"># Import multiple files
for file in *.ttl; do
  unrdf store import "$file" --graph "ex:${file%.ttl}"
done
</code></pre>
<h3 id="performance"><a class="header" href="#performance">Performance</a></h3>
<p>Use <code>--fast</code> mode for quick operations:</p>
<pre><code class="language-bash"># Fast mode skips heavy initialization
unrdf --fast store stats
unrdf --fast hook list
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="core-api-reference-1"><a class="header" href="#core-api-reference-1">Core API Reference</a></h1>
<p>This chapter documents UNRDF's core API for store context management and RDF operations.</p>
<h2 id="store-context-api-1"><a class="header" href="#store-context-api-1">Store Context API</a></h2>
<h3 id="initstoreinitialquads-options-1"><a class="header" href="#initstoreinitialquads-options-1"><code>initStore(initialQuads, options)</code></a></h3>
<p>Initialize the root store context for your application. This must be called at the application root.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>initialQuads</code> (Array<Quad>, optional): Initial RDF quads to populate the store. Default: <code>[]</code></li>
<li><code>options</code> (Object, optional): Store configuration options</li>
</ul>
<p><strong>Returns:</strong> <code>Function</code> - A runner function that accepts your application logic</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useStoreContext } from 'unrdf';

// Initialize store at application root
const runApp = initStore([], { baseIRI: 'http://example.org/' });

runApp(() =&gt; {
  // Your application code here
  const store = useStoreContext();
  // All composables will use the same store
});
</code></pre>
<hr />
<h3 id="usestorecontext-2"><a class="header" href="#usestorecontext-2"><code>useStoreContext()</code></a></h3>
<p>Access the current store context. Must be called within an <code>initStore()</code> runner.</p>
<p><strong>Returns:</strong> <code>StoreContext</code> - The current store context instance</p>
<p><strong>Throws:</strong> <code>Error</code> - If store context is not initialized</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store = useStoreContext();
console.log('Store size:', store.stats().quads);
</code></pre>
<hr />
<h3 id="createstorecontextinitialquads-options-1"><a class="header" href="#createstorecontextinitialquads-options-1"><code>createStoreContext(initialQuads, options)</code></a></h3>
<p>Create a store context instance without setting it as the active context. Useful for creating isolated stores.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>initialQuads</code> (Array<Quad>, optional): Initial quads. Default: <code>[]</code></li>
<li><code>options</code> (Object, optional): Store options</li>
</ul>
<p><strong>Returns:</strong> <code>StoreContext</code> - A new store context instance</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If initialQuads is not an array</li>
<li><code>TypeError</code> - If options is not an object</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const isolatedStore = createStoreContext([quad1, quad2], {
  baseIRI: 'http://example.org/'
});
</code></pre>
<hr />
<h2 id="storecontext-operations-1"><a class="header" href="#storecontext-operations-1">StoreContext Operations</a></h2>
<h3 id="sender-operations-primary-2"><a class="header" href="#sender-operations-primary-2">Sender Operations (PRIMARY)</a></h3>
<p>These operations modify the store state and are the primary way to interact with UNRDF.</p>
<h4 id="addquads-1"><a class="header" href="#addquads-1"><code>add(...quads)</code></a></h4>
<p>Add quads to the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...quads</code> (Quad[]): One or more quads to add</li>
</ul>
<p><strong>Returns:</strong> <code>StoreContext</code> - The context for chaining</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If any quad is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store = useStoreContext();

store.add(
  quad(
    namedNode('http://example.org/alice'),
    namedNode('http://xmlns.com/foaf/0.1/knows'),
    namedNode('http://example.org/bob')
  )
);

// Chaining
store
  .add(quad1)
  .add(quad2)
  .add(quad3);
</code></pre>
<hr />
<h4 id="removequads-1"><a class="header" href="#removequads-1"><code>remove(...quads)</code></a></h4>
<p>Remove quads from the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...quads</code> (Quad[]): One or more quads to remove</li>
</ul>
<p><strong>Returns:</strong> <code>StoreContext</code> - The context for chaining</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If any quad is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">store.remove(
  quad(
    namedNode('http://example.org/alice'),
    namedNode('http://xmlns.com/foaf/0.1/knows'),
    namedNode('http://example.org/charlie')
  )
);
</code></pre>
<hr />
<h4 id="clear-1"><a class="header" href="#clear-1"><code>clear()</code></a></h4>
<p>Clear all quads from the store.</p>
<p><strong>Returns:</strong> <code>StoreContext</code> - The context for chaining</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">store.clear();
console.log('Store cleared, size:', store.stats().quads); // 0
</code></pre>
<hr />
<h3 id="term-creation-2"><a class="header" href="#term-creation-2">Term Creation</a></h3>
<h4 id="namednodevalue-1"><a class="header" href="#namednodevalue-1"><code>namedNode(value)</code></a></h4>
<p>Create a named node (IRI).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> (string): The IRI value</li>
</ul>
<p><strong>Returns:</strong> <code>NamedNode</code> - Named node term</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If value is not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const alice = store.namedNode('http://example.org/alice');
const foafKnows = store.namedNode('http://xmlns.com/foaf/0.1/knows');
</code></pre>
<hr />
<h4 id="literalvalue-datatype-1"><a class="header" href="#literalvalue-datatype-1"><code>literal(value, datatype)</code></a></h4>
<p>Create a literal value.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> (string): The literal value</li>
<li><code>datatype</code> (string, optional): Datatype IRI or language tag</li>
</ul>
<p><strong>Returns:</strong> <code>Literal</code> - Literal term</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If value is not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Plain literal
const name = store.literal('Alice');

// Typed literal
const age = store.literal('30', 'http://www.w3.org/2001/XMLSchema#integer');

// Language-tagged literal
const greeting = store.literal('Hello', 'en');
</code></pre>
<hr />
<h4 id="blanknodevalue-1"><a class="header" href="#blanknodevalue-1"><code>blankNode(value)</code></a></h4>
<p>Create a blank node.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>value</code> (string, optional): Blank node identifier</li>
</ul>
<p><strong>Returns:</strong> <code>BlankNode</code> - Blank node term</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If value is provided but not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Auto-generated identifier
const person = store.blankNode();

// Specific identifier
const person2 = store.blankNode('person1');
</code></pre>
<hr />
<h4 id="quadsubject-predicate-object-graph-1"><a class="header" href="#quadsubject-predicate-object-graph-1"><code>quad(subject, predicate, object, graph)</code></a></h4>
<p>Create a quad.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>subject</code> (Term): Subject term</li>
<li><code>predicate</code> (Term): Predicate term</li>
<li><code>object</code> (Term): Object term</li>
<li><code>graph</code> (Term, optional): Graph term (defaults to default graph)</li>
</ul>
<p><strong>Returns:</strong> <code>Quad</code> - Quad object</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If any required parameter is missing</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const q = store.quad(
  store.namedNode('http://example.org/alice'),
  store.namedNode('http://xmlns.com/foaf/0.1/name'),
  store.literal('Alice'),
  store.namedNode('http://example.org/graph1')
);

store.add(q);
</code></pre>
<hr />
<h3 id="reader-operations-optional-2"><a class="header" href="#reader-operations-optional-2">Reader Operations (OPTIONAL)</a></h3>
<p>These operations read from the store without modifying it. Use sparingly in sender-only mode.</p>
<h4 id="serializeoptions-1"><a class="header" href="#serializeoptions-1"><code>serialize(options)</code></a></h4>
<p>Serialize the store to a string format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Serialization options
<ul>
<li><code>format</code> (string): Output format ('Turtle' or 'N-Quads'). Default: 'Turtle'</li>
<li><code>prefixes</code> (Object): Prefix mappings for Turtle format</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;string&gt;</code> - Serialized string</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If options is not an object</li>
<li><code>Error</code> - If format is unsupported</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// Serialize to Turtle with prefixes
const turtle = await store.serialize({
  format: 'Turtle',
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  }
});
console.log(turtle);

// Serialize to N-Quads
const nquads = await store.serialize({ format: 'N-Quads' });
</code></pre>
<hr />
<h4 id="stats-1"><a class="header" href="#stats-1"><code>stats()</code></a></h4>
<p>Get statistics about the store.</p>
<p><strong>Returns:</strong> <code>Object</code> - Store statistics</p>
<ul>
<li><code>quads</code> (number): Total number of quads</li>
<li><code>subjects</code> (number): Unique subjects count</li>
<li><code>predicates</code> (number): Unique predicates count</li>
<li><code>objects</code> (number): Unique objects count</li>
<li><code>graphs</code> (number): Unique graphs count</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const stats = store.stats();
console.log(`Store contains ${stats.quads} quads`);
console.log(`Unique subjects: ${stats.subjects}`);
console.log(`Unique predicates: ${stats.predicates}`);
</code></pre>
<hr />
<h4 id="querysparql-options-1"><a class="header" href="#querysparql-options-1"><code>query(sparql, options)</code></a></h4>
<p>Execute a SPARQL query against the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL query string</li>
<li><code>options</code> (Object, optional): Query options
<ul>
<li><code>limit</code> (number): Result limit</li>
<li><code>signal</code> (AbortSignal): Abort signal</li>
<li><code>deterministic</code> (boolean): Enable deterministic results</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Query result object</p>
<ul>
<li><code>type</code> (string): Query type ('select', 'ask', 'construct', 'describe', 'update')</li>
<li><code>rows</code> (Array, for SELECT): Result bindings</li>
<li><code>boolean</code> (boolean, for ASK): Boolean result</li>
<li><code>store</code> (Store, for CONSTRUCT/DESCRIBE): Result store</li>
</ul>
<p><strong>Throws:</strong> <code>Error</code> - If query is invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">// SELECT query
const result = await store.query(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  SELECT ?person ?name WHERE {
    ?person foaf:name ?name .
  }
`);
console.log('Results:', result.rows);

// ASK query
const hasAlice = await store.query(`
  ASK { ?s foaf:name "Alice" }
`);
console.log('Has Alice:', hasAlice.boolean);

// UPDATE query
await store.query(`
  PREFIX ex: &lt;http://example.org/&gt;
  INSERT DATA {
    ex:alice ex:age "30" .
  }
`);
</code></pre>
<hr />
<h4 id="canonicalizeoptions-1"><a class="header" href="#canonicalizeoptions-1"><code>canonicalize(options)</code></a></h4>
<p>Canonicalize the store using URDNA2015 algorithm.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Canonicalization options
<ul>
<li><code>timeoutMs</code> (number): Timeout in milliseconds. Default: 30000</li>
<li><code>onMetric</code> (Function): Metrics callback</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;string&gt;</code> - Canonicalized N-Quads string</p>
<p><strong>Throws:</strong> <code>Error</code> - If canonicalization fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const canonical = await store.canonicalize({
  timeoutMs: 10000,
  onMetric: (name, data) =&gt; {
    console.log(`Metric ${name}:`, data);
  }
});
</code></pre>
<hr />
<h4 id="isisomorphicstore1-store2-options-1"><a class="header" href="#isisomorphicstore1-store2-options-1"><code>isIsomorphic(store1, store2, options)</code></a></h4>
<p>Check if two stores are isomorphic (structurally equivalent).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store1</code> (Store): First store</li>
<li><code>store2</code> (Store): Second store</li>
<li><code>options</code> (Object, optional): Isomorphism options</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;boolean&gt;</code> - True if stores are isomorphic</p>
<p><strong>Throws:</strong> <code>Error</code> - If isomorphism check fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store1 = new Store();
const store2 = new Store();

// Add quads to stores...

const isEqual = await store.isIsomorphic(store1, store2);
console.log('Stores are isomorphic:', isEqual);
</code></pre>
<hr />
<h4 id="hashoptions-1"><a class="header" href="#hashoptions-1"><code>hash(options)</code></a></h4>
<p>Generate a canonical hash of the store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Hash options
<ul>
<li><code>algorithm</code> (string): Hash algorithm. Default: 'SHA-256'</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;string&gt;</code> - Hexadecimal hash string</p>
<p><strong>Throws:</strong> <code>Error</code> - If hashing fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const storeHash = await store.hash({ algorithm: 'SHA-256' });
console.log('Store hash:', storeHash);

// Compare stores by hash
const hash1 = await store1.hash();
const hash2 = await store2.hash();
console.log('Stores identical:', hash1 === hash2);
</code></pre>
<hr />
<h2 id="best-practices-14"><a class="header" href="#best-practices-14">Best Practices</a></h2>
<h3 id="sender-only-pattern-1"><a class="header" href="#sender-only-pattern-1">Sender-Only Pattern</a></h3>
<p>UNRDF enforces a sender-only model for optimal performance:</p>
<pre><code class="language-javascript">// ‚úÖ GOOD: Sender operations
store
  .add(quad1)
  .add(quad2)
  .remove(quad3);

// ‚ö†Ô∏è USE SPARINGLY: Reader operations
const stats = store.stats();
const turtle = await store.serialize();
</code></pre>
<h3 id="chaining-operations-1"><a class="header" href="#chaining-operations-1">Chaining Operations</a></h3>
<p>All sender operations return the context for chaining:</p>
<pre><code class="language-javascript">store
  .clear()
  .add(quad(alice, knows, bob))
  .add(quad(bob, knows, charlie))
  .add(quad(charlie, knows, alice));
</code></pre>
<h3 id="error-handling-9"><a class="header" href="#error-handling-9">Error Handling</a></h3>
<p>Always handle errors from async operations:</p>
<pre><code class="language-javascript">try {
  const result = await store.query(sparqlQuery);
  console.log('Query results:', result);
} catch (error) {
  console.error('Query failed:', error.message);
}
</code></pre>
<h3 id="context-isolation-3"><a class="header" href="#context-isolation-3">Context Isolation</a></h3>
<p>Use <code>createStoreContext</code> for isolated stores:</p>
<pre><code class="language-javascript">// Main application store
const runApp = initStore();

runApp(async () =&gt; {
  const mainStore = useStoreContext();

  // Isolated temporary store
  const tempStore = createStoreContext();
  tempStore.add(quad1);

  // Main store is unaffected
});
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="knowledge-engine-api-reference"><a class="header" href="#knowledge-engine-api-reference">Knowledge Engine API Reference</a></h1>
<p>The Knowledge Engine provides transaction management, knowledge hooks, policy packs, and cryptographic provenance for RDF graphs.</p>
<h2 id="transaction-manager"><a class="header" href="#transaction-manager">Transaction Manager</a></h2>
<h3 id="transactionmanageroptions"><a class="header" href="#transactionmanageroptions"><code>TransactionManager(options)</code></a></h3>
<p>Create a transaction manager for atomic RDF graph operations with hooks and receipts.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Manager options
<ul>
<li><code>maxHooks</code> (number): Maximum hooks allowed. Default: 100</li>
<li><code>strictMode</code> (boolean): Enable strict error handling. Default: false</li>
<li><code>afterHashOnly</code> (boolean): Skip canonicalization for performance. Default: false</li>
<li><code>enableLockchain</code> (boolean): Enable lockchain writer. Default: false</li>
<li><code>enableResolution</code> (boolean): Enable resolution layer. Default: false</li>
<li><code>observability</code> (Object): Observability configuration</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>TransactionManager</code> - New transaction manager instance</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { TransactionManager } from 'unrdf/knowledge-engine';

const tx = new TransactionManager({
  maxHooks: 50,
  strictMode: true,
  enableLockchain: true
});
</code></pre>
<hr />
<h3 id="transaction-manager-methods"><a class="header" href="#transaction-manager-methods">Transaction Manager Methods</a></h3>
<h4 id="addhookhook"><a class="header" href="#addhookhook"><code>addHook(hook)</code></a></h4>
<p>Register a transaction hook.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>hook</code> (Object): Hook definition
<ul>
<li><code>id</code> (string): Unique hook identifier</li>
<li><code>mode</code> (string): Hook mode ('pre' or 'post')</li>
<li><code>condition</code> (Function): Async condition function <code>(store, delta) =&gt; boolean</code></li>
<li><code>effect</code> (string|Function): Effect ('veto' or function)</li>
</ul>
</li>
</ul>
<p><strong>Throws:</strong></p>
<ul>
<li><code>Error</code> - If hook is invalid or limit exceeded</li>
<li><code>Error</code> - If hook with same ID already exists</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">tx.addHook({
  id: 'no-eve',
  mode: 'pre',
  condition: async (store, delta) =&gt; {
    // Veto if any addition mentions "eve"
    return !delta.additions.some(q =&gt;
      q.object.value &amp;&amp; q.object.value.includes('eve')
    );
  },
  effect: 'veto'
});
</code></pre>
<hr />
<h4 id="removehookhookid"><a class="header" href="#removehookhookid"><code>removeHook(hookId)</code></a></h4>
<p>Remove a hook by ID.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>hookId</code> (string): Hook identifier to remove</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if hook was removed, false if not found</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const removed = tx.removeHook('no-eve');
console.log('Hook removed:', removed);
</code></pre>
<hr />
<h4 id="gethooks"><a class="header" href="#gethooks"><code>getHooks()</code></a></h4>
<p>Get all registered hooks.</p>
<p><strong>Returns:</strong> <code>Array&lt;Hook&gt;</code> - Array of hook definitions</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const hooks = tx.getHooks();
console.log(`${hooks.length} hooks registered`);
</code></pre>
<hr />
<h4 id="clearhooks"><a class="header" href="#clearhooks"><code>clearHooks()</code></a></h4>
<p>Clear all hooks.</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">tx.clearHooks();
</code></pre>
<hr />
<h4 id="applystore-delta-options"><a class="header" href="#applystore-delta-options"><code>apply(store, delta, options)</code></a></h4>
<p>Apply a transaction with hooks and generate receipt.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store): The store to apply the transaction to</li>
<li><code>delta</code> (Object): The delta to apply
<ul>
<li><code>additions</code> (Array<Quad>): Quads to add</li>
<li><code>removals</code> (Array<Quad>): Quads to remove</li>
</ul>
</li>
<li><code>options</code> (Object, optional): Transaction options
<ul>
<li><code>actor</code> (string): Actor identifier</li>
<li><code>skipHooks</code> (boolean): Skip hook execution. Default: false</li>
<li><code>timeoutMs</code> (number): Transaction timeout. Default: 30000</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Transaction result</p>
<ul>
<li><code>store</code> (Store): Updated store</li>
<li><code>receipt</code> (Receipt): Transaction receipt</li>
</ul>
<p><strong>Throws:</strong> <code>Error</code> - If transaction fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { Store, DataFactory } from 'n3';

const store = new Store();
const { namedNode, quad } = DataFactory;

const delta = {
  additions: [
    quad(
      namedNode('http://example.org/alice'),
      namedNode('http://xmlns.com/foaf/0.1/knows'),
      namedNode('http://example.org/bob')
    )
  ],
  removals: []
};

const result = await tx.apply(store, delta, {
  actor: 'system',
  timeoutMs: 10000
});

console.log('Committed:', result.receipt.committed);
console.log('Duration:', result.receipt.durationMs + 'ms');
console.log('Hook results:', result.receipt.hookResults);
</code></pre>
<hr />
<h4 id="createsessioninitialstore-sessionoptions"><a class="header" href="#createsessioninitialstore-sessionoptions"><code>createSession(initialStore, sessionOptions)</code></a></h4>
<p>Create a transaction session for batch operations.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>initialStore</code> (Store): Initial store state</li>
<li><code>sessionOptions</code> (Object, optional): Session options</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Transaction session</p>
<ul>
<li><code>addDelta(delta)</code>: Add a delta to the session</li>
<li><code>applyAll(options)</code>: Apply all deltas</li>
<li><code>getCurrentStore()</code>: Get current store state</li>
<li><code>getReceipts()</code>: Get all receipts</li>
<li><code>reset()</code>: Reset session</li>
<li><code>getStats()</code>: Get session statistics</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const session = tx.createSession(store);

// Add multiple deltas
session.addDelta(delta1);
session.addDelta(delta2);
session.addDelta(delta3);

// Apply all at once
const receipts = await session.applyAll({ actor: 'batch-processor' });

// Get session stats
const stats = session.getStats();
console.log(`Success rate: ${stats.successRate * 100}%`);

// Get final state
const finalStore = session.getCurrentStore();
</code></pre>
<hr />
<h4 id="getstats"><a class="header" href="#getstats"><code>getStats()</code></a></h4>
<p>Get transaction manager statistics.</p>
<p><strong>Returns:</strong> <code>Object</code> - Manager statistics</p>
<ul>
<li><code>totalHooks</code> (number): Total number of hooks</li>
<li><code>preHooks</code> (number): Number of pre-transaction hooks</li>
<li><code>postHooks</code> (number): Number of post-transaction hooks</li>
<li><code>maxHooks</code> (number): Maximum hooks allowed</li>
<li><code>strictMode</code> (boolean): Strict mode enabled</li>
<li><code>lockchain</code> (Object, optional): Lockchain statistics</li>
<li><code>performance</code> (Object): Performance metrics</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const stats = tx.getStats();
console.log(`Hooks: ${stats.totalHooks}/${stats.maxHooks}`);
console.log(`Pre: ${stats.preHooks}, Post: ${stats.postHooks}`);
</code></pre>
<hr />
<h4 id="commitlockchain"><a class="header" href="#commitlockchain"><code>commitLockchain()</code></a></h4>
<p>Commit pending lockchain entries (if lockchain enabled).</p>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Commit result</p>
<p><strong>Throws:</strong> <code>Error</code> - If lockchain is not enabled</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">if (tx.lockchainWriter) {
  const result = await tx.commitLockchain();
  console.log('Lockchain committed:', result);
}
</code></pre>
<hr />
<h3 id="transaction-receipts-1"><a class="header" href="#transaction-receipts-1">Transaction Receipts</a></h3>
<p>Transaction receipts provide comprehensive metadata about each transaction:</p>
<pre><code class="language-javascript">{
  id: 'uuid',                      // Transaction UUID
  timestamp: 1234567890,           // Unix timestamp
  durationMs: 42,                  // Duration in milliseconds
  actor: 'system',                 // Actor identifier
  committed: true,                 // Success flag
  delta: {                         // Applied delta
    additions: [...],
    removals: [...]
  },
  hookResults: [                   // Hook execution results
    {
      hookId: 'no-eve',
      mode: 'pre',
      result: true
    }
  ],
  hookErrors: [],                  // Hook errors (if any)
  beforeHash: {                    // Pre-transaction hash
    sha3: '...',
    blake3: '...'
  },
  afterHash: {                     // Post-transaction hash
    sha3: '...',
    blake3: '...'
  },
  error: null                      // Error message (if failed)
}
</code></pre>
<hr />
<h3 id="printreceiptreceipt-options"><a class="header" href="#printreceiptreceipt-options"><code>printReceipt(receipt, options)</code></a></h3>
<p>Print a receipt in a consistent format.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>receipt</code> (Receipt): The receipt to print</li>
<li><code>options</code> (Object, optional): Print options
<ul>
<li><code>verbose</code> (boolean): Include detailed information. Default: false</li>
</ul>
</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { printReceipt } from 'unrdf/knowledge-engine';

const result = await tx.apply(store, delta);
printReceipt(result.receipt, { verbose: true });
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>üìã Transaction Receipt abc-123
   Status: ‚úÖ Committed
   Duration: 42ms
   Actor: system
   Hooks: 3 executed
     ‚úÖ no-eve (pre)
     ‚úÖ validate-schema (pre)
     ‚úÖ update-index (post)
</code></pre>
<hr />
<h2 id="knowledge-hook-manager"><a class="header" href="#knowledge-hook-manager">Knowledge Hook Manager</a></h2>
<h3 id="knowledgehookmanageroptions"><a class="header" href="#knowledgehookmanageroptions"><code>KnowledgeHookManager(options)</code></a></h3>
<p>Extended transaction manager with knowledge hook support.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Manager options (extends TransactionManager)
<ul>
<li><code>basePath</code> (string): Base path for file resolution. Default: <code>process.cwd()</code></li>
<li><code>enableKnowledgeHooks</code> (boolean): Enable knowledge hook execution. Default: true</li>
<li><code>strictMode</code> (boolean): Enable strict error handling. Default: false</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>KnowledgeHookManager</code> - New knowledge hook manager instance</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { KnowledgeHookManager } from 'unrdf/knowledge-engine';

const manager = new KnowledgeHookManager({
  basePath: '/path/to/hooks',
  enableKnowledgeHooks: true,
  strictMode: true
});
</code></pre>
<hr />
<h3 id="knowledge-hook-manager-methods"><a class="header" href="#knowledge-hook-manager-methods">Knowledge Hook Manager Methods</a></h3>
<h4 id="addknowledgehookhook"><a class="header" href="#addknowledgehookhook"><code>addKnowledgeHook(hook)</code></a></h4>
<p>Register a knowledge hook.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>hook</code> (Object): Knowledge hook definition
<ul>
<li><code>meta</code> (Object): Hook metadata
<ul>
<li><code>name</code> (string): Hook name</li>
<li><code>version</code> (string): Hook version</li>
<li><code>description</code> (string): Hook description</li>
</ul>
</li>
<li><code>when</code> (Object): Trigger condition</li>
<li><code>run</code> (Function): Hook execution function <code>(event) =&gt; Promise&lt;result&gt;</code></li>
</ul>
</li>
</ul>
<p><strong>Throws:</strong></p>
<ul>
<li><code>Error</code> - If knowledge hooks are disabled</li>
<li><code>Error</code> - If hook is invalid</li>
<li><code>Error</code> - If hook with same name already exists</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">manager.addKnowledgeHook({
  meta: {
    name: 'validate-person',
    version: '1.0.0',
    description: 'Validate person data'
  },
  when: {
    'sparql-ask': `
      ASK {
        ?s a &lt;http://schema.org/Person&gt; .
      }
    `
  },
  run: async (event) =&gt; {
    // Validation logic
    const { delta } = event.payload;

    for (const quad of delta.additions) {
      // Validate quad
    }

    return {
      success: true,
      metadata: { validated: delta.additions.length }
    };
  }
});
</code></pre>
<hr />
<h4 id="removeknowledgehookhookname"><a class="header" href="#removeknowledgehookhookname"><code>removeKnowledgeHook(hookName)</code></a></h4>
<p>Remove a knowledge hook.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>hookName</code> (string): The hook name to remove</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if hook was removed</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">manager.removeKnowledgeHook('validate-person');
</code></pre>
<hr />
<h4 id="getknowledgehooks"><a class="header" href="#getknowledgehooks"><code>getKnowledgeHooks()</code></a></h4>
<p>Get all registered knowledge hooks.</p>
<p><strong>Returns:</strong> <code>Array</code> - Array of knowledge hook definitions</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const hooks = manager.getKnowledgeHooks();
console.log(`${hooks.length} knowledge hooks registered`);
</code></pre>
<hr />
<h4 id="executeknowledgehookhookname-event-options"><a class="header" href="#executeknowledgehookhookname-event-options"><code>executeKnowledgeHook(hookName, event, options)</code></a></h4>
<p>Execute a knowledge hook directly.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>hookName</code> (string): The hook name</li>
<li><code>event</code> (Object): The hook event
<ul>
<li><code>name</code> (string): Event name</li>
<li><code>payload</code> (Object): Event payload</li>
<li><code>context</code> (Object): Execution context</li>
</ul>
</li>
<li><code>options</code> (Object, optional): Execution options</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Hook execution result</p>
<ul>
<li><code>success</code> (boolean): Success flag</li>
<li><code>metadata</code> (Object): Result metadata</li>
<li><code>error</code> (string, optional): Error message</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = await manager.executeKnowledgeHook('validate-person', {
  name: 'transaction-apply',
  payload: { delta, storeSize: 100 },
  context: { graph: store }
});

console.log('Hook succeeded:', result.success);
</code></pre>
<hr />
<h4 id="loadpolicypackpackname"><a class="header" href="#loadpolicypackpackname"><code>loadPolicyPack(packName)</code></a></h4>
<p>Load and activate a policy pack.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>packName</code> (string): Policy pack name</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;boolean&gt;</code> - Success</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">await manager.loadPolicyPack('governance:core');

// All hooks from the policy pack are now active
</code></pre>
<hr />
<h4 id="deactivatepolicypackpackname"><a class="header" href="#deactivatepolicypackpackname"><code>deactivatePolicyPack(packName)</code></a></h4>
<p>Deactivate a policy pack.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>packName</code> (string): Policy pack name</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - Success</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">manager.deactivatePolicyPack('governance:core');
</code></pre>
<hr />
<h2 id="policy-pack-manager"><a class="header" href="#policy-pack-manager">Policy Pack Manager</a></h2>
<h3 id="policypackmanagerbasepath"><a class="header" href="#policypackmanagerbasepath"><code>PolicyPackManager(basePath)</code></a></h3>
<p>Manage multiple policy packs.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>basePath</code> (string, optional): Base path for policy packs. Default: <code>process.cwd()</code></li>
</ul>
<p><strong>Returns:</strong> <code>PolicyPackManager</code> - New policy pack manager instance</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { PolicyPackManager } from 'unrdf/knowledge-engine';

const ppm = new PolicyPackManager('/path/to/policy-packs');
</code></pre>
<hr />
<h3 id="policy-pack-manager-methods"><a class="header" href="#policy-pack-manager-methods">Policy Pack Manager Methods</a></h3>
<h4 id="loadpolicypackmanifestpath"><a class="header" href="#loadpolicypackmanifestpath"><code>loadPolicyPack(manifestPath)</code></a></h4>
<p>Load a policy pack from manifest file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>manifestPath</code> (string): Path to manifest file</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;PolicyPack&gt;</code> - Loaded policy pack</p>
<p><strong>Throws:</strong> <code>Error</code> - If manifest file not found or invalid</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const pack = await ppm.loadPolicyPack('/path/to/manifest.json');
console.log(`Loaded pack: ${pack.manifest.meta.name}`);
</code></pre>
<hr />
<h4 id="loadallpolicypackspacksdir"><a class="header" href="#loadallpolicypackspacksdir"><code>loadAllPolicyPacks(packsDir)</code></a></h4>
<p>Load all policy packs from a directory.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>packsDir</code> (string, optional): Directory containing policy packs</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Array&lt;PolicyPack&gt;&gt;</code> - Array of loaded policy packs</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const packs = await ppm.loadAllPolicyPacks('./policy-packs');
console.log(`Loaded ${packs.length} policy packs`);
</code></pre>
<hr />
<h4 id="activatepolicypackpackname"><a class="header" href="#activatepolicypackpackname"><code>activatePolicyPack(packName)</code></a></h4>
<p>Activate a policy pack.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>packName</code> (string): Policy pack name</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - Success</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>Error</code> - If policy pack not found</li>
<li><code>Error</code> - If policy pack is disabled</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">ppm.activatePolicyPack('governance:core');
</code></pre>
<hr />
<h4 id="getactivepolicypacks"><a class="header" href="#getactivepolicypacks"><code>getActivePolicyPacks()</code></a></h4>
<p>Get all active policy packs.</p>
<p><strong>Returns:</strong> <code>Array&lt;PolicyPack&gt;</code> - Array of active policy packs</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const active = ppm.getActivePolicyPacks();
console.log('Active packs:', active.map(p =&gt; p.manifest.meta.name));
</code></pre>
<hr />
<h4 id="getactivehooks"><a class="header" href="#getactivehooks"><code>getActiveHooks()</code></a></h4>
<p>Get all hooks from active policy packs.</p>
<p><strong>Returns:</strong> <code>Array</code> - Array of hook definitions (sorted by priority)</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const hooks = ppm.getActiveHooks();
console.log(`${hooks.length} active hooks`);
</code></pre>
<hr />
<h2 id="policy-pack-structure"><a class="header" href="#policy-pack-structure">Policy Pack Structure</a></h2>
<p>Policy packs are versioned governance units that bundle related hooks:</p>
<pre><code>policy-packs/
  governance:core/
    manifest.json          # Pack metadata and configuration
    hooks/
      validate-schema.mjs  # Hook implementations
      check-permissions.mjs
    conditions/
      has-rdf-type.sparql  # Reusable conditions
    resources/
      schema.ttl           # Related resources
</code></pre>
<h3 id="manifest-format"><a class="header" href="#manifest-format">Manifest Format</a></h3>
<pre><code class="language-json">{
  "id": "uuid",
  "meta": {
    "name": "governance:core",
    "version": "1.0.0",
    "description": "Core governance policies",
    "author": "Your Team",
    "license": "MIT"
  },
  "config": {
    "enabled": true,
    "priority": 50,
    "strictMode": false,
    "timeout": 30000
  },
  "hooks": [
    {
      "name": "validate-schema",
      "file": "hooks/validate-schema.mjs",
      "enabled": true,
      "priority": 80
    }
  ],
  "conditions": [
    {
      "name": "has-rdf-type",
      "file": "conditions/has-rdf-type.sparql",
      "type": "sparql-ask"
    }
  ]
}
</code></pre>
<hr />
<h2 id="best-practices-15"><a class="header" href="#best-practices-15">Best Practices</a></h2>
<h3 id="hook-organization"><a class="header" href="#hook-organization">Hook Organization</a></h3>
<p>Group related hooks into policy packs:</p>
<pre><code class="language-javascript">// Load policy packs
await manager.loadPolicyPack('governance:core');
await manager.loadPolicyPack('security:validation');
await manager.loadPolicyPack('compliance:gdpr');

// All hooks are now active and prioritized
</code></pre>
<h3 id="error-handling-10"><a class="header" href="#error-handling-10">Error Handling</a></h3>
<p>Use strict mode for critical systems:</p>
<pre><code class="language-javascript">const tx = new TransactionManager({
  strictMode: true  // Fail fast on hook errors
});
</code></pre>
<h3 id="performance-1"><a class="header" href="#performance-1">Performance</a></h3>
<p>Use <code>afterHashOnly</code> for high-throughput systems:</p>
<pre><code class="language-javascript">const tx = new TransactionManager({
  afterHashOnly: true  // Skip expensive canonicalization
});
</code></pre>
<h3 id="receipt-verification"><a class="header" href="#receipt-verification">Receipt Verification</a></h3>
<p>Always verify transaction receipts:</p>
<pre><code class="language-javascript">const result = await tx.apply(store, delta);

if (result.receipt.committed) {
  console.log('‚úÖ Transaction committed');
  console.log('Hash:', result.receipt.afterHash.sha3);
} else {
  console.error('‚ùå Transaction failed');
  console.error('Error:', result.receipt.error);
}
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="composables-api-reference"><a class="header" href="#composables-api-reference">Composables API Reference</a></h1>
<p>UNRDF provides composable functions for common RDF operations. All composables use the store context established by <code>initStore()</code>.</p>
<h2 id="graph-operations-1"><a class="header" href="#graph-operations-1">Graph Operations</a></h2>
<h3 id="usegraph"><a class="header" href="#usegraph"><code>useGraph()</code></a></h3>
<p>Access high-level RDF graph operations with SPARQL querying and graph transformations.</p>
<p><strong>Returns:</strong> <code>Object</code> - Graph operations interface</p>
<p><strong>Throws:</strong> <code>Error</code> - If store context is not initialized</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useGraph } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const graph = useGraph();

  // Execute SPARQL queries
  const results = await graph.select(`
    SELECT ?s ?p ?o WHERE { ?s ?p ?o }
  `);
});
</code></pre>
<hr />
<h3 id="graph-api-methods"><a class="header" href="#graph-api-methods">Graph API Methods</a></h3>
<h4 id="querysparql-options-2"><a class="header" href="#querysparql-options-2"><code>query(sparql, options)</code></a></h4>
<p>Execute any valid SPARQL 1.1 query.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL query string</li>
<li><code>options</code> (Object, optional): Query options
<ul>
<li><code>limit</code> (number): Result limit</li>
<li><code>signal</code> (AbortSignal): Abort signal</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Query result object</p>
<p><strong>Throws:</strong> <code>TypeError</code> - If sparql is not a string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = await graph.query(`
  PREFIX ex: &lt;http://example.org/&gt;
  SELECT ?name WHERE {
    ?person ex:name ?name .
  }
`, { limit: 10 });
</code></pre>
<hr />
<h4 id="selectsparql"><a class="header" href="#selectsparql"><code>select(sparql)</code></a></h4>
<p>Execute a SPARQL SELECT query.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL SELECT query string</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Array&lt;Object&gt;&gt;</code> - Array of result bindings</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If sparql is not a string</li>
<li><code>Error</code> - If query is not a SELECT query</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const people = await graph.select(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  SELECT ?person ?name WHERE {
    ?person foaf:name ?name .
  }
`);

people.forEach(row =&gt; {
  console.log(`${row.person.value}: ${row.name.value}`);
});
</code></pre>
<hr />
<h4 id="asksparql"><a class="header" href="#asksparql"><code>ask(sparql)</code></a></h4>
<p>Execute a SPARQL ASK query.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL ASK query string</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;boolean&gt;</code> - Boolean result</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If sparql is not a string</li>
<li><code>Error</code> - If query is not an ASK query</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const hasAlice = await graph.ask(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  ASK {
    ?person foaf:name "Alice" .
  }
`);

console.log('Has Alice:', hasAlice);
</code></pre>
<hr />
<h4 id="constructsparql"><a class="header" href="#constructsparql"><code>construct(sparql)</code></a></h4>
<p>Execute a SPARQL CONSTRUCT query.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL CONSTRUCT query string</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Store&gt;</code> - New store with constructed triples</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If sparql is not a string</li>
<li><code>Error</code> - If query is not a CONSTRUCT query</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const inferredStore = await graph.construct(`
  PREFIX foaf: &lt;http://xmlns.com/foaf/0.1/&gt;
  PREFIX ex: &lt;http://example.org/&gt;
  CONSTRUCT {
    ?person1 ex:friend ?person2 .
  }
  WHERE {
    ?person1 foaf:knows ?person2 .
  }
`);
</code></pre>
<hr />
<h4 id="updatesparql"><a class="header" href="#updatesparql"><code>update(sparql)</code></a></h4>
<p>Execute a SPARQL UPDATE query.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>sparql</code> (string): SPARQL UPDATE query string</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Update result</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If sparql is not a string</li>
<li><code>Error</code> - If query is not an UPDATE query</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">await graph.update(`
  PREFIX ex: &lt;http://example.org/&gt;
  INSERT DATA {
    ex:alice ex:age "30" .
    ex:alice ex:city "NYC" .
  }
`);
</code></pre>
<hr />
<h4 id="serializeoptions-2"><a class="header" href="#serializeoptions-2"><code>serialize(options)</code></a></h4>
<p>Serialize the graph to a string.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Serialization options
<ul>
<li><code>format</code> (string): Output format ('Turtle' or 'N-Quads'). Default: 'Turtle'</li>
<li><code>prefixes</code> (Object): Prefix mappings</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Serialized string</p>
<p><strong>Throws:</strong></p>
<ul>
<li><code>TypeError</code> - If options is not an object</li>
<li><code>Error</code> - If format is unsupported</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const turtle = graph.serialize({
  format: 'Turtle',
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  }
});
</code></pre>
<hr />
<h4 id="stats-2"><a class="header" href="#stats-2"><code>stats()</code></a></h4>
<p>Get graph statistics.</p>
<p><strong>Returns:</strong> <code>Object</code> - Graph statistics</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const stats = graph.stats();
console.log(`Quads: ${stats.quads}`);
console.log(`Subjects: ${stats.subjects}`);
</code></pre>
<hr />
<h4 id="unionothergraphs"><a class="header" href="#unionothergraphs"><code>union(...otherGraphs)</code></a></h4>
<p>Create a new graph containing the union of this graph and others.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...otherGraphs</code> (Object|Store): Other useGraph instances or Stores</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - New useGraph instance with union</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const graph1 = useGraph();
const graph2 = createTemporaryGraph(store2);

const combined = graph1.union(graph2);
console.log('Combined size:', combined.size);
</code></pre>
<hr />
<h4 id="differenceothergraph"><a class="header" href="#differenceothergraph"><code>difference(otherGraph)</code></a></h4>
<p>Create a new graph containing quads in this graph but not in the other.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>otherGraph</code> (Object|Store): Another useGraph instance or Store</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - New useGraph instance with difference</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const diff = graph1.difference(graph2);
</code></pre>
<hr />
<h4 id="intersectionothergraph"><a class="header" href="#intersectionothergraph"><code>intersection(otherGraph)</code></a></h4>
<p>Create a new graph containing only quads that exist in both graphs.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>otherGraph</code> (Object|Store): Another useGraph instance or Store</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - New useGraph instance with intersection</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const common = graph1.intersection(graph2);
</code></pre>
<hr />
<h2 id="turtle-operations"><a class="header" href="#turtle-operations">Turtle Operations</a></h2>
<h3 id="useturtlegraphdir-options"><a class="header" href="#useturtlegraphdir-options"><code>useTurtle(graphDir, options)</code></a></h3>
<p>File system operations for Turtle (.ttl) files.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>graphDir</code> (string, optional): Directory containing Turtle files. Default: './graph'</li>
<li><code>options</code> (Object, optional): Turtle options
<ul>
<li><code>baseIRI</code> (string): Base IRI for parsing. Default: 'http://example.org/'</li>
<li><code>autoLoad</code> (boolean): Automatically load all .ttl files. Default: true</li>
<li><code>validateOnLoad</code> (boolean): Validate files on load. Default: true</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Turtle file system interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useTurtle } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const turtle = useTurtle('./my-data', {
    baseIRI: 'http://example.org/',
    autoLoad: true
  });

  // Load all .ttl files
  turtle.loadAll();
});
</code></pre>
<hr />
<h3 id="turtle-api-methods"><a class="header" href="#turtle-api-methods">Turtle API Methods</a></h3>
<h4 id="loadalloptions"><a class="header" href="#loadalloptions"><code>loadAll(options)</code></a></h4>
<p>Load all .ttl files from the graph directory.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Load options
<ul>
<li><code>merge</code> (boolean): Merge with existing store. Default: true</li>
<li><code>validate</code> (boolean): Validate files on load</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Load result</p>
<ul>
<li><code>loaded</code> (number): Number of files loaded</li>
<li><code>files</code> (Array<string>): Loaded file names</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = turtle.loadAll({ merge: true, validate: true });
console.log(`Loaded ${result.loaded} files:`, result.files);
</code></pre>
<hr />
<h4 id="loadfilename-options"><a class="header" href="#loadfilename-options"><code>load(fileName, options)</code></a></h4>
<p>Load a specific Turtle file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fileName</code> (string): Name of the file (without .ttl extension)</li>
<li><code>options</code> (Object, optional): Load options
<ul>
<li><code>merge</code> (boolean): Merge with existing store. Default: true</li>
<li><code>validate</code> (boolean): Validate file on load</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - Loaded store</p>
<p><strong>Throws:</strong> <code>Error</code> - If file not found</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const store = turtle.load('ontology', {
  merge: true,
  validate: true
});
</code></pre>
<hr />
<h4 id="savefilename-options"><a class="header" href="#savefilename-options"><code>save(fileName, options)</code></a></h4>
<p>Save the current store to a Turtle file.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fileName</code> (string): Name of the file (without .ttl extension)</li>
<li><code>options</code> (Object, optional): Save options
<ul>
<li><code>prefixes</code> (Object): Prefix mappings</li>
<li><code>createBackup</code> (boolean): Create backup of existing file. Default: false</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Save result</p>
<ul>
<li><code>path</code> (string): File path</li>
<li><code>bytes</code> (number): File size in bytes</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = turtle.save('export', {
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  },
  createBackup: true
});

console.log(`Saved to ${result.path} (${result.bytes} bytes)`);
</code></pre>
<hr />
<h4 id="listfiles"><a class="header" href="#listfiles"><code>listFiles()</code></a></h4>
<p>List all .ttl files in the graph directory.</p>
<p><strong>Returns:</strong> <code>Array&lt;string&gt;</code> - Array of file names</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const files = turtle.listFiles();
console.log('Available files:', files);
</code></pre>
<hr />
<h4 id="parsettl-options"><a class="header" href="#parsettl-options"><code>parse(ttl, options)</code></a></h4>
<p>Parse a Turtle string into a store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>ttl</code> (string): Turtle string</li>
<li><code>options</code> (Object, optional): Parse options
<ul>
<li><code>addToStore</code> (boolean): Add parsed data to context store. Default: false</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - Parsed store</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const turtleData = `
  @prefix ex: &lt;http://example.org/&gt; .
  ex:alice ex:knows ex:bob .
`;

const store = turtle.parse(turtleData, { addToStore: true });
</code></pre>
<hr />
<h2 id="delta-operations"><a class="header" href="#delta-operations">Delta Operations</a></h2>
<h3 id="usedeltaoptions"><a class="header" href="#usedeltaoptions"><code>useDelta(options)</code></a></h3>
<p>Track and apply graph changes (deltas).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>options</code> (Object, optional): Delta options
<ul>
<li><code>deterministic</code> (boolean): Enable deterministic operations. Default: true</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Delta interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useDelta } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const delta = useDelta({ deterministic: true });

  // Compare and sync stores
  const changes = delta.compareWith(newStore);
  delta.apply(changes);
});
</code></pre>
<hr />
<h3 id="delta-api-methods"><a class="header" href="#delta-api-methods">Delta API Methods</a></h3>
<h4 id="comparewithnewstore"><a class="header" href="#comparewithnewstore"><code>compareWith(newStore)</code></a></h4>
<p>Compare current context store with new data and return differences.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>newStore</code> (Store): New data store to compare against</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Comparison result</p>
<ul>
<li><code>added</code> (Store): Quads added in new store</li>
<li><code>removed</code> (Store): Quads removed from context</li>
<li><code>addedCount</code> (number): Number of added quads</li>
<li><code>removedCount</code> (number): Number of removed quads</li>
<li><code>unchangedCount</code> (number): Number of unchanged quads</li>
<li><code>contextSize</code> (number): Size of context store</li>
<li><code>newDataSize</code> (number): Size of new store</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const newStore = engine.parseTurtle(newData);
const changes = delta.compareWith(newStore);

console.log(`Added: ${changes.addedCount}, Removed: ${changes.removedCount}`);
</code></pre>
<hr />
<h4 id="syncwithnewstore-options"><a class="header" href="#syncwithnewstore-options"><code>syncWith(newStore, options)</code></a></h4>
<p>Compare and apply changes in one operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>newStore</code> (Store): New data store</li>
<li><code>options</code> (Object, optional): Sync options
<ul>
<li><code>dryRun</code> (boolean): Don't actually apply changes. Default: false</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Apply result with comparison info</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const result = delta.syncWith(newStore, { dryRun: false });
console.log(`Synced: +${result.added} -${result.removed}`);
</code></pre>
<hr />
<h4 id="applychanges-options"><a class="header" href="#applychanges-options"><code>apply(changes, options)</code></a></h4>
<p>Apply changes to the current store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>changes</code> (Object): Changes to apply
<ul>
<li><code>added</code> (Store): Quads to add</li>
<li><code>removed</code> (Store): Quads to remove</li>
</ul>
</li>
<li><code>options</code> (Object, optional): Apply options
<ul>
<li><code>dryRun</code> (boolean): Don't actually apply changes. Default: false</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Apply result</p>
<ul>
<li><code>success</code> (boolean): Success flag</li>
<li><code>added</code> (number): Number of quads added</li>
<li><code>removed</code> (number): Number of quads removed</li>
<li><code>originalSize</code> (number): Original store size</li>
<li><code>finalSize</code> (number): Final store size</li>
<li><code>dryRun</code> (boolean): Whether this was a dry run</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const changes = delta.compareWith(newStore);
const result = delta.apply(changes, { dryRun: false });

console.log(`Applied: +${result.added} -${result.removed}`);
console.log(`Store size: ${result.originalSize} ‚Üí ${result.finalSize}`);
</code></pre>
<hr />
<h4 id="getstatschanges"><a class="header" href="#getstatschanges"><code>getStats(changes)</code></a></h4>
<p>Get statistics about changes.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>changes</code> (Object): Changes object</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Statistics</p>
<ul>
<li><code>added</code> (Object): Added statistics</li>
<li><code>removed</code> (Object): Removed statistics</li>
<li><code>total</code> (Object): Total statistics</li>
<li><code>coverage</code> (Object): Coverage information</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const stats = delta.getStats(changes);
console.log('Net change:', stats.total.netChange);
console.log('Affected subjects:', stats.coverage.addedSubjects);
</code></pre>
<hr />
<h4 id="mergechangesets"><a class="header" href="#mergechangesets"><code>merge(...changeSets)</code></a></h4>
<p>Merge multiple change sets.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...changeSets</code> (Object): Change sets to merge</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Merged changes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const merged = delta.merge(changes1, changes2, changes3);
</code></pre>
<hr />
<h4 id="invertchanges"><a class="header" href="#invertchanges"><code>invert(changes)</code></a></h4>
<p>Invert changes (swap added and removed).</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>changes</code> (Object): Changes to invert</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Inverted changes</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">const inverted = delta.invert(changes);
// Apply inverted to undo changes
delta.apply(inverted);
</code></pre>
<hr />
<h2 id="term-operations"><a class="header" href="#term-operations">Term Operations</a></h2>
<h3 id="useterms"><a class="header" href="#useterms"><code>useTerms()</code></a></h3>
<p>Create and manipulate RDF terms.</p>
<p><strong>Returns:</strong> <code>Object</code> - Terms interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useTerms } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const terms = useTerms();

  const alice = terms.namedNode('http://example.org/alice');
  const name = terms.literal('Alice');
});
</code></pre>
<hr />
<h2 id="prefix-operations"><a class="header" href="#prefix-operations">Prefix Operations</a></h2>
<h3 id="useprefixes"><a class="header" href="#useprefixes"><code>usePrefixes()</code></a></h3>
<p>Manage namespace prefixes.</p>
<p><strong>Returns:</strong> <code>Object</code> - Prefixes interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, usePrefixes } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const prefixes = usePrefixes();

  prefixes.register('ex', 'http://example.org/');
  prefixes.register('foaf', 'http://xmlns.com/foaf/0.1/');

  const expanded = prefixes.expand('ex:alice');
  // =&gt; 'http://example.org/alice'
});
</code></pre>
<hr />
<h2 id="validation-operations"><a class="header" href="#validation-operations">Validation Operations</a></h2>
<h3 id="usevalidator"><a class="header" href="#usevalidator"><code>useValidator()</code></a></h3>
<p>SHACL validation operations.</p>
<p><strong>Returns:</strong> <code>Object</code> - Validator interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useValidator } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const validator = useValidator();

  const report = validator.validate(shapesStore);
  console.log('Valid:', report.conforms);
});
</code></pre>
<hr />
<h2 id="reasoning-operations"><a class="header" href="#reasoning-operations">Reasoning Operations</a></h2>
<h3 id="usereasoner"><a class="header" href="#usereasoner"><code>useReasoner()</code></a></h3>
<p>Inference and reasoning operations.</p>
<p><strong>Returns:</strong> <code>Object</code> - Reasoner interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useReasoner } from 'unrdf';

const runApp = initStore();

runApp(() =&gt; {
  const reasoner = useReasoner();

  const inferred = reasoner.inferTransitive(
    'http://www.w3.org/2000/01/rdf-schema#subClassOf'
  );
});
</code></pre>
<hr />
<h2 id="canonicalization-operations"><a class="header" href="#canonicalization-operations">Canonicalization Operations</a></h2>
<h3 id="usecanon"><a class="header" href="#usecanon"><code>useCanon()</code></a></h3>
<p>RDF canonicalization using URDNA2015.</p>
<p><strong>Returns:</strong> <code>Object</code> - Canonicalization interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useCanon } from 'unrdf';

const runApp = initStore();

runApp(async () =&gt; {
  const canon = useCanon();

  const canonical = await canon.canonicalize();
  const hash = await canon.hash();

  console.log('Canonical hash:', hash);
});
</code></pre>
<hr />
<h2 id="type-safety-operations"><a class="header" href="#type-safety-operations">Type Safety Operations</a></h2>
<h3 id="usezod"><a class="header" href="#usezod"><code>useZod()</code></a></h3>
<p>Zod-based type validation for RDF data.</p>
<p><strong>Returns:</strong> <code>Object</code> - Zod validation interface</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { initStore, useZod } from 'unrdf';
import { z } from 'zod';

const runApp = initStore();

runApp(() =&gt; {
  const zodRdf = useZod();

  const PersonSchema = z.object({
    name: z.string(),
    age: z.number(),
    knows: z.array(z.string())
  });

  const person = zodRdf.validate('http://example.org/alice', PersonSchema);
});
</code></pre>
<hr />
<h2 id="best-practices-16"><a class="header" href="#best-practices-16">Best Practices</a></h2>
<h3 id="composable-composition-1"><a class="header" href="#composable-composition-1">Composable Composition</a></h3>
<p>Combine multiple composables for complex operations:</p>
<pre><code class="language-javascript">const graph = useGraph();
const delta = useDelta();
const turtle = useTurtle();

// Load data
turtle.loadAll();

// Query data
const results = await graph.select('SELECT * WHERE { ?s ?p ?o }');

// Track changes
const newStore = turtle.load('updates');
const changes = delta.compareWith(newStore);
delta.apply(changes);
</code></pre>
<h3 id="error-handling-11"><a class="header" href="#error-handling-11">Error Handling</a></h3>
<p>Always handle errors from async operations:</p>
<pre><code class="language-javascript">try {
  const results = await graph.select(sparqlQuery);
} catch (error) {
  console.error('Query failed:', error.message);
}
</code></pre>
<h3 id="performance-2"><a class="header" href="#performance-2">Performance</a></h3>
<p>Use deterministic mode for reproducible results:</p>
<pre><code class="language-javascript">const delta = useDelta({ deterministic: true });
const graph = useGraph();

const results = await graph.query(sparql, { deterministic: true });
</code></pre>
<div style="break-before: page; page-break-before: always;"></div><h1 id="utilities-api-reference"><a class="header" href="#utilities-api-reference">Utilities API Reference</a></h1>
<p>UNRDF provides utility functions for common RDF operations, error handling, validation, and debugging.</p>
<h2 id="parsing--serialization-1"><a class="header" href="#parsing--serialization-1">Parsing &amp; Serialization</a></h2>
<h3 id="parseturtlettl-options"><a class="header" href="#parseturtlettl-options"><code>parseTurtle(ttl, options)</code></a></h3>
<p>Parse Turtle string into RDF quads.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>ttl</code> (string): Turtle/TriG string (required)</li>
<li><code>options</code> (Object, optional): Parse options
<ul>
<li><code>baseIRI</code> (string): Base IRI for resolving relative URIs</li>
<li><code>blankNodePrefix</code> (string): Prefix for blank node identifiers</li>
<li><code>format</code> (string): Format ('Turtle', 'TriG', 'N-Triples', 'N-Quads')</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - N3 Store containing parsed quads</p>
<p><strong>Throws:</strong> <code>Error</code> - If parsing fails</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { parseTurtle } from 'unrdf/utils';

const ttl = `
  @prefix ex: &lt;http://example.org/&gt; .
  ex:alice ex:knows ex:bob .
`;

const store = parseTurtle(ttl, {
  baseIRI: 'http://example.org/'
});

console.log('Parsed', store.size, 'quads');
</code></pre>
<hr />
<h3 id="serializeturtlestore-options"><a class="header" href="#serializeturtlestore-options"><code>serializeTurtle(store, options)</code></a></h3>
<p>Serialize RDF quads to Turtle string.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store|Array): N3 Store or array of quads (required)</li>
<li><code>options</code> (Object, optional): Serialization options
<ul>
<li><code>prefixes</code> (Object): Namespace prefix mappings</li>
<li><code>format</code> (string): Output format ('Turtle', 'TriG', 'N-Triples', 'N-Quads')</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Serialized Turtle/TriG string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { serializeTurtle } from 'unrdf/utils';

const turtle = serializeTurtle(store, {
  prefixes: {
    ex: 'http://example.org/',
    foaf: 'http://xmlns.com/foaf/0.1/'
  },
  format: 'Turtle'
});

console.log(turtle);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code class="language-turtle">@prefix ex: &lt;http://example.org/&gt; .
@prefix foaf: &lt;http://xmlns.com/foaf/0.1/&gt; .

ex:alice foaf:knows ex:bob .
</code></pre>
<hr />
<h3 id="parsenquadsnquads-options"><a class="header" href="#parsenquadsnquads-options"><code>parseNQuads(nquads, options)</code></a></h3>
<p>Parse N-Quads string into RDF quads.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>nquads</code> (string): N-Quads string (required)</li>
<li><code>options</code> (Object, optional): Parse options</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - N3 Store containing parsed quads</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { parseNQuads } from 'unrdf/utils';

const nquads = `
  &lt;http://example.org/alice&gt; &lt;http://xmlns.com/foaf/0.1/knows&gt; &lt;http://example.org/bob&gt; .
`;

const store = parseNQuads(nquads);
</code></pre>
<hr />
<h3 id="serializenquadsstore"><a class="header" href="#serializenquadsstore"><code>serializeNQuads(store)</code></a></h3>
<p>Serialize RDF quads to N-Quads string.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store|Array): N3 Store or array of quads (required)</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Serialized N-Quads string</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { serializeNQuads } from 'unrdf/utils';

const nquads = serializeNQuads(store);
console.log(nquads);
</code></pre>
<hr />
<h2 id="validation-1"><a class="header" href="#validation-1">Validation</a></h2>
<h3 id="validatequadquad"><a class="header" href="#validatequadquad"><code>validateQuad(quad)</code></a></h3>
<p>Validate that an object is a valid RDF quad.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>quad</code> (Object): Object to validate (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Validation result</p>
<ul>
<li><code>valid</code> (boolean): Is valid quad</li>
<li><code>errors</code> (Array<string>): Validation errors</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { validateQuad } from 'unrdf/utils';
import { DataFactory } from 'n3';

const { namedNode, literal, quad } = DataFactory;

const q = quad(
  namedNode('http://example.org/alice'),
  namedNode('http://xmlns.com/foaf/0.1/name'),
  literal('Alice')
);

const result = validateQuad(q);
console.log('Valid:', result.valid);
console.log('Errors:', result.errors);
</code></pre>
<hr />
<h3 id="validatestorestore"><a class="header" href="#validatestorestore"><code>validateStore(store)</code></a></h3>
<p>Validate that a store is properly formatted.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store): N3 Store to validate (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Validation result</p>
<ul>
<li><code>valid</code> (boolean): Is valid store</li>
<li><code>errors</code> (Array<string>): Validation errors</li>
<li><code>warnings</code> (Array<string>): Validation warnings</li>
<li><code>stats</code> (Object): Store statistics</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { validateStore } from 'unrdf/utils';

const result = validateStore(store);

if (!result.valid) {
  console.error('Invalid store:', result.errors);
} else {
  console.log('Valid store with', result.stats.quads, 'quads');
}
</code></pre>
<hr />
<h3 id="validateturtlettl"><a class="header" href="#validateturtlettl"><code>validateTurtle(ttl)</code></a></h3>
<p>Validate Turtle syntax without parsing.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>ttl</code> (string): Turtle string to validate (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Validation result</p>
<ul>
<li><code>valid</code> (boolean): Is valid Turtle</li>
<li><code>errors</code> (Array<Object>): Syntax errors with line/column info</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { validateTurtle } from 'unrdf/utils';

const ttl = `
  @prefix ex: &lt;http://example.org/&gt; .
  ex:alice ex:knows ex:bob .
`;

const result = validateTurtle(ttl);

if (!result.valid) {
  result.errors.forEach(err =&gt; {
    console.error(`Line ${err.line}, column ${err.column}: ${err.message}`);
  });
}
</code></pre>
<hr />
<h2 id="term-utilities"><a class="header" href="#term-utilities">Term Utilities</a></h2>
<h3 id="isnamednodeterm"><a class="header" href="#isnamednodeterm"><code>isNamedNode(term)</code></a></h3>
<p>Check if a term is a named node.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>term</code> (Term): RDF term to check (required)</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if named node</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { isNamedNode } from 'unrdf/utils';
import { DataFactory } from 'n3';

const { namedNode, literal } = DataFactory;

console.log(isNamedNode(namedNode('http://example.org/alice'))); // true
console.log(isNamedNode(literal('Alice'))); // false
</code></pre>
<hr />
<h3 id="isliteralterm"><a class="header" href="#isliteralterm"><code>isLiteral(term)</code></a></h3>
<p>Check if a term is a literal.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>term</code> (Term): RDF term to check (required)</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if literal</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { isLiteral } from 'unrdf/utils';

console.log(isLiteral(literal('Alice'))); // true
console.log(isLiteral(namedNode('http://example.org/alice'))); // false
</code></pre>
<hr />
<h3 id="isblanknodeterm"><a class="header" href="#isblanknodeterm"><code>isBlankNode(term)</code></a></h3>
<p>Check if a term is a blank node.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>term</code> (Term): RDF term to check (required)</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if blank node</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { isBlankNode } from 'unrdf/utils';
import { DataFactory } from 'n3';

const { blankNode } = DataFactory;

console.log(isBlankNode(blankNode('b1'))); // true
</code></pre>
<hr />
<h3 id="termequalsterm1-term2"><a class="header" href="#termequalsterm1-term2"><code>termEquals(term1, term2)</code></a></h3>
<p>Check if two terms are equal.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>term1</code> (Term): First term (required)</li>
<li><code>term2</code> (Term): Second term (required)</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if terms are equal</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { termEquals } from 'unrdf/utils';
import { DataFactory } from 'n3';

const { namedNode } = DataFactory;

const alice1 = namedNode('http://example.org/alice');
const alice2 = namedNode('http://example.org/alice');
const bob = namedNode('http://example.org/bob');

console.log(termEquals(alice1, alice2)); // true
console.log(termEquals(alice1, bob)); // false
</code></pre>
<hr />
<h3 id="getliteralvalueliteral"><a class="header" href="#getliteralvalueliteral"><code>getLiteralValue(literal)</code></a></h3>
<p>Get the string value of a literal.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>literal</code> (Literal): Literal term (required)</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Literal value</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { getLiteralValue } from 'unrdf/utils';
import { DataFactory } from 'n3';

const { literal } = DataFactory;

const name = literal('Alice');
console.log(getLiteralValue(name)); // "Alice"

const age = literal('30', 'http://www.w3.org/2001/XMLSchema#integer');
console.log(getLiteralValue(age)); // "30"
</code></pre>
<hr />
<h3 id="getliteraldatatypeliteral"><a class="header" href="#getliteraldatatypeliteral"><code>getLiteralDatatype(literal)</code></a></h3>
<p>Get the datatype IRI of a literal.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>literal</code> (Literal): Literal term (required)</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Datatype IRI</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { getLiteralDatatype } from 'unrdf/utils';

const age = literal('30', 'http://www.w3.org/2001/XMLSchema#integer');
console.log(getLiteralDatatype(age));
// =&gt; "http://www.w3.org/2001/XMLSchema#integer"
</code></pre>
<hr />
<h2 id="quad-utilities"><a class="header" href="#quad-utilities">Quad Utilities</a></h2>
<h3 id="quadequalsquad1-quad2"><a class="header" href="#quadequalsquad1-quad2"><code>quadEquals(quad1, quad2)</code></a></h3>
<p>Check if two quads are equal.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>quad1</code> (Quad): First quad (required)</li>
<li><code>quad2</code> (Quad): Second quad (required)</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if quads are equal</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { quadEquals } from 'unrdf/utils';

const q1 = quad(alice, knows, bob);
const q2 = quad(alice, knows, bob);

console.log(quadEquals(q1, q2)); // true
</code></pre>
<hr />
<h3 id="clonequadquad"><a class="header" href="#clonequadquad"><code>cloneQuad(quad)</code></a></h3>
<p>Create a deep copy of a quad.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>quad</code> (Quad): Quad to clone (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Quad</code> - Cloned quad</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { cloneQuad } from 'unrdf/utils';

const original = quad(alice, knows, bob);
const copy = cloneQuad(original);

console.log(quadEquals(original, copy)); // true
console.log(original === copy); // false
</code></pre>
<hr />
<h3 id="matchespatternquad-pattern"><a class="header" href="#matchespatternquad-pattern"><code>matchesPattern(quad, pattern)</code></a></h3>
<p>Check if a quad matches a pattern.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>quad</code> (Quad): Quad to check (required)</li>
<li><code>pattern</code> (Object): Pattern to match
<ul>
<li><code>subject</code> (Term|null): Subject pattern</li>
<li><code>predicate</code> (Term|null): Predicate pattern</li>
<li><code>object</code> (Term|null): Object pattern</li>
<li><code>graph</code> (Term|null): Graph pattern</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if quad matches pattern</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { matchesPattern } from 'unrdf/utils';

const q = quad(alice, knows, bob);

// Match specific predicate
const matches = matchesPattern(q, {
  subject: null,
  predicate: knows,
  object: null,
  graph: null
});

console.log('Matches:', matches); // true
</code></pre>
<hr />
<h2 id="store-utilities"><a class="header" href="#store-utilities">Store Utilities</a></h2>
<h3 id="mergestoresstores"><a class="header" href="#mergestoresstores"><code>mergeStores(...stores)</code></a></h3>
<p>Merge multiple stores into one.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>...stores</code> (Store[]): Stores to merge (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - New store containing all quads</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { mergeStores } from 'unrdf/utils';

const store1 = new Store([quad1, quad2]);
const store2 = new Store([quad3, quad4]);

const merged = mergeStores(store1, store2);
console.log('Merged size:', merged.size);
</code></pre>
<hr />
<h3 id="clonestorestore"><a class="header" href="#clonestorestore"><code>cloneStore(store)</code></a></h3>
<p>Create a deep copy of a store.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store): Store to clone (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - Cloned store</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { cloneStore } from 'unrdf/utils';

const original = new Store([quad1, quad2]);
const copy = cloneStore(original);

console.log('Copy size:', copy.size);
console.log('Same reference:', original === copy); // false
</code></pre>
<hr />
<h3 id="filterstorestore-predicate"><a class="header" href="#filterstorestore-predicate"><code>filterStore(store, predicate)</code></a></h3>
<p>Filter a store based on a predicate function.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store): Store to filter (required)</li>
<li><code>predicate</code> (Function): Filter function <code>(quad) =&gt; boolean</code> (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - New store with filtered quads</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { filterStore } from 'unrdf/utils';

const filtered = filterStore(store, quad =&gt; {
  return quad.predicate.value === 'http://xmlns.com/foaf/0.1/knows';
});

console.log('Filtered size:', filtered.size);
</code></pre>
<hr />
<h3 id="mapstorestore-mapper"><a class="header" href="#mapstorestore-mapper"><code>mapStore(store, mapper)</code></a></h3>
<p>Map quads in a store using a mapper function.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store): Store to map (required)</li>
<li><code>mapper</code> (Function): Map function <code>(quad) =&gt; quad</code> (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Store</code> - New store with mapped quads</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { mapStore } from 'unrdf/utils';

// Replace all blank nodes with named nodes
const mapped = mapStore(store, quad =&gt; {
  if (quad.subject.termType === 'BlankNode') {
    return quad({
      subject: namedNode(`http://example.org/${quad.subject.value}`),
      predicate: quad.predicate,
      object: quad.object,
      graph: quad.graph
    });
  }
  return quad;
});
</code></pre>
<hr />
<h2 id="prefix-utilities"><a class="header" href="#prefix-utilities">Prefix Utilities</a></h2>
<h3 id="expandprefixprefixed-prefixes"><a class="header" href="#expandprefixprefixed-prefixes"><code>expandPrefix(prefixed, prefixes)</code></a></h3>
<p>Expand a prefixed URI to full IRI.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>prefixed</code> (string): Prefixed URI (e.g., 'ex:alice') (required)</li>
<li><code>prefixes</code> (Object): Prefix mappings (required)</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Expanded IRI</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { expandPrefix } from 'unrdf/utils';

const prefixes = {
  ex: 'http://example.org/',
  foaf: 'http://xmlns.com/foaf/0.1/'
};

const expanded = expandPrefix('ex:alice', prefixes);
console.log(expanded); // "http://example.org/alice"
</code></pre>
<hr />
<h3 id="compactiriiri-prefixes"><a class="header" href="#compactiriiri-prefixes"><code>compactIRI(iri, prefixes)</code></a></h3>
<p>Compact an IRI to prefixed form.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>iri</code> (string): Full IRI (required)</li>
<li><code>prefixes</code> (Object): Prefix mappings (required)</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Prefixed URI or original IRI</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { compactIRI } from 'unrdf/utils';

const prefixes = {
  ex: 'http://example.org/',
  foaf: 'http://xmlns.com/foaf/0.1/'
};

const compacted = compactIRI('http://example.org/alice', prefixes);
console.log(compacted); // "ex:alice"
</code></pre>
<hr />
<h3 id="loadprefixesformat"><a class="header" href="#loadprefixesformat"><code>loadPrefixes(format)</code></a></h3>
<p>Load common prefix mappings.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>format</code> (string, optional): Format ('rdf', 'rdfs', 'owl', 'foaf', 'schema', 'all')</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Prefix mappings</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { loadPrefixes } from 'unrdf/utils';

// Load all common prefixes
const prefixes = loadPrefixes('all');

// Load specific ontology
const rdfPrefixes = loadPrefixes('rdf');
</code></pre>
<hr />
<h2 id="error-handling-12"><a class="header" href="#error-handling-12">Error Handling</a></h2>
<h3 id="isrdferrorerror"><a class="header" href="#isrdferrorerror"><code>isRDFError(error)</code></a></h3>
<p>Check if an error is an RDF-specific error.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>error</code> (Error): Error to check (required)</li>
</ul>
<p><strong>Returns:</strong> <code>boolean</code> - True if RDF error</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { isRDFError } from 'unrdf/utils';

try {
  parseTurtle('invalid turtle');
} catch (error) {
  if (isRDFError(error)) {
    console.error('RDF Error:', error.message);
  }
}
</code></pre>
<hr />
<h3 id="formaterrorerror-options"><a class="header" href="#formaterrorerror-options"><code>formatError(error, options)</code></a></h3>
<p>Format an error for display.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>error</code> (Error): Error to format (required)</li>
<li><code>options</code> (Object, optional): Format options
<ul>
<li><code>verbose</code> (boolean): Include stack trace</li>
<li><code>color</code> (boolean): Use ANSI colors</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Formatted error message</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { formatError } from 'unrdf/utils';

try {
  // Some operation
} catch (error) {
  console.error(formatError(error, { verbose: true, color: true }));
}
</code></pre>
<hr />
<h2 id="debugging-utilities"><a class="header" href="#debugging-utilities">Debugging Utilities</a></h2>
<h3 id="inspectquadquad-options"><a class="header" href="#inspectquadquad-options"><code>inspectQuad(quad, options)</code></a></h3>
<p>Inspect a quad with detailed information.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>quad</code> (Quad): Quad to inspect (required)</li>
<li><code>options</code> (Object, optional): Inspect options
<ul>
<li><code>depth</code> (number): Inspection depth</li>
<li><code>colors</code> (boolean): Use colors</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Formatted quad information</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { inspectQuad } from 'unrdf/utils';

const q = quad(alice, knows, bob);
console.log(inspectQuad(q, { colors: true }));
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Quad {
  subject: NamedNode { value: 'http://example.org/alice' },
  predicate: NamedNode { value: 'http://xmlns.com/foaf/0.1/knows' },
  object: NamedNode { value: 'http://example.org/bob' },
  graph: DefaultGraph {}
}
</code></pre>
<hr />
<h3 id="inspectstorestore-options"><a class="header" href="#inspectstorestore-options"><code>inspectStore(store, options)</code></a></h3>
<p>Inspect a store with statistics and sample quads.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store</code> (Store): Store to inspect (required)</li>
<li><code>options</code> (Object, optional): Inspect options
<ul>
<li><code>sampleSize</code> (number): Number of sample quads to show. Default: 5</li>
<li><code>showStats</code> (boolean): Show statistics. Default: true</li>
</ul>
</li>
</ul>
<p><strong>Returns:</strong> <code>string</code> - Formatted store information</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { inspectStore } from 'unrdf/utils';

console.log(inspectStore(store, { sampleSize: 10 }));
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>Store {
  size: 1,234 quads
  subjects: 234
  predicates: 12
  objects: 456
  graphs: 3

  Sample quads:
    1. ex:alice foaf:knows ex:bob
    2. ex:bob foaf:name "Bob"
    ...
}
</code></pre>
<hr />
<h3 id="diffstoresstore1-store2"><a class="header" href="#diffstoresstore1-store2"><code>diffStores(store1, store2)</code></a></h3>
<p>Compare two stores and show differences.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>store1</code> (Store): First store (required)</li>
<li><code>store2</code> (Store): Second store (required)</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Difference information</p>
<ul>
<li><code>added</code> (Store): Quads in store2 but not store1</li>
<li><code>removed</code> (Store): Quads in store1 but not store2</li>
<li><code>common</code> (Store): Quads in both stores</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { diffStores } from 'unrdf/utils';

const diff = diffStores(store1, store2);

console.log('Added:', diff.added.size);
console.log('Removed:', diff.removed.size);
console.log('Common:', diff.common.size);
</code></pre>
<hr />
<h2 id="performance-utilities"><a class="header" href="#performance-utilities">Performance Utilities</a></h2>
<h3 id="measureoperationfn-label"><a class="header" href="#measureoperationfn-label"><code>measureOperation(fn, label)</code></a></h3>
<p>Measure the execution time of an operation.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>fn</code> (Function): Function to measure (required)</li>
<li><code>label</code> (string, optional): Label for the operation</li>
</ul>
<p><strong>Returns:</strong> <code>Promise&lt;Object&gt;</code> - Result and timing</p>
<ul>
<li><code>result</code> (any): Function result</li>
<li><code>duration</code> (number): Duration in milliseconds</li>
</ul>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { measureOperation } from 'unrdf/utils';

const { result, duration } = await measureOperation(
  async () =&gt; {
    return parseTurtle(largeTurtleData);
  },
  'Parse large Turtle file'
);

console.log(`Parsed in ${duration}ms`);
</code></pre>
<hr />
<h3 id="benchmarkoperations-iterations"><a class="header" href="#benchmarkoperations-iterations"><code>benchmark(operations, iterations)</code></a></h3>
<p>Benchmark multiple operations.</p>
<p><strong>Parameters:</strong></p>
<ul>
<li><code>operations</code> (Object): Operations to benchmark <code>{ name: function }</code> (required)</li>
<li><code>iterations</code> (number, optional): Number of iterations. Default: 100</li>
</ul>
<p><strong>Returns:</strong> <code>Object</code> - Benchmark results</p>
<p><strong>Example:</strong></p>
<pre><code class="language-javascript">import { benchmark } from 'unrdf/utils';

const results = await benchmark({
  'Parse Turtle': () =&gt; parseTurtle(ttlData),
  'Parse N-Quads': () =&gt; parseNQuads(nquadData),
  'Serialize Turtle': () =&gt; serializeTurtle(store)
}, 1000);

console.table(results);
</code></pre>
<p><strong>Output:</strong></p>
<pre><code>‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ Operation         ‚îÇ Average  ‚îÇ Min      ‚îÇ Max      ‚îÇ
‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
‚îÇ Parse Turtle      ‚îÇ 12.3ms   ‚îÇ 10.1ms   ‚îÇ 15.2ms   ‚îÇ
‚îÇ Parse N-Quads     ‚îÇ 8.7ms    ‚îÇ 7.2ms    ‚îÇ 11.3ms   ‚îÇ
‚îÇ Serialize Turtle  ‚îÇ 15.4ms   ‚îÇ 13.8ms   ‚îÇ 18.9ms   ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
</code></pre>
<hr />
<h2 id="best-practices-17"><a class="header" href="#best-practices-17">Best Practices</a></h2>
<h3 id="error-handling-pattern"><a class="header" href="#error-handling-pattern">Error Handling Pattern</a></h3>
<pre><code class="language-javascript">import { parseTurtle, isRDFError, formatError } from 'unrdf/utils';

try {
  const store = parseTurtle(turtleData);
} catch (error) {
  if (isRDFError(error)) {
    console.error('RDF parsing failed:', formatError(error));
  } else {
    console.error('Unexpected error:', error.message);
  }
}
</code></pre>
<h3 id="validation-pattern"><a class="header" href="#validation-pattern">Validation Pattern</a></h3>
<pre><code class="language-javascript">import { validateStore, validateQuad } from 'unrdf/utils';

// Validate before operations
const storeValidation = validateStore(store);
if (!storeValidation.valid) {
  throw new Error(`Invalid store: ${storeValidation.errors.join(', ')}`);
}

// Validate individual quads
for (const quad of quads) {
  const quadValidation = validateQuad(quad);
  if (!quadValidation.valid) {
    console.warn(`Skipping invalid quad: ${quadValidation.errors.join(', ')}`);
  }
}
</code></pre>
<h3 id="performance-monitoring"><a class="header" href="#performance-monitoring">Performance Monitoring</a></h3>
<pre><code class="language-javascript">import { measureOperation, benchmark } from 'unrdf/utils';

// Measure critical operations
const { result, duration } = await measureOperation(
  () =&gt; complexOperation(),
  'Complex Operation'
);

if (duration &gt; 1000) {
  console.warn(`Operation took ${duration}ms - consider optimization`);
}

// Benchmark alternatives
const results = await benchmark({
  'Approach A': () =&gt; approachA(),
  'Approach B': () =&gt; approachB()
});
</code></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>

        <!-- Livereload script (if served using the cli tool) -->
        <script>
            const wsProtocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsAddress = wsProtocol + "//" + location.host + "/" + "__livereload";
            const socket = new WebSocket(wsAddress);
            socket.onmessage = function (event) {
                if (event.data === "reload") {
                    socket.close();
                    location.reload();
                }
            };

            window.onbeforeunload = function() {
                socket.close();
            }
        </script>


        <script>
            window.playground_line_numbers = true;
        </script>

        <script>
            window.playground_copyable = true;
        </script>

        <script src="ace.js"></script>
        <script src="editor.js"></script>
        <script src="mode-rust.js"></script>
        <script src="theme-dawn.js"></script>
        <script src="theme-tomorrow_night.js"></script>

        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
