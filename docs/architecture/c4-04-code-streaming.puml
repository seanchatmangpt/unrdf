@startuml UNRDF Streaming - Code Level
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

LAYOUT_WITH_LEGEND()

title @unrdf/streaming - C4 Code Level (Event-driven pub/sub, change feeds, sync protocol)

Package("Change Feed - EventTarget Pattern") {
  Component(change_feed_class, "class ChangeFeed extends EventTarget", "Core Class", "constructor(store?: UnrdfStore)\n\nüì° CORE METHODS\nsubscribe(callback: (change: ChangeEvent) => void):\n  () => void\n  ‚Üí Returns unsubscribe function\n  ‚Üí Registered in WeakMap\n  ‚Üí Automatic cleanup on GC\n\nemit(event: CustomEvent): void\n  ‚Üí Dispatch CustomEvent('change')\n  ‚Üí Notifies all subscribers\n  ‚Üí detail: {type, quad, timestamp, metadata}\n\ngetHistory(options?: {\n  since?: number (timestamp)\n  until?: number\n  limit?: number\n}): ChangeEvent[]\n  ‚Üí Returns bounded history from ring buffer\n  ‚Üí Ring buffer: Fixed size (config)\n  ‚Üí Circular: Oldest discarded first\n\nreplay(callback: (event) => void):\n  Promise<void>\n  ‚Üí Synchronous replay of history\n  ‚Üí Triggers callback for each event\n  ‚Üí Used for recovery/sync\n\nclear(): void\n  ‚Üí Empties history\n  ‚Üí Closes all subscribers\n\n‚öôÔ∏è INTERNAL STATE\n- subscribers: WeakMap<object, callback>\n- history: RingBuffer<ChangeEvent>\n- version: number (correlation ID)\n\n‚öôÔ∏è EVENTS\nCustomEvent('change', {\n  detail: {\n    type: 'add'|'remove'|'update'\n    quad: Quad (full RDF quad)\n    timestamp: number (ms since epoch)\n    metadata: {\n      source: string (caller ID)\n      userId: string (optional)\n      transactionId: string (optional)\n      batchId: string (correlation)\n    }\n  }\n})")
}

Package("Stream Processor - Chainable Operations") {
  Component(stream_processor_class, "class StreamProcessor", "Chainable Class", "constructor(feed: ChangeFeed)\n\n‚õìÔ∏è CHAINABLE OPERATIONS (fluent API)\nbatch(size: number | {size, windowMs?}):\n  StreamProcessor\n  ‚Üí Groups changes into batches\n  ‚Üí Size: number of changes or window in ms\n  ‚Üí Returns new StreamProcessor\n  ‚Üí Can chain: .batch(100).filter(...).map(...)\n\nfilter(predicate: (change) => boolean):\n  StreamProcessor\n  ‚Üí Filters changes by condition\n  ‚Üí Skips non-matching changes\n  ‚Üí Can chain with other operations\n\nmap(transformer: (change) => ChangeEvent):\n  StreamProcessor\n  ‚Üí Transforms each change\n  ‚Üí Maps to modified change\n  ‚Üí Useful for normalization\n\ndebounce(ms: number): StreamProcessor\n  ‚Üí Delays emission\n  ‚Üí Waits for more changes\n  ‚Üí Emits after silence\n  ‚Üí De-duplicates rapid fires\n\nthrottle(ms: number): StreamProcessor\n  ‚Üí Rate limiting\n  ‚Üí Max 1 emission per ms\n  ‚Üí Smooths bursty input\n\nüìå TERMINAL OPERATIONS\nsubscribe(callback): () => void\n  ‚Üí Terminal operation\n  ‚Üí Returns unsubscribe\n  ‚Üí Starts receiving events\n\nbuild(): Observable\n  ‚Üí Returns RxJS-like observable\n  ‚Üí Lazy subscription\n  ‚Üí Chainable further\n\n‚öôÔ∏è INTERNAL STATE\n- feed: ChangeFeed (source)\n- operations: Operation[] (pipeline)\n- subscribers: Set<callback>\n- state: {batched, filtered, mapped}")
}

Package("Sync Protocol - Message Encoding/Decoding") {
  Component(sync_msg_fn, "createSyncMessage(changes: ChangeEvent[])", "Factory Function", "export function createSyncMessage(\n  changes: ChangeEvent[],\n  options?: SyncOptions\n): SyncMessage\n\noptions: {\n  compress?: boolean (gzip)\n  includeMetadata?: boolean\n  expiry?: number (seconds)\n  algorithm?: 'SHA-256'|'SHA-256-256'|'BLAKE3'\n}\n\nFlow:\n1. Serialize changes to JSON\n2. Compute checksum hash\n3. Add timestamp\n4. Add metadata\n5. Return SyncMessage\n\nReturns: SyncMessage {\n  version: '1.0' (protocol version)\n  changes: ChangeEvent[] (serialized)\n  checksum: string (hex SHA-256)\n  timestamp: number (ms)\n  metadata?: {...}\n  expiry?: number (TTL)\n}\n\nSerialization:\n‚Ä¢ Compact JSON format\n‚Ä¢ Quad normalization\n‚Ä¢ Type preservation\n‚Ä¢ Null/undefined safe")

  Component(parse_msg_fn, "parseSyncMessage(message: SyncMessage)", "Factory Function", "export async function parseSyncMessage(\n  message: SyncMessage\n): Promise<ParsedMessage>\n\nValidation:\n1. Check version ('1.0')\n2. Verify checksum\n   ‚Üí SHA-256(message.changes)\n   ‚Üí Compare with message.checksum\n   ‚Üí Throw if mismatch\n3. Check expiry\n   ‚Üí now > (timestamp + expiry)\n   ‚Üí Throw if expired\n4. Deserialize changes\n5. Return validated payload\n\nReturns: ParsedMessage {\n  changes: ChangeEvent[] (validated)\n  metadata: {...}\n  valid: boolean\n  checksum: string\n  age: number (ms)\n}\n\nErrors:\n‚Ä¢ INVALID_CHECKSUM ‚Üí Message corrupted\n‚Ä¢ EXPIRED ‚Üí Too old\n‚Ä¢ INVALID_FORMAT ‚Üí Parsing error\n‚Ä¢ UNSUPPORTED_VERSION ‚Üí Protocol mismatch")

  Component(checksum_mod, "Checksum Module", "Hashing", "export function computeChecksum(\n  data: any,\n  algorithm: 'SHA-256'|...\n): string\n  ‚Üí Hashes data to hex string\n  ‚Üí Deterministic\n  ‚Üí Error detection\n\nexport function verifyChecksum(\n  data: any,\n  checksum: string,\n  algorithm: string\n): boolean\n  ‚Üí Compares computed vs provided\n  ‚Üí Returns true if match\n  ‚Üí False if mismatch")

  Component(msg_format, "Message Format", "Interface", "interface SyncMessage {\n  version: '1.0'\n  changes: {\n    type: 'add'|'remove'|'update'\n    quad: {\n      subject: string|{type, value}\n      predicate: string|{type, value}\n      object: string|{type, value, language?, datatype?}\n      graph: string|{type, value}\n    }\n    timestamp: number\n    metadata: {source, userId?, transactionId?}\n  }[]\n  checksum: string (hex)\n  timestamp: number (ms)\n  metadata?: {\n    source: string\n    peerId?: string\n    batchId?: string\n    compression?: string\n  }\n  expiry?: number (seconds, max 24h)\n}\n\nSize:\n‚Ä¢ Typical: 500B - 5KB\n‚Ä¢ With compression: 50% reduction\n‚Ä¢ Max batch: ~1MB (configurable)")
}

Package("Subscription Management") {
  Component(sub_mgr_class, "class SubscriptionManager", "Manager Class", "private subscribers: Map<string, Subscription>\nprivate idCounter: number\n\nadd(callback, filter?, metadata?):\n  string (subscription ID)\n  ‚Üí Generates unique ID\n  ‚Üí Stores subscription\n  ‚Üí Returns ID for unsubscribe\n\nremove(id: string): boolean\n  ‚Üí Unsubscribes\n  ‚Üí Cleans up resources\n  ‚Üí Returns true if existed\n\nbroadcast(change: ChangeEvent): void\n  ‚Üí Notifies all subscribers\n  ‚Üí Checks filter condition\n  ‚Üí Calls callback async\n  ‚Üí Error handling per subscriber\n\ngetSubscriberCount(): number\n  ‚Üí Returns active subscription count\n\nclear(): void\n  ‚Üí Removes all subscribers\n  ‚Üí Cleanup\n\n‚öôÔ∏è INTERNAL STATE\n- subscribers: Map<string, Subscription>\n- idCounter: number (for unique IDs)")
}

Package("History & Ring Buffer") {
  Component(history_mod, "History Manager", "Module", "export class RingBuffer<T> {\n  constructor(capacity: number)\n\n  push(item: T): void\n    ‚Üí Adds item\n    ‚Üí Overwrites oldest if full\n    ‚Üí O(1) insertion\n\n  getAll(): T[]\n    ‚Üí Returns all items (oldest ‚Üí newest)\n\n  slice(start, end): T[]\n    ‚Üí Returns subsequence\n    ‚Üí Efficient via circular indexing\n\n  getStats(): {\n    count: number\n    capacity: number\n    oldestTimestamp: number\n    newestTimestamp: number\n  }\n}\n\nUsage:\nring = new RingBuffer(10000)\nring.push(changeEvent) ‚Üí O(1)\nring.getAll() ‚Üí O(n), n = 10000 max")

  Component(replay, "Replay Function", "Module", "export async function replay(\n  history: ChangeEvent[],\n  callback: (event) => Promise<void>\n): Promise<void>\n\n1. Iterate history (oldest ‚Üí newest)\n2. Call callback(event)\n3. Await completion\n4. Continue to next\n5. Handle errors\n\nUsage:\n‚Ä¢ Recovery: Replay missed changes\n‚Ä¢ Sync: Catch up new peer\n‚Ä¢ Debug: Re-run scenarios")
}

Package("Transport Layer") {
  Component(transport_abstract, "Transport Abstraction", "Module", "export interface Transport {\n  send(message: SyncMessage):\n    Promise<void>\n  on(event: 'message'|'error'|'closed',\n     handler): unsubscribe\n  close(): Promise<void>\n  isConnected(): boolean\n}\n\nImplementations:\n‚Ä¢ WebSocket (ws npm)\n‚Ä¢ Server-Sent Events (EventSource)\n‚Ä¢ HTTP polling\n‚Ä¢ Custom (user-defined)")

  Component(websocket_impl, "WebSocket Adapter", "Implementation", "export class WebSocketTransport\n  implements Transport\n\nconstructor(url: string, options?)\n\nsend(message: SyncMessage):\n  Promise<void>\n  ‚Üí JSON.stringify(message)\n  ‚Üí ws.send(buffer)\n  ‚Üí Error handling\n  ‚Üí Reconnect on failure\n\non(event, handler): unsubscribe\n  ‚Üí 'message': Receive SyncMessage\n  ‚Üí 'error': Connection error\n  ‚Üí 'closed': Disconnected\n  ‚Üí 'connected': Established\n\nclose(): Promise<void>\n  ‚Üí Close ws connection\n  ‚Üí Cleanup\n\nisConnected(): boolean\n  ‚Üí ws.readyState === OPEN\n\nOptions:\n  url: string\n  reconnect?: boolean\n  reconnectDelay?: number (ms)\n  heartbeat?: number (ms)\n  maxRetries?: number")
}

' Relationships
Rel(change_feed_class, stream_processor_class, "consumed by")
Rel(stream_processor_class, change_feed_class, "subscribes to")
Rel(sync_msg_fn, checksum_mod, "uses")
Rel(parse_msg_fn, checksum_mod, "uses")
Rel(change_feed_class, history_mod, "uses RingBuffer")
Rel(history_mod, replay, "enables")
Rel(change_feed_class, sub_mgr_class, "uses")
Rel(websocket_impl, transport_abstract, "implements")

note right of change_feed_class
  **EVENT-DRIVEN ARCHITECTURE**

  Extends browser EventTarget
  Compatible with DOM events API

  Stores full change history
  Ring buffer: bounded memory
  Subscribers: WeakMap for GC

  Metadata: Correlation tracking
  Batch ID: Group related changes
  Transaction ID: ACID tracking
end note

note right of stream_processor_class
  **FUNCTIONAL COMPOSITION**

  Chainable stream operations
  Similar to RxJS/reactive patterns

  Each operation creates wrapper
  Late subscription: no pre-processing
  Lazy evaluation

  Batch: Time or size window
  Filter: Predicate-based
  Map: Transformation
  Debounce: De-duplication
end note

note right of sync_msg_fn
  **MESSAGE INTEGRITY**

  SHA-256 checksum on all messages
  Detects network corruption
  TTL (expiry) prevents replay

  Serialization: JSON format
  Quad normalization: Canonical form
  Compression: Optional gzip
  Size: Typically 500B-5KB
end note

note right of websocket_impl
  **REALTIME TRANSPORT**

  WebSocket for bidirectional
  Automatic reconnection
  Heartbeat monitoring
  Error recovery

  Message handling:
  ‚Üí Send: JSON.stringify
  ‚Üí Receive: Parse SyncMessage
  ‚Üí Error: Reconnect
end note

note bottom
  **STREAMING WORKFLOW**

  Store mutation
    ‚Üì
  emit('change') event
    ‚Üì
  ChangeEvent({type, quad, timestamp, metadata})
    ‚Üì
  Subscribers notified
    ‚Üì
  StreamProcessor chains:
    .batch(100)
    .filter(...)
    .debounce(100ms)
    ‚Üì
  createSyncMessage(changes)
    ‚Üì
  Compute SHA-256 checksum
    ‚Üì
  Send via WebSocket
    ‚Üì
  Peer receives SyncMessage
    ‚Üì
  parseSyncMessage()
    ‚Üí Verify checksum
    ‚Üí Check expiry
    ‚Üì
  Apply changes to peer store
    ‚Üì
  Peer emits own change events
    ‚Üì
  Replication complete
end note

SHOW_LEGEND()

@enduml
