@startuml UNRDF Federation - Code Level
!include https://raw.githubusercontent.com/plantuml-stdlib/C4-PlantUML/master/C4_Component.puml

LAYOUT_WITH_LEGEND()

title @unrdf/federation - C4 Code Level (Distributed queries, peer management, result aggregation)

Package("Core Coordinator") {
  Component(coordinator_class, "class Coordinator", "Main Class", "constructor(config: CoordinatorConfig) {\n  this.peers: Map<string, Peer>\n  this.metrics: Metrics\n  this.config: CoordinatorConfig\n  this.healthMonitor: HealthMonitor\n  this.queryRouter: QueryRouter\n}\n\nâœ¨ PEER MANAGEMENT\naddPeer(id: string, endpoint: string, metadata?):\n  void\n  â†’ Creates Peer object\n  â†’ Adds to registry\n  â†’ Starts health monitoring\n  â†’ Returns peer reference\n\nremovePeer(id: string): void\n  â†’ Removes from registry\n  â†’ Stops health monitoring\n  â†’ Cleans up connections\n\ngetPeer(id: string): Peer|null\n  â†’ Direct lookup\n  â†’ Fast O(1) access\n\ngetAllPeers(): Peer[]\n  â†’ Returns all registered peers\n  â†’ Sorted by status\n\ngetHealthyPeers(): Peer[]\n  â†’ Filters to status='healthy'\n  â†’ Ready for queries\n\nğŸ” QUERY EXECUTION\nquery(sparql: string, options?: QueryOptions):\n  Promise<AggregateResult>\n  â†’ Main entry point\n  â†’ Delegates to queryRouter\n  â†’ Executes on selected peers\n  â†’ Aggregates results\n  â†’ Returns combined answer\n\nqueryPeer(id: string, sparql: string):\n  Promise<PeerResult>\n  â†’ Query single peer\n  â†’ Direct execution\n  â†’ Error handling per peer\n\nğŸ’Š HEALTH MANAGEMENT\nstartHealthChecks(interval?: number):\n  Promise<void>\n  â†’ Interval: default 60s\n  â†’ Periodic ping to all peers\n  â†’ Updates peer status\n  â†’ Event emission on change\n\nstopHealthChecks(): void\n  â†’ Stops periodic monitoring\n  â†’ Cleans up timers\n\nğŸ“Š METRICS & MONITORING\ngetStats(): CoordinatorStats\n  â†’ queries: number (total)\n  â†’ errors: number\n  â†’ avgDuration: number (ms)\n  â†’ peersHealthy: number\n  â†’ peersDegraded: number\n  â†’ peersUnreachable: number\n\ngetPeerStats(id: string): PeerStats\n  â†’ queryCount: number\n  â†’ errorCount: number\n  â†’ avgLatency: number\n  â†’ lastQueryTime: Date\n  â†’ lastError?: Error")
}

Package("Peer Management & Health") {
  Component(peer_mgr_class, "class PeerManager", "Manager Class", "private peers: Map<string, Peer>\n\naddPeer(config: PeerConfig): Peer\n  â†’ Creates: {\n      id: string\n      endpoint: string (SPARQL URL)\n      metadata: {tags, capabilities, description}\n      status: 'healthy'|'degraded'|'unreachable'\n      latency: number (ms)\n      errorCount: number\n      lastPing: number (timestamp)\n    }\n  â†’ Returns Peer object\n\ngetPeer(id): Peer|null\n  â†’ Fast lookup via Map\n\nremovePeer(id): void\n  â†’ Deletes from registry\n  â†’ Triggers cleanup\n\nupdatePeerStatus(id, status): void\n  â†’ health: PeerHealth\n  â†’ latency: number\n  â†’ errorCount: number\n  â†’ Emits 'status_change' event")

  Component(health_checker, "class HealthChecker", "Monitor Class", "constructor(manager: PeerManager)\n\ncheck(peer: Peer):\n  Promise<PeerHealth>\n  â†’ Sends ASK query: 'ASK { ?s ?p ?o }'\n  â†’ Measures latency\n  â†’ Status determination:\n      latency < 100ms â†’ 'healthy'\n      latency >= 100ms â†’ 'degraded'\n      timeout/error â†’ 'unreachable'\n  â†’ Updates peer.status\n  â†’ Returns PeerHealth\n\ncheckAll(): Promise<Health[]>\n  â†’ Pings all peers in parallel\n  â†’ Promise.all([check(p1), check(p2), ...])\n  â†’ Aggregates results\n  â†’ Returns status for each peer\n\nmonitor(interval: number):\n  â†’ Periodic checks\n  â†’ setInterval(checkAll, interval)\n  â†’ Handles disconnects\n  â†’ Automatic peer removal (configurable)")

  Component(peer_model, "Peer Interface", "Type Definition", "interface Peer {\n  id: string (unique)\n  endpoint: string\n    (http(s)://host/sparql)\n  metadata: {\n    tags: string[] (categories)\n    capabilities: string[]\n      (e.g., 'SPARQL 1.1', 'Reasoning')\n    description: string\n    contact?: string (email/URL)\n  }\n  status: PeerStatus\n    ('healthy'|'degraded'|'unreachable')\n  health: {\n    latency: number (ms)\n    errorRate: number (0-100%)\n    uptime: number (percentage)\n    lastCheck: number (timestamp)\n  }\n  stats: {\n    queryCount: number\n    errorCount: number\n    avgDuration: number\n  }\n}")
}

Package("Query Routing & Execution") {
  Component(query_router, "class QueryRouter", "Routing Class", "selectPeers(strategy: string):\n  Peer[]\n  â†’ Strategies:\n      'broadcast': All healthy peers\n      'selective': Filter by metadata\n      'first-available': Stop at 1st success\n      'round-robin': Load balance\n  â†’ Returns sorted peer list\n\ngetExecutionPlan(query: string):\n  Peer[]\n  â†’ Analyzes SPARQL query\n  â†’ Predicts: SELECT|ASK|CONSTRUCT\n  â†’ Selects optimal peers\n  â†’ Ranks by latency\n  â†’ Returns ordered list\n\noptimizeQuery(query: string):\n  string\n  â†’ Query optimization:\n      pushFilters(): Reduce data transfer\n      pushProjection(): Select only needed\n      reorderPatterns(): Optimal order\n  â†’ Returns optimized SPARQL")

  Component(query_executor, "queryExecutor", "Module", "export async function executeQuery(\n  peers: Peer[],\n  sparql: string,\n  options?: ExecuteOptions\n): Promise<PeerResult[]>\n\nFlow:\n1. For each peer in parallel:\n   a. Construct endpoint URL\n   b. POST to {endpoint}/sparql\n   c. Send SPARQL query (URL-encoded)\n   d. Set timeout (default 30s)\n   e. Handle errors (retry 1x)\n2. Return results array\n\noptions: {\n  timeout: number (ms, default 30000)\n  retries: number (default 1)\n  headers?: {Authorization, Accept}\n  baseIri?: string\n}\n\nReturns: PeerResult[] = [\n  {\n    peerId: string\n    success: boolean\n    data?: Result (SPARQL result)\n    error?: Error\n    duration: number (ms)\n    status: number (HTTP)\n  }\n]")

  Component(sparql_post, "SPARQL Execution", "HTTP Module", "POST {endpoint}/sparql\n\nBody (application/x-www-form-urlencoded):\n  query={SPARQL}\n  &default-graph-uri={uri}\n  &named-graph-uri={uri}\n\nHeaders:\n  Accept: application/sparql-results+json\n       or application/rdf+xml\n       or text/turtle\n\nTimeout: AbortController\n  signal = timeout(ms)\n  fetch(..., {signal})\n  â†’ Automatic cancellation\n\nResult Formats:\n  SELECT: JSON [{bindings}]\n  ASK: JSON {boolean}\n  CONSTRUCT: RDF (Turtle/JSON-LD)\n  DESCRIBE: RDF")
}

Package("Result Aggregation") {
  Component(aggregator, "class ResultAggregator", "Aggregation Class", "aggregate(results: PeerResult[],\n          strategy: AggregationStrategy):\n  AggregateResult\n\nStrategies:\n  'UNION': All results + duplicates\n  'INTERSECT': Only common bindings\n  'MERGE': Union - duplicates\n\nFlow:\n1. Filter successful results\n2. Extract bindings from each\n3. Apply strategy:\n   UNION: [r1.bindings, r2.bindings, ...]\n   MERGE: Dedup + combine\n   INTERSECT: Common only\n4. Aggregate errors\n5. Return AggregateResult\n\nreturns: AggregateResult {\n  success: boolean\n  data: {\n    head: {vars: string[]}\n    bindings: {[var]: Term}[]\n  }\n  peersQueried: number\n  peersSuccess: number\n  peersFailure: number\n  duration: number (total ms)\n  errors: {peerId, error}[]\n  stats: {\n    resultCount: number\n    unionSize: number\n    intersectSize: number\n  }\n}")

  Component(dedup, "Deduplication", "Module", "export function deduplicateBindings(\n  bindings: Binding[]\n): Binding[]\n\nCompares binding objects\nRemoves identical results\n\nComparison:\nfor each variable:\n  term1.equals(term2)?\n  â†’ Use RDF.js equals()\n  â†’ Deep equality\n\nUsage:\n  â€¢ MERGE strategy\n  â€¢ Result consolidation\n  â€¢ Eliminates duplicates")
}

Package("Query Planning & Optimization") {
  Component(query_planner, "QueryPlanner", "Module", "analyzeQuery(sparql: string):\n  QueryAnalysis\n  â†’ Parses SPARQL\n  â†’ Counts triple patterns\n  â†’ Identifies filters\n  â†’ Detects graph patterns\n\nestimateResultSize(analysis):\n  number\n  â†’ Heuristic estimation\n  â†’ Based on patterns\n  â†’ Predicts data volume\n\nrecommendPeers(analysis, allPeers):\n  Peer[]\n  â†’ Selects peers based on:\n      query complexity\n      peer capabilities\n      latency\n  â†’ Returns ordered list")

  Component(optimizer, "QueryOptimizer", "Module", "pushFilters(sparql): string\n  â†’ Moves FILTER earlier\n  â†’ Reduces intermediate results\n  â†’ FILTER { ... } BEFORE patterns\n\npushProjection(sparql): string\n  â†’ Only SELECT needed vars\n  â†’ Reduces data transfer\n  â†’ Example: SELECT ?s vs SELECT *\n\nreorderTriplePatterns(sparql): string\n  â†’ Most selective first\n  â†’ Reduces join size\n  â†’ Better execution plan")
}

' Relationships
Rel(coordinator_class, peer_mgr_class, "delegates peer management to")
Rel(coordinator_class, query_router, "uses for routing")
Rel(coordinator_class, aggregator, "aggregates with")
Rel(peer_mgr_class, health_checker, "uses for monitoring")
Rel(query_router, query_executor, "executes via")
Rel(query_executor, sparql_post, "sends via HTTP")
Rel(aggregator, dedup, "uses")
Rel(query_router, query_planner, "consults")

note right of coordinator_class
  **FEDERATION ORCHESTRATOR**

  Central coordination point
  Manages peers: registry, health, metrics
  Routes queries: strategy-based selection
  Aggregates results: merge/union/intersect
  Monitors health: periodic pings
  Tracks metrics: throughput, errors, duration
end note

note right of health_checker
  **CONTINUOUS MONITORING**

  Heartbeat: SPARQL ASK query
  Interval: Configurable (60s default)
  Measurement: Latency + success/failure

  Status determination:
  â€¢ Latency < 100ms â†’ Healthy
  â€¢ Latency >= 100ms â†’ Degraded
  â€¢ Timeout/error â†’ Unreachable

  Automatic remediation:
  â€¢ Remove after N failures
  â€¢ Event emission on change
  â€¢ Metrics tracking
end note

note right of query_router
  **INTELLIGENT ROUTING**

  Broadcast: All healthy peers
  Selective: Filter by metadata (tags)
  First-available: Fail-over strategy
  Round-robin: Load balancing

  Optimization:
  â€¢ Query analysis
  â€¢ Peer capability matching
  â€¢ Latency-based ranking
end note

note right of aggregator
  **RESULT MERGING**

  UNION: All results combined
  INTERSECT: Common only
  MERGE: Deduplicated union

  Deduplication:
  â€¢ RDF.js equals() per term
  â€¢ Exact matching
  â€¢ No duplicates in result

  Error collection:
  â€¢ Tracks which peers failed
  â€¢ Error reasons
  â€¢ Partial success handling
end note

note bottom
  **DISTRIBUTED QUERY WORKFLOW**

  User query
    â†“
  Coordinator.query(sparql)
    â†“
  queryRouter.selectPeers(strategy)
    â†’ Pick peers to query
    â†“
  queryExecutor.execute(peers, sparql)
    â†’ Parallel HTTP POST to each
    â†“
  Each peer executes independently
    â†’ SPARQL engine runs
    â†’ Returns results
    â†“
  ResultAggregator.aggregate(results)
    â†’ Merge results
    â†’ Dedup if needed
    â†’ Collect errors
    â†“
  Return AggregateResult
    â†’ Combined answer
    â†’ Error info
    â†’ Metadata

  Example:
  SELECT ?s ?o { ?s rdf:type ?o }
  â†’ Query 3 peers in parallel
  â†’ Each returns 100 results
  â†’ Merge: Union = 300 (or fewer if duplicates)
  â†’ Metrics: 3 peers, 2 success, 1 failed, 250ms total
end note

SHOW_LEGEND()

@enduml
