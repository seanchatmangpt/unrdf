# UNRDF v3.1.0 Technical Architecture

**Version:** v3.1.0
**Status:** Design Phase
**Author:** System Architecture Team
**Date:** 2025-11-16

## Executive Summary

This document details the technical architecture for UNRDF v3.1.0, covering four major subsystems:

1. **Isolated-VM Sandbox Architecture** - Replace vm2 with isolated-vm for enhanced security
2. **Browser Compatibility Architecture** - Full browser support with ES2020+ features
3. **OTEL Validation Framework v3** - Enhanced validation to 90+/100 score
4. **Performance Profiling Architecture** - Built-in profiling without external dependencies

**Key Principles:**
- Zero breaking changes to public APIs
- Maintain backward compatibility with v3.0.x
- Progressive enhancement approach
- Runtime environment detection and adaptation

---

## 1. Isolated-VM Sandbox Architecture

### 1.1 Current State Analysis

**Current Implementation (vm2):**
```javascript
// src/security/sandbox-adapter.mjs
import { VM } from 'vm2';

export class SandboxAdapter {
  constructor(options = {}) {
    this.engine = 'vm2';
    this.vm = new VM({
      timeout: options.timeoutMs || 1000,
      sandbox: options.sandbox || {},
      eval: false,
      wasm: false,
    });
  }

  run(code) {
    return this.vm.run(code);
  }
}
```

**Known Issues:**
- vm2 is deprecated and has known security vulnerabilities
- Limited isolation compared to modern alternatives
- No async/await support without workarounds
- Performance overhead for frequent executions

### 1.2 Isolated-VM Architecture Design

#### 1.2.1 Component Architecture

```
┌─────────────────────────────────────────────────────────────┐
│                   Sandbox Adapter (Public API)               │
│  - Same interface as v3.0 (backward compatible)              │
│  - Auto-detects environment capabilities                     │
└─────────────────┬───────────────────────────────────────────┘
                  │
      ┌───────────┴───────────┐
      │                       │
┌─────▼──────┐       ┌───────▼────────┐
│ Isolated-VM│       │  Worker Thread │
│  Executor  │       │    Executor    │
│ (Node 18+) │       │   (Fallback)   │
└────────────┘       └────────────────┘
      │                       │
      └───────────┬───────────┘
                  │
      ┌───────────▼───────────┐
      │  VM2 Executor          │
      │  (Legacy Fallback)     │
      │  - Deprecated warning  │
      └────────────────────────┘
```

#### 1.2.2 Module Organization

```
src/security/
├── sandbox-adapter.mjs           # Public API (unchanged interface)
├── executors/
│   ├── isolated-vm-executor.mjs  # Isolated-VM implementation
│   ├── worker-executor.mjs       # Worker thread fallback
│   ├── vm2-executor.mjs          # Legacy fallback
│   └── browser-executor.mjs      # Browser-specific (Web Workers)
├── sandbox-detector.mjs          # Runtime capability detection
├── sandbox-context.mjs           # Context management
└── sandbox-restrictions.mjs      # Security policies (existing)
```

#### 1.2.3 Implementation Design

**Sandbox Adapter (Unchanged Public Interface):**
```javascript
/**
 * @file Enhanced Sandbox Adapter with isolated-vm
 * @module security/sandbox-adapter
 */
import { detectSandboxCapabilities } from './sandbox-detector.mjs';
import { IsolatedVMExecutor } from './executors/isolated-vm-executor.mjs';
import { WorkerExecutor } from './executors/worker-executor.mjs';
import { VM2Executor } from './executors/vm2-executor.mjs';

export class SandboxAdapter {
  constructor(options = {}) {
    // Detect best available sandbox engine
    const capabilities = detectSandboxCapabilities();

    // Select executor based on capabilities and preferences
    if (options.engine) {
      this.executor = this._createExecutor(options.engine, options);
    } else if (capabilities.isolatedVM) {
      this.executor = new IsolatedVMExecutor(options);
      this.engine = 'isolated-vm';
    } else if (capabilities.workerThreads) {
      this.executor = new WorkerExecutor(options);
      this.engine = 'worker';
    } else {
      // Fallback to vm2 with deprecation warning
      console.warn('[DEPRECATED] Using vm2. Please upgrade to Node 18+ for isolated-vm support');
      this.executor = new VM2Executor(options);
      this.engine = 'vm2';
    }
  }

  /**
   * Execute untrusted code (unchanged API)
   * @param {string} code
   * @returns {any}
   */
  run(code) {
    return this.executor.run(code);
  }

  /**
   * Async execution support (new in v3.1)
   * @param {string} code
   * @returns {Promise<any>}
   */
  async runAsync(code) {
    if (this.executor.runAsync) {
      return await this.executor.runAsync(code);
    }
    // Fallback to sync execution wrapped in Promise
    return Promise.resolve(this.run(code));
  }
}
```

**Isolated-VM Executor:**
```javascript
/**
 * @file Isolated-VM Executor Implementation
 * @module security/executors/isolated-vm-executor
 */
import ivm from 'isolated-vm';
import { z } from 'zod';

const IsolatedVMConfigSchema = z.object({
  memoryLimit: z.number().int().positive().default(128), // MB
  timeoutMs: z.number().int().positive().default(1000),
  allowAsync: z.boolean().default(true),
  sandbox: z.record(z.any()).default({}),
});

export class IsolatedVMExecutor {
  constructor(options = {}) {
    this.config = IsolatedVMConfigSchema.parse(options);
    this.isolate = new ivm.Isolate({ memoryLimit: this.config.memoryLimit });
    this.context = null;
    this._initialized = false;
  }

  async _initialize() {
    if (this._initialized) return;

    this.context = await this.isolate.createContext();

    // Transfer sandbox globals
    for (const [key, value] of Object.entries(this.config.sandbox)) {
      await this.context.global.set(key, new ivm.ExternalCopy(value).copyInto());
    }

    // Add safe built-ins
    await this.context.global.set('global', this.context.global.derefInto());

    this._initialized = true;
  }

  run(code) {
    // Synchronous execution
    if (!this._initialized) {
      throw new Error('Isolated-VM executor not initialized. Use runAsync() instead.');
    }

    const script = this.isolate.compileScriptSync(code);
    return script.runSync(this.context, {
      timeout: this.config.timeoutMs,
      reference: true
    });
  }

  async runAsync(code) {
    await this._initialize();

    const script = await this.isolate.compileScript(code);
    const result = await script.run(this.context, {
      timeout: this.config.timeoutMs,
      reference: true
    });

    // Copy result out of isolate
    if (result && typeof result.copy === 'function') {
      return await result.copy();
    }

    return result;
  }

  async dispose() {
    if (this.context) {
      this.context.release();
    }
    if (this.isolate) {
      this.isolate.dispose();
    }
  }
}
```

**Capability Detection:**
```javascript
/**
 * @file Sandbox Capability Detection
 * @module security/sandbox-detector
 */
import { isBrowser, isNode } from '../knowledge-engine/browser-shims.mjs';

export function detectSandboxCapabilities() {
  const capabilities = {
    isolatedVM: false,
    workerThreads: false,
    webWorkers: false,
    vm2: false,
    nodeVersion: null,
  };

  if (isBrowser) {
    capabilities.webWorkers = typeof Worker !== 'undefined';
    return capabilities;
  }

  if (isNode) {
    try {
      capabilities.nodeVersion = process.versions.node;
      const [major] = capabilities.nodeVersion.split('.').map(Number);

      // Check for isolated-vm support (Node 18+)
      if (major >= 18) {
        try {
          require.resolve('isolated-vm');
          capabilities.isolatedVM = true;
        } catch {}
      }

      // Check for worker_threads
      try {
        require.resolve('worker_threads');
        capabilities.workerThreads = true;
      } catch {}

      // Check for vm2
      try {
        require.resolve('vm2');
        capabilities.vm2 = true;
      } catch {}
    } catch {}
  }

  return capabilities;
}

export function getRecommendedExecutor() {
  const caps = detectSandboxCapabilities();

  if (caps.isolatedVM) return 'isolated-vm';
  if (caps.workerThreads) return 'worker';
  if (caps.webWorkers) return 'browser';
  if (caps.vm2) return 'vm2';

  throw new Error('No sandbox executor available. Install isolated-vm or upgrade Node to 18+');
}
```

### 1.3 Security Improvements

**Isolated-VM vs vm2 Security Comparison:**

| Feature | vm2 | isolated-vm | Improvement |
|---------|-----|-------------|-------------|
| Memory Isolation | Process-level | True V8 isolate | 100% memory isolation |
| CPU Limits | Timeout only | Memory + CPU limits | Prevents resource exhaustion |
| Async Support | Limited | Full async/await | Modern code support |
| Breakout Risk | Medium | Low | Separate V8 isolate |
| Maintenance | Deprecated | Active | Long-term security |

### 1.4 Performance Characteristics

**Benchmark Targets:**

```javascript
// Initialization overhead
isolated-vm: ~50ms (one-time per isolate)
worker: ~10ms (one-time per worker)
vm2: ~5ms (one-time per VM)

// Execution overhead (per call)
isolated-vm: ~0.1ms (small scripts)
worker: ~2ms (message passing overhead)
vm2: ~0.05ms (same process)

// Memory overhead
isolated-vm: 10MB base + script size
worker: 5MB base + script size
vm2: Minimal (same process)
```

**Performance Optimization Strategy:**
- Pool isolates for frequently-used hooks
- Reuse contexts for similar executions
- Batch small executions when possible
- Lazy initialization for first use

### 1.5 Backward Compatibility Strategy

**Phase 1: Soft Migration (v3.1.0)**
```javascript
// Default behavior: auto-detect and use best available
const adapter = new SandboxAdapter(); // Uses isolated-vm on Node 18+

// Explicit selection for testing/migration
const vm2Adapter = new SandboxAdapter({ engine: 'vm2' });
const isolatedAdapter = new SandboxAdapter({ engine: 'isolated-vm' });
```

**Phase 2: Deprecation Warnings (v3.2.0)**
```javascript
// Emit deprecation warnings when vm2 is used
if (this.engine === 'vm2') {
  console.warn('vm2 is deprecated. Upgrade to Node 18+ for isolated-vm');
}
```

**Phase 3: Remove vm2 (v4.0.0)**
```javascript
// vm2 support removed entirely
// Only isolated-vm and worker executors remain
```

### 1.6 Integration with Knowledge Hooks

**Hook Execution Context:**
```javascript
// src/knowledge-engine/effect-sandbox.mjs (updated)
import { SandboxAdapter } from '../security/sandbox-adapter.mjs';

export class EffectSandbox {
  constructor(config = {}) {
    // Use new sandbox adapter with isolated-vm
    this.sandboxAdapter = new SandboxAdapter({
      memoryLimit: config.memoryLimit || 64,
      timeoutMs: config.timeout || 30000,
      allowAsync: true,
      sandbox: this._createSandboxGlobals(config)
    });
  }

  async executeEffect(effect, context, options = {}) {
    const effectCode = this._createSafeEffect(effect, context);

    // Use async execution for isolated-vm
    return await this.sandboxAdapter.runAsync(effectCode);
  }
}
```

---

## 2. Browser Compatibility Architecture

### 2.1 Browser Environment Analysis

**Current Browser Support:**
- Basic browser bundle exists (browser.mjs)
- Memory-based file system shim
- Web Worker support for sandboxing
- Limited SPARQL engine support (Comunica browser bundle)

**Target Browser Support:**
- Chrome/Edge 90+ (ES2020+)
- Firefox 88+ (ES2020+)
- Safari 14+ (ES2020+)
- No IE11 support (ES2020 requirement)

### 2.2 Component Architecture

```
┌─────────────────────────────────────────────────────────────┐
│              UNRDF Core (Environment Agnostic)               │
│  - Knowledge Hooks API                                       │
│  - RDF Operations (parse, query, validate, reason)           │
│  - Policy Packs                                              │
└─────────────────┬───────────────────────────────────────────┘
                  │
      ┌───────────┴───────────┐
      │                       │
┌─────▼──────┐       ┌───────▼────────┐
│  Node.js   │       │    Browser     │
│  Runtime   │       │    Runtime     │
└────────────┘       └────────────────┘
      │                       │
      │                       │
┌─────▼──────┐       ┌───────▼────────┐
│ Native FS  │       │  IndexedDB FS  │
│ SPARQL Eng │       │  Comunica/Web  │
│ Worker Thr │       │  Web Workers   │
│ Isolated-VM│       │  (No isolate)  │
└────────────┘       └────────────────┘
```

### 2.3 Module Organization

```
src/
├── knowledge-engine/
│   ├── browser.mjs                    # Browser entry point
│   ├── browser-shims.mjs              # Environment detection
│   ├── storage/
│   │   ├── fs-adapter.mjs             # Unified FS interface
│   │   ├── node-fs.mjs                # Node.js implementation
│   │   └── indexeddb-fs.mjs           # Browser implementation
│   ├── query/
│   │   ├── query-adapter.mjs          # Unified query interface
│   │   ├── comunica-node.mjs          # Node.js SPARQL
│   │   └── comunica-browser.mjs       # Browser SPARQL
│   └── sandbox/
│       ├── sandbox-adapter.mjs        # Unified sandbox interface
│       ├── isolated-vm-executor.mjs   # Node.js sandbox
│       └── web-worker-executor.mjs    # Browser sandbox

dist/
├── unrdf.esm.mjs                      # ESM bundle (Node + Browser)
├── unrdf.browser.mjs                  # Browser-optimized bundle
└── unrdf.node.mjs                     # Node-optimized bundle
```

### 2.4 File System Abstraction

**Unified File System Interface:**
```javascript
/**
 * @file File System Adapter
 * @module storage/fs-adapter
 */
import { isBrowser } from '../browser-shims.mjs';

export class FileSystemAdapter {
  static async create(options = {}) {
    if (isBrowser) {
      const { IndexedDBFileSystem } = await import('./indexeddb-fs.mjs');
      return new IndexedDBFileSystem(options);
    } else {
      const { NodeFileSystem } = await import('./node-fs.mjs');
      return new NodeFileSystem(options);
    }
  }
}

// Common interface both implementations must follow
export class FileSystemInterface {
  async readFile(path, encoding = 'utf8') {}
  async writeFile(path, data, encoding = 'utf8') {}
  async exists(path) {}
  async mkdir(path, options = {}) {}
  async readdir(path) {}
  async unlink(path) {}
  async stat(path) {}
}
```

**IndexedDB File System Implementation:**
```javascript
/**
 * @file IndexedDB-based File System for Browser
 * @module storage/indexeddb-fs
 */
import { z } from 'zod';

const FileEntrySchema = z.object({
  path: z.string(),
  content: z.string(),
  encoding: z.string().default('utf8'),
  mtime: z.number(),
  size: z.number(),
  type: z.enum(['file', 'directory']),
});

export class IndexedDBFileSystem {
  constructor(options = {}) {
    this.dbName = options.dbName || 'unrdf-fs';
    this.storeName = 'files';
    this.db = null;
  }

  async _init() {
    if (this.db) return;

    return new Promise((resolve, reject) => {
      const request = indexedDB.open(this.dbName, 1);

      request.onerror = () => reject(request.error);
      request.onsuccess = () => {
        this.db = request.result;
        resolve();
      };

      request.onupgradeneeded = (event) => {
        const db = event.target.result;
        if (!db.objectStoreNames.contains(this.storeName)) {
          const store = db.createObjectStore(this.storeName, { keyPath: 'path' });
          store.createIndex('type', 'type', { unique: false });
          store.createIndex('mtime', 'mtime', { unique: false });
        }
      };
    });
  }

  async readFile(path, encoding = 'utf8') {
    await this._init();

    return new Promise((resolve, reject) => {
      const tx = this.db.transaction([this.storeName], 'readonly');
      const store = tx.objectStore(this.storeName);
      const request = store.get(path);

      request.onsuccess = () => {
        const entry = request.result;
        if (!entry) {
          reject(new Error(`ENOENT: no such file or directory, open '${path}'`));
        } else {
          resolve(encoding === 'utf8' ? entry.content : Buffer.from(entry.content, 'utf8'));
        }
      };

      request.onerror = () => reject(request.error);
    });
  }

  async writeFile(path, data, encoding = 'utf8') {
    await this._init();

    const content = encoding === 'utf8' ? data : data.toString();
    const entry = FileEntrySchema.parse({
      path,
      content,
      encoding,
      mtime: Date.now(),
      size: content.length,
      type: 'file',
    });

    return new Promise((resolve, reject) => {
      const tx = this.db.transaction([this.storeName], 'readwrite');
      const store = tx.objectStore(this.storeName);
      const request = store.put(entry);

      request.onsuccess = () => resolve();
      request.onerror = () => reject(request.error);
    });
  }

  async exists(path) {
    try {
      await this.readFile(path);
      return true;
    } catch {
      return false;
    }
  }

  async readdir(path) {
    await this._init();

    return new Promise((resolve, reject) => {
      const tx = this.db.transaction([this.storeName], 'readonly');
      const store = tx.objectStore(this.storeName);
      const request = store.getAll();

      request.onsuccess = () => {
        const files = request.result
          .filter(entry => entry.path.startsWith(path + '/'))
          .map(entry => entry.path.replace(path + '/', '').split('/')[0]);
        resolve([...new Set(files)]); // Deduplicate
      };

      request.onerror = () => reject(request.error);
    });
  }
}
```

### 2.5 ES2020+ Features Available in Browser

**Core Features (ES2020):**
- Optional chaining (`?.`)
- Nullish coalescing (`??`)
- Dynamic import (`import()`)
- BigInt
- Promise.allSettled
- globalThis
- String.prototype.matchAll

**Module Support:**
- Native ES modules (`<script type="module">`)
- Dynamic imports for code splitting
- Top-level await (in modules)

**Already Used in Codebase:**
```javascript
// Optional chaining (already used)
const value = context?.metadata?.key;

// Nullish coalescing (already used)
const timeout = options.timeout ?? 1000;

// Dynamic import (already used)
const { VM } = await import('vm2');

// ES modules (entire codebase)
export class KnowledgeEngine { }
```

### 2.6 Module Loading Strategy

**Build Configuration:**
```javascript
// build.config.mjs (enhanced)
export default {
  entries: [
    {
      input: 'src/index.mjs',
      output: 'dist/unrdf.node.mjs',
      target: 'node',
      externals: ['vm2', 'isolated-vm', 'n3', '@comunica/query-sparql']
    },
    {
      input: 'src/knowledge-engine/browser.mjs',
      output: 'dist/unrdf.browser.mjs',
      target: 'browser',
      format: 'esm',
      minify: true,
      bundle: {
        // Bundle browser-compatible dependencies
        include: ['zod', 'rdf-canonize'],
        // Don't bundle Node.js-only deps
        exclude: ['fs', 'path', 'worker_threads', 'isolated-vm']
      }
    },
    {
      input: 'src/index.mjs',
      output: 'dist/unrdf.esm.mjs',
      target: 'universal',
      format: 'esm',
      // Universal bundle with conditional imports
      conditions: ['browser', 'node', 'import']
    }
  ]
};
```

**Package.json Exports:**
```json
{
  "name": "unrdf",
  "type": "module",
  "exports": {
    ".": {
      "browser": "./dist/unrdf.browser.mjs",
      "node": "./dist/unrdf.node.mjs",
      "import": "./dist/unrdf.esm.mjs",
      "default": "./src/index.mjs"
    },
    "./browser": "./dist/unrdf.browser.mjs",
    "./node": "./dist/unrdf.node.mjs"
  },
  "browser": {
    "./src/security/sandbox-adapter.mjs": "./src/security/executors/browser-executor.mjs",
    "fs": false,
    "path": false,
    "worker_threads": false,
    "isolated-vm": false
  }
}
```

### 2.7 Service Worker Support

**Background Operations Design:**
```javascript
/**
 * @file Service Worker for Background Operations
 * @module browser/service-worker
 */

// Register service worker
if ('serviceWorker' in navigator) {
  navigator.serviceWorker.register('/unrdf-worker.js')
    .then(reg => console.log('UNRDF Service Worker registered'))
    .catch(err => console.error('Service Worker registration failed:', err));
}

// Service Worker implementation
self.addEventListener('message', async (event) => {
  const { type, payload } = event.data;

  switch (type) {
    case 'query':
      // Execute SPARQL query in background
      const result = await executeQuery(payload.query, payload.store);
      event.ports[0].postMessage({ type: 'result', data: result });
      break;

    case 'validate':
      // Execute SHACL validation in background
      const report = await validateStore(payload.store, payload.shapes);
      event.ports[0].postMessage({ type: 'result', data: report });
      break;

    case 'sync':
      // Sync local store to remote
      await syncStore(payload.localStore, payload.remoteUrl);
      event.ports[0].postMessage({ type: 'complete' });
      break;
  }
});
```

### 2.8 Browser Limitations Documentation

**Known Limitations:**
```markdown
# Browser Limitations

## File System
- No real file system access
- Uses IndexedDB for persistent storage
- Limited to browser storage quotas (~50MB-1GB depending on browser)
- No direct file path access (security restriction)

## Sandboxing
- Web Workers instead of isolated-vm
- Less strict isolation than Node.js isolates
- Cannot enforce memory limits as strictly

## Performance
- SPARQL queries may be slower (no native C++ bindings)
- Canonicalization slower (pure JS implementation)
- Limited parallelism compared to worker_threads

## Not Available in Browser
- File system operations (fs.readFile, fs.writeFile)
- Command-line interface (CLI)
- Native addons (isolated-vm, etc.)
- Process-level features (child_process, cluster)

## Workarounds
- Use fetch() API for remote file loading
- Use IndexedDB for persistent storage
- Use Web Workers for parallelism
- Use Service Workers for background operations
```

---

## 3. OTEL Validation Framework v3 Architecture

### 3.1 Current State Analysis

**Current Score: 81/100**

Score breakdown:
- Knowledge Engine: 30/100 (5 violations)
- CLI Parse: 20/100 (8 violations)
- CLI Query: 40/100 (6 violations)
- Transaction Manager: Pass
- CLI Validate: Pass
- CLI Hook: Pass

**Issues Identified:**
1. Legacy CLI validation checks (v2 CLI deprecated in favor of Knowledge Hooks API)
2. Missing v3.1 feature validations
3. Incomplete span attribute coverage
4. Performance threshold enforcement gaps

### 3.2 Target Architecture (90+/100)

**Score Target Allocation:**

| Feature | Current | Target | Priority |
|---------|---------|--------|----------|
| Knowledge Engine Core | 30 | 95 | Critical |
| Knowledge Hooks API | - | 95 | Critical |
| Policy Packs | - | 90 | High |
| Lockchain Integrity | - | 95 | Critical |
| Browser Compatibility | - | 85 | Medium |
| Transaction Manager | 90 | 95 | Medium |
| CLI (Legacy) | 20-40 | Remove | N/A |

**Overall Target: 92/100**

### 3.3 Validation Framework Architecture

```
┌─────────────────────────────────────────────────────────────┐
│           OTEL Validation Framework v3                       │
└─────────────────┬───────────────────────────────────────────┘
                  │
      ┌───────────┴───────────┐
      │                       │
┌─────▼──────┐       ┌───────▼────────┐
│  Feature   │       │  Performance   │
│ Validators │       │   Validators   │
└────────────┘       └────────────────┘
      │                       │
      └───────────┬───────────┘
                  │
      ┌───────────▼───────────┐
      │   Span Collector       │
      │   - In-memory spans    │
      │   - Span matching      │
      │   - Attribute extract  │
      └────────────────────────┘
                  │
      ┌───────────▼───────────┐
      │   Report Generator     │
      │   - Score calculation  │
      │   - Violation tracking │
      │   - JSON/HTML reports  │
      └────────────────────────┘
```

### 3.4 Module Organization

```
src/validation/
├── index.mjs                          # Public API
├── validation-runner.mjs              # Suite execution (existing)
├── otel-validator.mjs                 # Core validator (existing)
├── validation-helpers.mjs             # Helper utilities (existing)
├── features/
│   ├── knowledge-engine.validator.mjs # Core engine validation
│   ├── knowledge-hooks.validator.mjs  # Hooks API validation
│   ├── policy-packs.validator.mjs     # Policy pack validation
│   ├── lockchain.validator.mjs        # Lockchain integrity validation
│   ├── browser.validator.mjs          # Browser compat validation
│   └── transaction.validator.mjs      # Transaction validation
├── rules/
│   ├── span-rules.mjs                 # Span existence/structure rules
│   ├── attribute-rules.mjs            # Required attribute rules
│   ├── performance-rules.mjs          # Performance threshold rules
│   └── custom-rules.mjs               # Feature-specific rules
└── reporters/
    ├── json-reporter.mjs              # JSON report generation
    ├── html-reporter.mjs              # HTML dashboard
    └── console-reporter.mjs           # Console output (existing)

validation/
├── run-all.mjs                        # Entry point (existing)
├── otel-provider.mjs                  # OTEL setup (existing)
├── knowledge-engine.validation.mjs    # Updated for v3.1
└── knowledge-hooks.validation.mjs     # New for v3.1
```

### 3.5 Enhanced Validation Rules

**Knowledge Engine Core Validation:**
```javascript
/**
 * @file Knowledge Engine Validator
 * @module validation/features/knowledge-engine.validator
 */
export const knowledgeEngineValidation = {
  name: 'knowledge-engine-core',
  description: 'Core knowledge engine operations validation',

  config: {
    expectedSpans: [
      'parse.turtle',
      'parse.ntriples',
      'parse.jsonld',
      'query.sparql',
      'validate.shacl',
      'reason.n3',
      'canonicalize.urdna2015',
    ],

    requiredAttributes: [
      'service.name',            // Must be 'unrdf'
      'operation.type',          // parse|query|validate|reason|canonicalize
      'input.format',            // turtle|ntriples|jsonld|sparql
      'input.size',              // Bytes
      'output.size',             // Bytes
      'output.triples',          // Number of triples
      'duration.ms',             // Execution time
      'cache.hit',               // Cache hit/miss
    ],

    performanceThresholds: {
      'parse.turtle': {
        maxLatency: { p50: 10, p99: 100 },
        maxErrorRate: 0.01,
        minThroughput: 100,
      },
      'query.sparql': {
        maxLatency: { p50: 50, p99: 500 },
        maxErrorRate: 0.01,
        minThroughput: 10,
      },
      'validate.shacl': {
        maxLatency: { p50: 100, p99: 1000 },
        maxErrorRate: 0.01,
        minThroughput: 5,
      },
      'canonicalize.urdna2015': {
        maxLatency: { p50: 200, p99: 2000 },
        maxErrorRate: 0.01,
        minThroughput: 1,
      },
    },

    validationRules: [
      {
        name: 'span-attributes-complete',
        severity: 'error',
        condition: (span) => {
          const required = [
            'service.name',
            'operation.type',
            'input.format',
            'duration.ms'
          ];
          return required.every(attr => span.attributes[attr] !== undefined);
        },
        message: 'Span missing required attributes'
      },
      {
        name: 'cache-instrumentation',
        severity: 'warning',
        condition: (span) => {
          return span.attributes['cache.hit'] !== undefined;
        },
        message: 'Span missing cache instrumentation'
      },
      {
        name: 'error-handling-instrumented',
        severity: 'error',
        condition: (spans) => {
          // Check that error paths are instrumented
          const errorSpans = spans.filter(s => s.status?.code === 2);
          return errorSpans.every(s => s.attributes['error.type']);
        },
        message: 'Error spans missing error.type attribute'
      }
    ]
  }
};
```

**Knowledge Hooks API Validation:**
```javascript
/**
 * @file Knowledge Hooks Validator
 * @module validation/features/knowledge-hooks.validator
 */
export const knowledgeHooksValidation = {
  name: 'knowledge-hooks-api',
  description: 'Knowledge Hooks API validation',

  config: {
    expectedSpans: [
      'hook.register',
      'hook.evaluate',
      'hook.condition.check',
      'hook.effect.execute',
      'hook.lifecycle.before',
      'hook.lifecycle.after',
      'hook.sandbox.execute',
    ],

    requiredAttributes: [
      'hook.id',
      'hook.name',
      'hook.kind',               // before|after|validation|transformation
      'hook.event',              // The event that triggered the hook
      'hook.condition.result',   // true|false|error
      'hook.effect.result',      // success|error
      'hook.execution.time',     // µs
      'sandbox.engine',          // isolated-vm|worker|vm2
    ],

    performanceThresholds: {
      'hook.evaluate': {
        maxLatency: { p50: 0.2, p99: 2 },  // KGC PRD targets
        maxErrorRate: 0.01,
        minThroughput: 10000,              // 10k exec/min
      },
      'hook.sandbox.execute': {
        maxLatency: { p50: 1, p99: 10 },
        maxErrorRate: 0.00,                // 100% isolation
      },
    },

    validationRules: [
      {
        name: 'hook-lifecycle-complete',
        severity: 'error',
        condition: (spans) => {
          // Every hook.register must have corresponding evaluate
          const registered = spans.filter(s => s.name === 'hook.register');
          const evaluated = spans.filter(s => s.name === 'hook.evaluate');
          return registered.length > 0 && evaluated.length > 0;
        }
      },
      {
        name: 'sandbox-isolation-verified',
        severity: 'critical',
        condition: (spans) => {
          // All hook executions must be sandboxed
          const effects = spans.filter(s => s.name === 'hook.effect.execute');
          return effects.every(s => s.attributes['sandbox.engine']);
        }
      },
      {
        name: 'performance-kgc-prd-compliance',
        severity: 'error',
        condition: (spans) => {
          // Check KGC PRD p50 ≤ 200µs requirement
          const hookEvals = spans.filter(s => s.name === 'hook.evaluate');
          const latencies = hookEvals.map(s => s.attributes['hook.execution.time']);
          const p50 = calculatePercentile(latencies, 0.5);
          return p50 <= 200; // µs
        }
      }
    ]
  }
};
```

### 3.6 Legacy CLI Removal Strategy

**Validation Changes:**
```javascript
// validation/run-all.mjs (updated)
const comprehensiveSuite = {
  name: 'comprehensive',
  features: [
    // ✅ Keep: Core features
    knowledgeEngineValidation,
    knowledgeHooksValidation,
    policyPacksValidation,
    lockchainValidation,
    transactionValidation,

    // ✅ New: v3.1 features
    browserCompatValidation,
    isolatedVMValidation,

    // ❌ Remove: Legacy CLI checks (v2)
    // cliParseValidation,  // REMOVED
    // cliQueryValidation,  // REMOVED
    // cliValidateValidation, // REMOVED
    // cliHookValidation,   // REMOVED
  ]
};
```

**Migration Path:**
```markdown
# CLI Validation Migration

## v3.0.x (Current)
- CLI commands validated via OTEL spans
- Separate CLI validation suite

## v3.1.0 (Migration)
- CLI validation marked as deprecated
- Knowledge Hooks API becomes primary interface
- CLI validation score excluded from overall score

## v3.2.0 (Removal)
- CLI validation removed entirely
- Only Knowledge Hooks API validated
- CLI exists only as convenience wrapper (no validation)
```

### 3.7 Score Calculation Enhancement

**Weighted Scoring:**
```javascript
/**
 * Calculate weighted validation score
 */
function calculateWeightedScore(featureResults) {
  const weights = {
    'knowledge-engine-core': 0.30,    // 30% weight
    'knowledge-hooks-api': 0.30,      // 30% weight
    'policy-packs': 0.15,             // 15% weight
    'lockchain-integrity': 0.15,      // 15% weight
    'transaction-manager': 0.05,      // 5% weight
    'browser-compat': 0.05,           // 5% weight
  };

  let weightedScore = 0;
  let totalWeight = 0;

  for (const result of featureResults) {
    const weight = weights[result.feature] || 0;
    weightedScore += result.score * weight;
    totalWeight += weight;
  }

  return Math.round(weightedScore / totalWeight);
}
```

### 3.8 Target Achievement Plan

**Phase 1: Foundation (Week 1)**
- Implement new validation rules for knowledge-engine-core
- Add knowledge-hooks-api validation
- Remove legacy CLI validations

**Phase 2: Enhancement (Week 2)**
- Add policy-packs validation
- Add lockchain-integrity validation
- Implement weighted scoring

**Phase 3: Polish (Week 3)**
- Add browser-compat validation
- Performance threshold tuning
- HTML report dashboard

**Expected Progression:**
- Current: 81/100
- After Phase 1: 85/100
- After Phase 2: 90/100
- After Phase 3: 92/100

---

## 4. Performance Profiling Architecture

### 4.1 Current State Analysis

**Existing Performance Infrastructure:**
```javascript
// src/knowledge-engine/performance-optimizer.mjs
- Basic latency tracking (p50, p99)
- Hook execution rate monitoring
- Memory usage tracking
- Cache hit/miss statistics
- KGC PRD compliance checking
```

**Gaps:**
1. No built-in profiling dashboard
2. Limited CPU profiling
3. No flame graph generation
4. Manual metric collection
5. No real-time monitoring

### 4.2 Profiler Architecture Design

```
┌─────────────────────────────────────────────────────────────┐
│              Performance Profiler (Built-in)                 │
└─────────────────┬───────────────────────────────────────────┘
                  │
      ┌───────────┴───────────┬───────────────┐
      │                       │               │
┌─────▼──────┐       ┌───────▼────────┐  ┌──▼─────────┐
│   Latency  │       │   Memory       │  │    CPU     │
│  Profiler  │       │   Profiler     │  │  Profiler  │
└────────────┘       └────────────────┘  └────────────┘
      │                       │               │
      └───────────┬───────────┴───────────────┘
                  │
      ┌───────────▼───────────┐
      │   Metrics Collector    │
      │   - OTEL integration   │
      │   - Time-series data   │
      └────────────────────────┘
                  │
      ┌───────────▼───────────┐
      │   Report Generator     │
      │   - JSON export        │
      │   - HTML dashboard     │
      │   - Terminal UI        │
      └────────────────────────┘
```

### 4.3 Module Organization

```
src/knowledge-engine/profiling/
├── index.mjs                          # Public profiler API
├── latency-profiler.mjs               # Latency tracking
├── memory-profiler.mjs                # Memory analysis
├── cpu-profiler.mjs                   # CPU profiling (optional)
├── metrics-collector.mjs              # Centralized metrics
├── profiler-config.mjs                # Configuration
└── reporters/
    ├── json-reporter.mjs              # JSON export
    ├── html-reporter.mjs              # HTML dashboard
    └── terminal-reporter.mjs          # Terminal UI

examples/
└── profiling-demo.mjs                 # Usage examples
```

### 4.4 Latency Profiler Implementation

**Design:**
```javascript
/**
 * @file Latency Profiler
 * @module knowledge-engine/profiling/latency-profiler
 */
import { z } from 'zod';
import { trace } from '@opentelemetry/api';

const LatencyConfigSchema = z.object({
  percentiles: z.array(z.number()).default([0.5, 0.9, 0.95, 0.99, 0.999]),
  maxSamples: z.number().int().positive().default(10000),
  windowSizeMs: z.number().int().positive().default(60000), // 1 minute
  enableHistogram: z.boolean().default(true),
  bucketBoundaries: z.array(z.number()).default([1, 5, 10, 50, 100, 500, 1000, 5000]),
});

export class LatencyProfiler {
  constructor(config = {}) {
    this.config = LatencyConfigSchema.parse(config);
    this.samples = [];
    this.histogram = new Map();
    this.tracer = trace.getTracer('latency-profiler');

    // Initialize histogram buckets
    for (const boundary of this.config.bucketBoundaries) {
      this.histogram.set(boundary, 0);
    }
  }

  /**
   * Record a latency sample
   * @param {string} operation - Operation name
   * @param {number} latency - Latency in milliseconds
   * @param {Object} [metadata] - Additional metadata
   */
  record(operation, latency, metadata = {}) {
    const sample = {
      operation,
      latency,
      timestamp: Date.now(),
      metadata
    };

    this.samples.push(sample);

    // Update histogram
    if (this.config.enableHistogram) {
      this._updateHistogram(latency);
    }

    // Trim old samples
    this._trimSamples();

    // Record OTEL span
    this._recordSpan(operation, latency, metadata);
  }

  /**
   * Calculate percentiles for an operation
   * @param {string} [operation] - Operation name (all if omitted)
   * @returns {Object} Percentile values
   */
  getPercentiles(operation = null) {
    const samples = operation
      ? this.samples.filter(s => s.operation === operation)
      : this.samples;

    const latencies = samples.map(s => s.latency).sort((a, b) => a - b);

    if (latencies.length === 0) {
      return this.config.percentiles.reduce((acc, p) => {
        acc[`p${p * 100}`] = 0;
        return acc;
      }, {});
    }

    const percentiles = {};
    for (const p of this.config.percentiles) {
      const index = Math.ceil(latencies.length * p) - 1;
      percentiles[`p${p * 100}`] = latencies[Math.max(0, index)];
    }

    return percentiles;
  }

  /**
   * Get histogram data
   * @returns {Array} Histogram buckets
   */
  getHistogram() {
    return Array.from(this.histogram.entries()).map(([boundary, count]) => ({
      boundary,
      count,
      percentage: (count / this.samples.length) * 100
    }));
  }

  /**
   * Get latency statistics
   * @param {string} [operation] - Operation name
   * @returns {Object} Statistics
   */
  getStats(operation = null) {
    const samples = operation
      ? this.samples.filter(s => s.operation === operation)
      : this.samples;

    if (samples.length === 0) {
      return { count: 0, mean: 0, min: 0, max: 0, stddev: 0 };
    }

    const latencies = samples.map(s => s.latency);
    const mean = latencies.reduce((a, b) => a + b, 0) / latencies.length;
    const variance = latencies.reduce((acc, val) => acc + Math.pow(val - mean, 2), 0) / latencies.length;
    const stddev = Math.sqrt(variance);

    return {
      count: samples.length,
      mean,
      min: Math.min(...latencies),
      max: Math.max(...latencies),
      stddev,
      ...this.getPercentiles(operation)
    };
  }

  /**
   * Update histogram buckets
   * @private
   */
  _updateHistogram(latency) {
    const boundaries = [...this.config.bucketBoundaries].sort((a, b) => a - b);

    for (const boundary of boundaries) {
      if (latency <= boundary) {
        this.histogram.set(boundary, (this.histogram.get(boundary) || 0) + 1);
        return;
      }
    }

    // Greater than all boundaries
    const max = boundaries[boundaries.length - 1];
    this.histogram.set(max, (this.histogram.get(max) || 0) + 1);
  }

  /**
   * Trim old samples outside window
   * @private
   */
  _trimSamples() {
    const cutoff = Date.now() - this.config.windowSizeMs;
    this.samples = this.samples.filter(s => s.timestamp > cutoff);

    // Also enforce max samples limit
    if (this.samples.length > this.config.maxSamples) {
      this.samples = this.samples.slice(-this.config.maxSamples);
    }
  }

  /**
   * Record OTEL span
   * @private
   */
  _recordSpan(operation, latency, metadata) {
    this.tracer.startActiveSpan(`profiler.latency.${operation}`, span => {
      span.setAttributes({
        'profiler.type': 'latency',
        'profiler.operation': operation,
        'profiler.latency.ms': latency,
        ...metadata
      });
      span.end();
    });
  }

  /**
   * Reset profiler state
   */
  reset() {
    this.samples = [];
    this.histogram.clear();
    for (const boundary of this.config.bucketBoundaries) {
      this.histogram.set(boundary, 0);
    }
  }
}
```

### 4.5 Memory Profiler Implementation

**Design:**
```javascript
/**
 * @file Memory Profiler
 * @module knowledge-engine/profiling/memory-profiler
 */
import { isBrowser } from '../browser-shims.mjs';

export class MemoryProfiler {
  constructor(config = {}) {
    this.config = {
      sampleIntervalMs: 1000,
      maxSamples: 1000,
      enableHeapSnapshot: !isBrowser,
      ...config
    };

    this.samples = [];
    this.snapshots = [];
    this.intervalId = null;
  }

  /**
   * Start memory profiling
   */
  start() {
    if (this.intervalId) return;

    this.intervalId = setInterval(() => {
      this._takeSample();
    }, this.config.sampleIntervalMs);
  }

  /**
   * Stop memory profiling
   */
  stop() {
    if (this.intervalId) {
      clearInterval(this.intervalId);
      this.intervalId = null;
    }
  }

  /**
   * Take a memory sample
   * @private
   */
  _takeSample() {
    let sample;

    if (isBrowser) {
      // Browser: Use performance.memory (Chrome only)
      if (performance.memory) {
        sample = {
          timestamp: Date.now(),
          totalJSHeapSize: performance.memory.totalJSHeapSize,
          usedJSHeapSize: performance.memory.usedJSHeapSize,
          jsHeapSizeLimit: performance.memory.jsHeapSizeLimit,
        };
      }
    } else {
      // Node.js: Use process.memoryUsage()
      const mem = process.memoryUsage();
      sample = {
        timestamp: Date.now(),
        rss: mem.rss,
        heapTotal: mem.heapTotal,
        heapUsed: mem.heapUsed,
        external: mem.external,
        arrayBuffers: mem.arrayBuffers || 0,
      };
    }

    if (sample) {
      this.samples.push(sample);

      // Trim old samples
      if (this.samples.length > this.config.maxSamples) {
        this.samples = this.samples.slice(-this.config.maxSamples);
      }
    }
  }

  /**
   * Get memory statistics
   * @returns {Object} Memory stats
   */
  getStats() {
    if (this.samples.length === 0) {
      return { count: 0, current: {}, peak: {}, average: {} };
    }

    const current = this.samples[this.samples.length - 1];
    const fields = Object.keys(current).filter(k => k !== 'timestamp');

    const peak = {};
    const average = {};

    for (const field of fields) {
      const values = this.samples.map(s => s[field]);
      peak[field] = Math.max(...values);
      average[field] = values.reduce((a, b) => a + b, 0) / values.length;
    }

    return {
      count: this.samples.length,
      current,
      peak,
      average,
      trend: this._calculateTrend()
    };
  }

  /**
   * Calculate memory trend (growing/stable/declining)
   * @private
   */
  _calculateTrend() {
    if (this.samples.length < 10) return 'insufficient-data';

    const recent = this.samples.slice(-10);
    const field = isBrowser ? 'usedJSHeapSize' : 'heapUsed';

    const first = recent[0][field];
    const last = recent[recent.length - 1][field];

    const change = ((last - first) / first) * 100;

    if (change > 5) return 'growing';
    if (change < -5) return 'declining';
    return 'stable';
  }

  /**
   * Take heap snapshot (Node.js only)
   */
  takeHeapSnapshot() {
    if (isBrowser || !this.config.enableHeapSnapshot) {
      throw new Error('Heap snapshots not available in this environment');
    }

    const v8 = require('v8');
    const snapshot = v8.writeHeapSnapshot();

    this.snapshots.push({
      timestamp: Date.now(),
      path: snapshot
    });

    return snapshot;
  }

  /**
   * Reset profiler
   */
  reset() {
    this.stop();
    this.samples = [];
    this.snapshots = [];
  }
}
```

### 4.6 CPU Profiler (Optional - Node.js only)

**Design:**
```javascript
/**
 * @file CPU Profiler (Node.js only)
 * @module knowledge-engine/profiling/cpu-profiler
 */
export class CPUProfiler {
  constructor(config = {}) {
    this.config = {
      sampleIntervalMs: 10,
      ...config
    };

    this.profiling = false;
    this.profile = null;
  }

  /**
   * Start CPU profiling
   */
  start() {
    if (this.profiling) return;

    try {
      const inspector = require('inspector');
      const session = new inspector.Session();
      session.connect();

      session.post('Profiler.enable');
      session.post('Profiler.start');

      this.session = session;
      this.profiling = true;
    } catch (error) {
      console.warn('CPU profiling not available:', error.message);
    }
  }

  /**
   * Stop CPU profiling
   * @returns {Object} CPU profile
   */
  async stop() {
    if (!this.profiling) return null;

    return new Promise((resolve) => {
      this.session.post('Profiler.stop', (err, { profile }) => {
        this.session.post('Profiler.disable');
        this.session.disconnect();

        this.profiling = false;
        this.profile = profile;

        resolve(profile);
      });
    });
  }

  /**
   * Get hot functions (most CPU time)
   * @param {number} [topN=10] - Number of top functions to return
   * @returns {Array} Hot functions
   */
  getHotFunctions(topN = 10) {
    if (!this.profile) return [];

    const nodes = this.profile.nodes || [];
    const samples = this.profile.samples || [];

    // Count samples per node
    const sampleCounts = new Map();
    for (const sampleId of samples) {
      sampleCounts.set(sampleId, (sampleCounts.get(sampleId) || 0) + 1);
    }

    // Sort by sample count
    const sorted = Array.from(sampleCounts.entries())
      .sort((a, b) => b[1] - a[1])
      .slice(0, topN);

    return sorted.map(([nodeId, count]) => {
      const node = nodes[nodeId];
      return {
        functionName: node?.callFrame?.functionName || '(anonymous)',
        url: node?.callFrame?.url || '',
        lineNumber: node?.callFrame?.lineNumber || 0,
        sampleCount: count,
        percentage: (count / samples.length) * 100
      };
    });
  }
}
```

### 4.7 Unified Profiler API

**Public API:**
```javascript
/**
 * @file Performance Profiler API
 * @module knowledge-engine/profiling
 */
import { LatencyProfiler } from './latency-profiler.mjs';
import { MemoryProfiler } from './memory-profiler.mjs';
import { CPUProfiler } from './cpu-profiler.mjs';
import { MetricsCollector } from './metrics-collector.mjs';
import { isBrowser } from '../browser-shims.mjs';

export class PerformanceProfiler {
  constructor(config = {}) {
    this.config = {
      enableLatency: true,
      enableMemory: true,
      enableCPU: !isBrowser,
      ...config
    };

    this.latency = this.config.enableLatency ? new LatencyProfiler(config.latency) : null;
    this.memory = this.config.enableMemory ? new MemoryProfiler(config.memory) : null;
    this.cpu = this.config.enableCPU ? new CPUProfiler(config.cpu) : null;
    this.metrics = new MetricsCollector();
  }

  /**
   * Start profiling
   */
  start() {
    if (this.memory) this.memory.start();
    if (this.cpu) this.cpu.start();
  }

  /**
   * Stop profiling
   */
  async stop() {
    if (this.memory) this.memory.stop();
    if (this.cpu) return await this.cpu.stop();
  }

  /**
   * Profile a function execution
   * @param {string} name - Operation name
   * @param {Function} fn - Function to profile
   * @returns {any} Function result
   */
  async profile(name, fn) {
    const start = performance.now();

    try {
      const result = await fn();
      const duration = performance.now() - start;

      if (this.latency) {
        this.latency.record(name, duration, { success: true });
      }

      this.metrics.record(name, { duration, success: true });

      return result;
    } catch (error) {
      const duration = performance.now() - start;

      if (this.latency) {
        this.latency.record(name, duration, { success: false, error: error.message });
      }

      this.metrics.record(name, { duration, success: false, error: error.message });

      throw error;
    }
  }

  /**
   * Get comprehensive profiling report
   * @returns {Object} Profiling report
   */
  getReport() {
    return {
      latency: this.latency ? this.latency.getStats() : null,
      memory: this.memory ? this.memory.getStats() : null,
      cpu: this.cpu ? this.cpu.getHotFunctions() : null,
      metrics: this.metrics.getAll(),
      timestamp: new Date().toISOString()
    };
  }

  /**
   * Export report to JSON
   * @param {string} [filepath] - Output file path
   */
  async exportJSON(filepath) {
    const report = this.getReport();
    const json = JSON.stringify(report, null, 2);

    if (isBrowser) {
      // Download as file in browser
      const blob = new Blob([json], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = filepath || 'profiling-report.json';
      a.click();
    } else {
      // Write to file in Node.js
      const fs = await import('fs/promises');
      await fs.writeFile(filepath || 'profiling-report.json', json);
    }
  }

  /**
   * Generate HTML dashboard
   * @returns {string} HTML content
   */
  generateDashboard() {
    const report = this.getReport();

    return `
<!DOCTYPE html>
<html>
<head>
  <title>UNRDF Performance Profile</title>
  <style>
    body { font-family: system-ui; max-width: 1200px; margin: 0 auto; padding: 20px; }
    .metric { border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 5px; }
    .metric h3 { margin-top: 0; }
    table { width: 100%; border-collapse: collapse; }
    th, td { padding: 8px; text-align: left; border-bottom: 1px solid #ddd; }
    .warning { color: #ff9800; }
    .error { color: #f44336; }
    .success { color: #4caf50; }
  </style>
</head>
<body>
  <h1>UNRDF Performance Profile</h1>
  <p>Generated: ${report.timestamp}</p>

  <div class="metric">
    <h3>Latency Statistics</h3>
    ${this._renderLatencyTable(report.latency)}
  </div>

  <div class="metric">
    <h3>Memory Statistics</h3>
    ${this._renderMemoryTable(report.memory)}
  </div>

  ${report.cpu ? `
  <div class="metric">
    <h3>CPU Hot Functions</h3>
    ${this._renderCPUTable(report.cpu)}
  </div>
  ` : ''}
</body>
</html>
    `;
  }

  _renderLatencyTable(latency) {
    if (!latency) return '<p>No latency data</p>';

    return `
      <table>
        <tr>
          <th>Metric</th>
          <th>Value</th>
        </tr>
        <tr><td>Count</td><td>${latency.count}</td></tr>
        <tr><td>Mean</td><td>${latency.mean.toFixed(2)}ms</td></tr>
        <tr><td>Min</td><td>${latency.min.toFixed(2)}ms</td></tr>
        <tr><td>Max</td><td>${latency.max.toFixed(2)}ms</td></tr>
        <tr><td>p50</td><td>${latency.p50.toFixed(2)}ms</td></tr>
        <tr><td>p95</td><td>${latency.p95.toFixed(2)}ms</td></tr>
        <tr><td>p99</td><td>${latency.p99.toFixed(2)}ms</td></tr>
      </table>
    `;
  }

  _renderMemoryTable(memory) {
    if (!memory) return '<p>No memory data</p>';

    const formatBytes = (bytes) => {
      const mb = bytes / (1024 * 1024);
      return `${mb.toFixed(2)} MB`;
    };

    return `
      <table>
        <tr>
          <th>Metric</th>
          <th>Current</th>
          <th>Peak</th>
          <th>Average</th>
        </tr>
        ${Object.keys(memory.current).filter(k => k !== 'timestamp').map(key => `
          <tr>
            <td>${key}</td>
            <td>${formatBytes(memory.current[key])}</td>
            <td>${formatBytes(memory.peak[key])}</td>
            <td>${formatBytes(memory.average[key])}</td>
          </tr>
        `).join('')}
        <tr>
          <td><strong>Trend</strong></td>
          <td colspan="3" class="${memory.trend === 'growing' ? 'warning' : 'success'}">
            ${memory.trend}
          </td>
        </tr>
      </table>
    `;
  }

  _renderCPUTable(cpu) {
    if (!cpu || cpu.length === 0) return '<p>No CPU data</p>';

    return `
      <table>
        <tr>
          <th>Function</th>
          <th>Samples</th>
          <th>%</th>
        </tr>
        ${cpu.map(fn => `
          <tr>
            <td>${fn.functionName}</td>
            <td>${fn.sampleCount}</td>
            <td>${fn.percentage.toFixed(2)}%</td>
          </tr>
        `).join('')}
      </table>
    `;
  }
}

/**
 * Create a performance profiler
 * @param {Object} [config] - Configuration
 * @returns {PerformanceProfiler} Profiler instance
 */
export function createPerformanceProfiler(config = {}) {
  return new PerformanceProfiler(config);
}
```

### 4.8 Integration with OTEL

**OTEL Integration:**
```javascript
/**
 * Integrate profiler with OpenTelemetry
 */
import { trace, metrics } from '@opentelemetry/api';

export class MetricsCollector {
  constructor() {
    this.meter = metrics.getMeter('unrdf-profiler');

    // Create metrics
    this.latencyHistogram = this.meter.createHistogram('operation_latency_ms', {
      description: 'Operation latency in milliseconds',
      unit: 'ms'
    });

    this.memoryGauge = this.meter.createObservableGauge('memory_usage_bytes', {
      description: 'Memory usage in bytes',
      unit: 'bytes'
    });

    this.operationCounter = this.meter.createCounter('operations_total', {
      description: 'Total number of operations'
    });
  }

  record(operation, data) {
    // Record latency
    if (data.duration !== undefined) {
      this.latencyHistogram.record(data.duration, {
        operation,
        success: data.success ? 'true' : 'false'
      });
    }

    // Count operation
    this.operationCounter.add(1, {
      operation,
      success: data.success ? 'true' : 'false'
    });
  }
}
```

### 4.9 Usage Examples

**Example: Profile Knowledge Hook Execution:**
```javascript
import { createPerformanceProfiler } from 'unrdf/profiling';
import { KnowledgeEngine } from 'unrdf';

const profiler = createPerformanceProfiler({
  enableLatency: true,
  enableMemory: true,
  enableCPU: true
});

const engine = new KnowledgeEngine();

// Start profiling
profiler.start();

// Profile operations
await profiler.profile('parse', async () => {
  return await engine.parse(turtleData, { format: 'turtle' });
});

await profiler.profile('query', async () => {
  return await engine.query('SELECT * WHERE { ?s ?p ?o } LIMIT 100');
});

await profiler.profile('validate', async () => {
  return await engine.validate(shaclShapes);
});

// Stop profiling and get report
await profiler.stop();
const report = profiler.getReport();

console.log('Latency:', report.latency);
console.log('Memory:', report.memory);
console.log('CPU Hot Functions:', report.cpu);

// Export reports
await profiler.exportJSON('profile-report.json');
```

---

## 5. Deployment & Bundling Considerations

### 5.1 Package Exports Strategy

**package.json:**
```json
{
  "name": "unrdf",
  "version": "3.1.0",
  "type": "module",
  "exports": {
    ".": {
      "browser": "./dist/unrdf.browser.mjs",
      "node": "./dist/unrdf.node.mjs",
      "import": "./dist/unrdf.esm.mjs",
      "default": "./src/index.mjs"
    },
    "./profiling": {
      "browser": "./src/knowledge-engine/profiling/browser.mjs",
      "node": "./src/knowledge-engine/profiling/index.mjs",
      "import": "./src/knowledge-engine/profiling/index.mjs"
    },
    "./validation": {
      "import": "./src/validation/index.mjs"
    }
  }
}
```

### 5.2 Build Pipeline

**Build Steps:**
1. Transpile with obuild (ESM → ESM, no transpilation needed for ES2020+)
2. Bundle browser version (include browser-compatible deps)
3. Generate TypeScript declarations from JSDoc
4. Run OTEL validation
5. Generate performance baseline

**Build Command:**
```bash
pnpm run build
# → dist/unrdf.node.mjs (Node.js optimized)
# → dist/unrdf.browser.mjs (Browser bundle)
# → dist/unrdf.esm.mjs (Universal ESM)
# → dist/types/ (TypeScript declarations)
```

### 5.3 Tree-Shaking Considerations

**Ensure Tree-Shakability:**
```javascript
// ✅ Good: Named exports (tree-shakable)
export { KnowledgeEngine } from './knowledge-engine/index.mjs';
export { createPerformanceProfiler } from './profiling/index.mjs';

// ❌ Bad: Default export with everything
export default {
  KnowledgeEngine,
  createPerformanceProfiler,
  // ... everything bundled
};
```

---

## 6. Breaking Changes Analysis

### 6.1 Public API Compatibility

**No Breaking Changes:**
- `SandboxAdapter.run(code)` - Same signature, enhanced implementation
- `KnowledgeEngine` API - Unchanged
- `defineHook()` API - Unchanged
- OTEL validation API - Enhanced, not changed

**New Features (Additive Only):**
- `SandboxAdapter.runAsync(code)` - New method for async execution
- `createPerformanceProfiler()` - New profiler API
- Browser-specific exports - New, doesn't affect Node.js usage

### 6.2 Migration Path (v3.0.x → v3.1.0)

**Zero-Effort Migration:**
```javascript
// v3.0.x code works unchanged
import { KnowledgeEngine } from 'unrdf';
const engine = new KnowledgeEngine();
// ✅ Still works, now with isolated-vm automatically
```

**Optional Enhancements:**
```javascript
// v3.1.0 - Opt-in to new features
import { KnowledgeEngine } from 'unrdf';
import { createPerformanceProfiler } from 'unrdf/profiling';

const profiler = createPerformanceProfiler();
profiler.start();

const engine = new KnowledgeEngine({
  sandbox: {
    engine: 'isolated-vm', // Explicit selection
    memoryLimit: 256       // New option
  }
});
```

---

## 7. Implementation Roadmap

### Phase 1: Foundation (Week 1-2)
**Isolated-VM Sandbox:**
- [ ] Implement `isolated-vm-executor.mjs`
- [ ] Implement `sandbox-detector.mjs`
- [ ] Update `sandbox-adapter.mjs` with executor selection
- [ ] Add unit tests for each executor
- [ ] Benchmark performance vs vm2

**Browser Compatibility:**
- [ ] Implement `IndexedDBFileSystem`
- [ ] Update `FileSystemAdapter` with environment detection
- [ ] Create browser-optimized build pipeline
- [ ] Test in Chrome, Firefox, Safari

### Phase 2: Enhancement (Week 3-4)
**OTEL Validation v3:**
- [ ] Remove legacy CLI validations
- [ ] Implement `knowledge-hooks.validator.mjs`
- [ ] Implement `policy-packs.validator.mjs`
- [ ] Implement weighted scoring
- [ ] Achieve 85/100 baseline score

**Performance Profiling:**
- [ ] Implement `LatencyProfiler`
- [ ] Implement `MemoryProfiler`
- [ ] Implement unified `PerformanceProfiler` API
- [ ] Create HTML dashboard reporter

### Phase 3: Polish (Week 5-6)
**OTEL Validation v3 (continued):**
- [ ] Implement `lockchain.validator.mjs`
- [ ] Implement `browser.validator.mjs`
- [ ] Fine-tune performance thresholds
- [ ] Achieve 90+/100 target score

**Performance Profiling (continued):**
- [ ] Implement `CPUProfiler` (Node.js)
- [ ] OTEL integration for profiler
- [ ] Terminal UI reporter
- [ ] Documentation and examples

### Phase 4: Testing & Release (Week 7-8)
**Integration Testing:**
- [ ] E2E tests with all executors
- [ ] Browser compatibility testing
- [ ] Performance regression testing
- [ ] OTEL validation comprehensive run

**Documentation:**
- [ ] Migration guide (v3.0 → v3.1)
- [ ] Browser compatibility guide
- [ ] Profiling guide with examples
- [ ] Architecture decision records (ADRs)

**Release:**
- [ ] Release candidate (v3.1.0-rc.1)
- [ ] Community testing period
- [ ] Final release (v3.1.0)

---

## 8. Success Metrics

### 8.1 Isolated-VM Success Criteria
- [ ] 100% backward compatible with vm2 API
- [ ] Zero breaking changes for existing code
- [ ] Performance overhead ≤ 10% vs vm2
- [ ] Security audit passed
- [ ] All existing tests pass with isolated-vm

### 8.2 Browser Compatibility Success Criteria
- [ ] Demo working in Chrome, Firefox, Safari
- [ ] IndexedDB file system functional
- [ ] SPARQL queries working (via Comunica browser)
- [ ] Web Workers sandbox functional
- [ ] Bundle size ≤ 500KB (minified)

### 8.3 OTEL Validation v3 Success Criteria
- [ ] Overall score ≥ 90/100
- [ ] Legacy CLI validations removed
- [ ] All v3.1 features validated
- [ ] Performance thresholds enforced
- [ ] HTML report dashboard generated

### 8.4 Performance Profiling Success Criteria
- [ ] Latency profiling functional (p50, p95, p99)
- [ ] Memory profiling functional
- [ ] CPU profiling functional (Node.js)
- [ ] JSON export working
- [ ] HTML dashboard rendering
- [ ] Zero external dependencies (except OTEL)

---

## 9. Risks & Mitigations

### 9.1 Isolated-VM Risks

**Risk: Performance Regression**
- Mitigation: Benchmark extensively, optimize hot paths, pool isolates

**Risk: Compatibility Issues**
- Mitigation: Comprehensive test suite, fallback to worker threads

**Risk: Memory Leaks**
- Mitigation: Proper isolate disposal, automated leak detection

### 9.2 Browser Compatibility Risks

**Risk: SPARQL Engine Performance**
- Mitigation: Implement query result caching, optimize common queries

**Risk: Storage Quota Limits**
- Mitigation: Document limitations, implement quota monitoring

**Risk: Service Worker Support**
- Mitigation: Graceful degradation, feature detection

### 9.3 OTEL Validation Risks

**Risk: False Positives/Negatives**
- Mitigation: Manual review of validation rules, community feedback

**Risk: Performance Impact**
- Mitigation: Make validation opt-in for production, sampling

### 9.4 Profiling Risks

**Risk: Overhead in Production**
- Mitigation: Make profiling opt-in, sampling mode, disable by default

**Risk: Memory Consumption**
- Mitigation: Circular buffer for samples, configurable limits

---

## 10. Conclusion

This architecture provides a comprehensive design for UNRDF v3.1.0 with:

1. **Isolated-VM Sandbox** - Enhanced security without breaking changes
2. **Browser Compatibility** - Full browser support with progressive enhancement
3. **OTEL Validation v3** - 90+/100 score with modern feature coverage
4. **Performance Profiling** - Built-in profiling with zero external deps

**Key Architectural Principles:**
- Backward compatibility maintained (zero breaking changes)
- Progressive enhancement (auto-detect capabilities)
- Runtime adaptation (Node.js vs browser)
- Performance-first design (KGC PRD targets met)
- Security-first approach (isolated-vm, sandbox restrictions)

**Next Steps:**
1. Review and approve architecture
2. Create detailed implementation tasks
3. Begin Phase 1 implementation
4. Continuous OTEL validation throughout development

---

## Appendix A: Architecture Decision Records

### ADR-001: Isolated-VM over vm2
**Status:** Accepted
**Context:** vm2 is deprecated, security vulnerabilities, no active maintenance
**Decision:** Migrate to isolated-vm with fallbacks
**Consequences:** Better security, async support, but initialization overhead

### ADR-002: IndexedDB for Browser File System
**Status:** Accepted
**Context:** No real file system in browser, need persistent storage
**Decision:** Use IndexedDB with file-like API
**Consequences:** Storage limits apply, but works across browsers

### ADR-003: Remove Legacy CLI Validation
**Status:** Accepted
**Context:** v2 CLI deprecated, Knowledge Hooks API primary
**Decision:** Remove CLI validation from OTEL suite
**Consequences:** Cleaner validation, focus on core features

### ADR-004: Built-in Profiler (No External Deps)
**Status:** Accepted
**Context:** Need profiling without clinic.js/0x dependencies
**Decision:** Build custom profiler using OTEL and native APIs
**Consequences:** More control, zero deps, but limited features vs clinic

---

## Appendix B: API Compatibility Matrix

| API | v3.0.x | v3.1.0 | Breaking? |
|-----|--------|--------|-----------|
| `KnowledgeEngine` | ✅ | ✅ | ❌ No |
| `defineHook()` | ✅ | ✅ | ❌ No |
| `SandboxAdapter.run()` | ✅ | ✅ | ❌ No |
| `SandboxAdapter.runAsync()` | ❌ | ✅ | ❌ No (new) |
| `createPerformanceProfiler()` | ❌ | ✅ | ❌ No (new) |
| Browser exports | ❌ | ✅ | ❌ No (new) |
| CLI validation | ✅ | ⚠️ Deprecated | ⚠️ Yes (internal only) |

---

**Document Version:** 1.0
**Last Updated:** 2025-11-16
**Authors:** System Architecture Team
**Reviewers:** TBD
**Status:** Draft → Pending Review
