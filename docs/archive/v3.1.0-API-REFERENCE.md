# UNRDF v3.1.0 API Reference Summary

**Last Updated:** March 15, 2026

---

## New Exports in v3.1.0

### Browser Support

```javascript
// Browser-specific entry point
import {
  createBrowserKnowledgeEngine,
  BrowserTransactionManager,
  IndexedDBStorage,
  WebWorkerExecutor,
  ServiceWorkerCache
} from 'unrdf/browser';
```

### Performance Profiling

```javascript
import {
  PerformanceProfiler,
  createProfiler,
  generateFlamegraph  // Node.js only
} from 'unrdf';
```

### Security

```javascript
import {
  IsolatedVMSandbox,
  createIsolatedSandbox,
  ThreatDetector,
  validateEffectCode,
  signCode
} from 'unrdf';
```

---

## createBrowserKnowledgeEngine

Create a browser-compatible knowledge engine with IndexedDB storage.

```javascript
const engine = await createBrowserKnowledgeEngine(options);
```

**Options:**
```javascript
{
  storage: {
    type: 'indexeddb',           // Storage backend
    name: string,                 // Database name
    quota: number,                // Max storage (bytes)
    onQuotaExceeded: function     // Quota handler
  },
  workers: {
    enabled: boolean,             // Enable Web Workers
    maxWorkers: number,           // Max concurrent workers
    useSharedMemory: boolean      // Use SharedArrayBuffer
  },
  cache: {
    serviceWorker: boolean,       // Enable Service Worker
    offlineFirst: boolean,        // Offline-first mode
    cacheQueries: boolean,        // Cache query results
    ttl: number                   // Cache TTL (ms)
  },
  profiling: {
    enabled: boolean,             // Enable profiling
    sampleRate: number,           // 0-1 (0.1 = 10%)
    slowQueryThreshold: number,   // ms
    metrics: string[]             // ['latency', 'memory', 'cache']
  }
}
```

**Returns:** `Promise<BrowserKnowledgeEngine>`

**Example:**
```javascript
const engine = await createBrowserKnowledgeEngine({
  storage: {
    type: 'indexeddb',
    name: 'my-graph',
    quota: 100 * 1024 * 1024  // 100MB
  },
  workers: {
    enabled: true,
    maxWorkers: 4
  }
});
```

---

## createDarkMatterCore (Enhanced in v3.1.0)

Create a knowledge engine with new v3.1.0 features.

**New options in v3.1.0:**

```javascript
const system = await createDarkMatterCore({
  // New: isolated-vm sandbox
  sandbox: {
    engine: 'isolated-vm',        // Default in v3.1.0
    memoryLimit: 128,             // MB per isolate
    timeout: 5000,                // ms
    enableWasm: true,             // WASM support
    poolSize: 10,                 // Isolate pool
    maxConcurrent: 20,            // Max concurrent
    onTimeout: function,          // Timeout handler
    onMemoryLimit: function       // Memory limit handler
  },

  // New: Performance profiling
  profiling: {
    enabled: boolean,
    sampleRate: number,
    slowQueryThreshold: number,
    budgets: object,
    onSlowQuery: function,
    onBudgetExceeded: function,
    otel: {
      exporter: OTELExporter,
      metrics: string[],
      interval: number
    },
    memoryLeakDetection: {
      enabled: boolean,
      sampleInterval: number,
      threshold: number,
      onLeakDetected: function
    }
  }
});
```

---

## getPerformanceProfile

Get comprehensive performance profile.

```javascript
const profile = await system.getPerformanceProfile();
```

**Returns:**
```javascript
{
  latency: {
    p50: number,      // Median latency (ms)
    p95: number,      // 95th percentile (ms)
    p99: number,      // 99th percentile (ms)
    max: number,      // Maximum latency (ms)
    min: number,      // Minimum latency (ms)
    mean: number,     // Average latency (ms)
    stddev: number    // Standard deviation (ms)
  },
  memory: {
    heapUsed: number,      // Heap used (bytes)
    heapTotal: number,     // Total heap (bytes)
    external: number,      // External memory (bytes)
    rss: number,           // Resident set size (bytes)
    arrayBuffers: number,  // ArrayBuffer memory (bytes)
    gcPressure: number,    // GC pressure (0-1)
    leakScore: number      // Leak detection score (0-1)
  },
  cache: {
    hitRate: number,       // Cache hit rate (0-1)
    size: number,          // Cache size (entries)
    evictions: number      // Total evictions
  },
  slowQueries: [
    {
      query: string,
      duration: number,
      timestamp: number,
      type: string
    }
  ],
  hotPaths: [  // Node.js only
    {
      function: string,
      file: string,
      line: number,
      count: number,
      totalTime: number,
      avgTime: number,
      percentage: number
    }
  ],
  latencyByOperation: {
    'sparql-select': { p50, p95, p99 },
    'transaction-commit': { p50, p95, p99 },
    ...
  }
}
```

---

## generateFlamegraph

Generate CPU flamegraph (Node.js only).

```javascript
const flamegraph = await system.generateFlamegraph(options);
```

**Options:**
```javascript
{
  duration: number,      // Profile duration (ms)
  outputPath: string,    // Output file path
  format: 'svg' | 'html' | 'json'
}
```

**Returns:**
```javascript
{
  path: string,
  format: string,
  duration: number
}
```

**Example:**
```javascript
const flamegraph = await system.generateFlamegraph({
  duration: 30000,
  outputPath: './profiles/flamegraph.svg',
  format: 'svg'
});

console.log(`Flamegraph saved to: ${flamegraph.path}`);
```

---

## startContinuousProfiling

Start continuous performance profiling.

```javascript
const profiler = system.startContinuousProfiling(options);
```

**Options:**
```javascript
{
  interval: number,       // Sample interval (ms)
  output: 'console' | 'file' | 'otel',
  filePath: string,       // File path (if output='file')
  fileRotation: 'hourly' | 'daily' | 'weekly'
}
```

**Returns:** `ContinuousProfiler`

**Methods:**
```javascript
await profiler.stop();
const profiles = await profiler.getProfiles();
```

**Example:**
```javascript
const profiler = system.startContinuousProfiling({
  interval: 10000,
  output: 'file',
  filePath: './profiles/profile-{timestamp}.json'
});

// Run for a while...
await new Promise(r => setTimeout(r, 60000));

await profiler.stop();
const profiles = await profiler.getProfiles();
console.log(`Collected ${profiles.length} profiles`);
```

---

## getStorageQuota (Browser only)

Get IndexedDB storage quota.

```javascript
const quota = await engine.getStorageQuota();
```

**Returns:**
```javascript
{
  used: number,       // Bytes used
  total: number,      // Total quota (bytes)
  available: number,  // Available (bytes)
  percentage: number  // Usage percentage (0-1)
}
```

**Example:**
```javascript
const quota = await engine.getStorageQuota();

console.log(`Used: ${(quota.used / 1024 / 1024).toFixed(2)}MB`);
console.log(`Total: ${(quota.total / 1024 / 1024).toFixed(2)}MB`);
console.log(`Available: ${(quota.available / 1024 / 1024).toFixed(2)}MB`);
console.log(`Percentage: ${(quota.percentage * 100).toFixed(1)}%`);

if (quota.percentage > 0.8) {
  console.warn('Storage nearly full!');
}
```

---

## vacuum

Clean up storage and optimize performance.

```javascript
await engine.vacuum(options);
```

**Options:**
```javascript
{
  keepLatest: number,     // Keep latest N triples
  strategy: 'lru' | 'fifo',  // Eviction strategy
  retentionDays: number,  // Keep data from last N days
  compressOld: boolean    // Compress old data
}
```

**Example:**
```javascript
// Keep only latest 1000 triples
await engine.vacuum({
  keepLatest: 1000,
  strategy: 'lru'
});

// Keep only last 7 days
await engine.vacuum({
  retentionDays: 7,
  compressOld: true
});
```

---

## checkForMemoryLeaks

Check for memory leaks.

```javascript
const report = await system.checkForMemoryLeaks();
```

**Returns:**
```javascript
{
  leak: boolean,
  score: number,           // 0-1 (0 = no leak, 1 = severe)
  growthRate: number,      // MB/min
  suspectedSource: string,
  recommendations: string[]
}
```

**Example:**
```javascript
const leak = await system.checkForMemoryLeaks();

if (leak.leak) {
  console.error(`Memory leak detected!`);
  console.error(`Score: ${(leak.score * 100).toFixed(2)}%`);
  console.error(`Growth: ${leak.growthRate}MB/min`);
  console.error(`Source: ${leak.suspectedSource}`);

  for (const rec of leak.recommendations) {
    console.log(`  - ${rec}`);
  }
}
```

---

## ThreatDetector

Analyze effect code for security threats (optional).

```javascript
import { ThreatDetector } from 'unrdf';

const detector = new ThreatDetector(options);
```

**Options:**
```javascript
{
  blockThreshold: number,      // Block if score ≥ this
  logThreshold: number,        // Log if score ≥ this
  enableCodeSigning: boolean,  // Require signatures
  trustedSigners: string[]     // Trusted public keys
}
```

**Methods:**
```javascript
const analysis = await detector.analyzeCode(code, {
  signature: string,
  publicKey: string
});
```

**Returns:**
```javascript
{
  score: number,            // Threat score (0-100)
  severity: 'low' | 'medium' | 'high' | 'critical',
  blocked: boolean,
  patterns: [
    {
      name: string,
      description: string,
      severity: string,
      score: number
    }
  ],
  complexityScore: number,
  behaviorScore: number
}
```

**Example:**
```javascript
const detector = new ThreatDetector({
  blockThreshold: 80,
  logThreshold: 40
});

const analysis = await detector.analyzeCode(effectCode);

if (analysis.blocked) {
  console.error(`Threat detected (score: ${analysis.score})`);
  for (const pattern of analysis.patterns) {
    console.error(`  - ${pattern.name}: ${pattern.description}`);
  }
} else {
  console.log('Code is safe to execute');
}
```

---

## signCode / verifyCode

Cryptographically sign effect code.

```javascript
import { signCode, verifyCode } from 'unrdf';
import { generateKeyPair } from 'crypto';
```

**Sign:**
```javascript
const { publicKey, privateKey } = generateKeyPair('ed25519', {
  modulusLength: 2048
});

const signature = signCode(code, privateKey);
```

**Verify:**
```javascript
const valid = verifyCode(code, signature, publicKey);

if (!valid) {
  throw new Error('Invalid signature');
}
```

---

## Backward Compatibility

All v3.0.x APIs remain unchanged in v3.1.0:

```javascript
// All these still work exactly as before:
import {
  createDarkMatterCore,
  parseTurtle,
  toTurtle,
  defineHook,
  registerHook,
  deregisterHook,
  evaluateHook,
  TransactionManager,
  LockchainWriter,
  Observability,
  Store,
  Parser,
  Writer
} from 'unrdf';
```

---

## Migration Guide

See [MIGRATION-v3.0-to-v3.1.md](./MIGRATION-v3.0-to-v3.1.md) for detailed migration instructions.

**Summary:**
- ✅ Zero breaking changes
- ✅ Drop-in replacement for v3.0.x
- ✅ New features are opt-in

---

## Complete Documentation

- [v3.1.0 Release Notes](./v3.1.0-RELEASE-NOTES.md)
- [Migration Guide](./MIGRATION-v3.0-to-v3.1.md)
- [Browser Compatibility](./BROWSER-COMPATIBILITY.md)
- [Security Updates](./SECURITY-UPDATES-v3.1.md)
- [Performance Profiling](./PERFORMANCE-PROFILING.md)
- [CLI Package Design](./CLI-PACKAGE-DESIGN.md)
- [Ecosystem Roadmap](./ECOSYSTEM-ROADMAP.md)

---

**Questions?** Open an issue: https://github.com/unrdf/unrdf/issues
