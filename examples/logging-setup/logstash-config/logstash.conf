input {
  # JSON logs from UNRDF services
  tcp {
    port => 5000
    codec => json_lines
  }

  # UDP for high-throughput scenarios
  udp {
    port => 5000
    codec => json_lines
  }

  # Filebeat input
  beats {
    port => 5044
  }
}

filter {
  # Parse UNRDF-specific log format
  if [service] == "unrdf-kgc" or [service] == "unrdf-validation" {
    # Extract log level
    grok {
      match => { "message" => "\[%{LOGLEVEL:log_level}\] %{GREEDYDATA:log_message}" }
    }

    # Parse OpenTelemetry trace context
    if [trace_id] {
      mutate {
        add_field => {
          "has_trace" => "true"
        }
      }
    }

    # Sample DEBUG logs (1 in 100)
    if [log_level] == "DEBUG" {
      ruby {
        code => "
          if rand(100) != 0
            event.cancel
          else
            event.set('sampled', true)
          end
        "
      }
    }

    # Always keep WARN and ERROR
    if [log_level] == "WARN" or [log_level] == "ERROR" {
      mutate {
        add_tag => ["high_priority"]
      }
    }

    # Add timestamp
    date {
      match => ["timestamp", "ISO8601"]
      target => "@timestamp"
    }

    # Extract metrics from structured logs
    if [kgc_metric] {
      mutate {
        add_tag => ["metric"]
      }
    }
  }

  # Enrich with GeoIP if applicable
  if [client_ip] {
    geoip {
      source => "client_ip"
    }
  }
}

output {
  # Send to Elasticsearch
  elasticsearch {
    hosts => ["elasticsearch:9200"]
    index => "unrdf-logs-%{+YYYY.MM.dd}"

    # Use template for index mapping
    template_name => "unrdf-logs"
    template_overwrite => true
  }

  # Debug output (optional, comment out in production)
  # stdout { codec => rubydebug }
}
