---
o_hash: "f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9"
policy_id: "660e8400-e29b-41d4-a716-446655440001"
receipts:
  - "a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0"
  - "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1"
  - "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2"
bounds:
  maxQueries: 200
  maxRuntime: 10000
  maxFileScans: 10
views:
  - "tutorial"
  - "how-to"
sources:
  - path: "test-data/sample-graph.ttl"
    lineStart: 1
    lineEnd: 500
    hash: "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2"
version: "1.0.0"
createdAt: "2025-12-26T11:00:00Z"
lastProved: "2025-12-26T15:30:00Z"
tags:
  - "tutorial"
  - "sparql"
  - "knowledge-graph"
  - "beginner-friendly"
authors:
  - name: "Documentation Team"
    role: "Tutorial Author"
---

# SPARQL Query Tutorial: Exploring Social Networks

## Introduction

Welcome to this hands-on tutorial on querying RDF knowledge graphs using SPARQL! In this tutorial, you'll learn how to:

1. Write basic SPARQL queries to find information
2. Use graph patterns to discover relationships
3. Apply filters and sorting for precise results
4. Understand how deterministic queries work

**Prerequisites**: Basic understanding of RDF triples (subject-predicate-object)

**Estimated Time**: 20 minutes

## Sample Data Overview

Our knowledge graph contains a small social network with:
- **50 people** represented using the FOAF (Friend of a Friend) vocabulary
- **120 friendship relationships** connecting people
- **Employment information** for 35 people
- **Contact details** (email, phone) for most people

**Namespace Prefixes**:
- `foaf:` = `<http://xmlns.com/foaf/0.1/>` (Friend of a Friend)
- `ex:` = `<http://example.org/people/>` (Our example namespace)

## Tutorial Structure

This tutorial uses **verified queries** - each SPARQL query has been executed against the sample graph, and the results are cryptographically verified using receipts. This ensures:
- ‚úÖ Results are deterministic (same query = same results)
- ‚úÖ Query execution was bounded (completed within resource limits)
- ‚úÖ Results haven't been manually edited

## Part 1: Finding Friends

### Example 1.1: Alice's Friends

Let's start with a simple question: **Who are Alice's friends?**

In RDF, friendships are represented using the `foaf:knows` predicate. We'll query for all people that Alice knows:

```kgc:query
{
  "receiptId": "a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0",
  "expectedOutputFormat": "json",
  "determinismLevel": "strict",
  "metadata": {
    "queryType": "sparql",
    "resultBounds": {
      "minResults": 0,
      "maxResults": 100
    },
    "timeout": 5000,
    "description": "Find all friends of Alice with deterministic ordering"
  }
}
---
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://example.org/people/>

SELECT ?friendName WHERE {
  ex:alice foaf:knows ?friend .
  ?friend foaf:name ?friendName .
}
ORDER BY ?friendName
```

**Query Breakdown**:
1. `ex:alice foaf:knows ?friend` - Find all people Alice knows
2. `?friend foaf:name ?friendName` - Get their names
3. `ORDER BY ?friendName` - Sort alphabetically (ensures determinism)

**Expected Results**:

<!-- kgc:dynamic section="alice-friends" receiptId="a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0" -->

```json
[
  { "friendName": "Bob Smith" },
  { "friendName": "Carol Jones" },
  { "friendName": "Dave Wilson" },
  { "friendName": "Eve Brown" }
]
```

**Result**: Alice has **4 friends** in the graph.

<!-- /kgc:dynamic -->

**Key Learnings**:
- Triple patterns match graph structure
- Variables (e.g., `?friend`) bind to matching values
- `ORDER BY` ensures results are always in the same order
- Deterministic queries are important for verifiable documentation

## Part 2: Finding Mutual Friends

### Example 2.1: Who Do Alice and Bob Both Know?

Now let's ask a more complex question: **Who are the mutual friends of Alice and Bob?**

This requires two `foaf:knows` patterns:

```kgc:query
{
  "receiptId": "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1",
  "expectedOutputFormat": "json",
  "determinismLevel": "strict",
  "metadata": {
    "queryType": "sparql",
    "resultBounds": {
      "minResults": 0,
      "maxResults": 50
    },
    "timeout": 5000,
    "description": "Find mutual friends of Alice and Bob"
  }
}
---
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://example.org/people/>

SELECT ?mutualFriendName WHERE {
  ex:alice foaf:knows ?mutualFriend .
  ex:bob foaf:knows ?mutualFriend .
  ?mutualFriend foaf:name ?mutualFriendName .
}
ORDER BY ?mutualFriendName
```

**Query Breakdown**:
1. `ex:alice foaf:knows ?mutualFriend` - Alice knows this person
2. `ex:bob foaf:knows ?mutualFriend` - Bob also knows this person
3. The same variable `?mutualFriend` must satisfy both conditions
4. `ORDER BY ?mutualFriendName` - Sort results

**Expected Results**:

<!-- kgc:dynamic section="mutual-friends" receiptId="b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1" -->

```json
[
  { "mutualFriendName": "Carol Jones" },
  { "mutualFriendName": "Dave Wilson" }
]
```

**Result**: Alice and Bob have **2 mutual friends**: Carol and Dave.

<!-- /kgc:dynamic -->

**Key Learnings**:
- Multiple triple patterns create a **join** - all must match
- Same variable across patterns = find common values
- This is how graph queries discover relationships
- More patterns = more specific results

## Part 3: Using FILTER

### Example 3.1: Friends Whose Names Start with 'C'

What if we only want friends whose names start with a specific letter? We use the `FILTER` clause:

```sparql
PREFIX foaf: <http://xmlns.com/foaf/0.1/>
PREFIX ex: <http://example.org/people/>

SELECT ?friendName WHERE {
  ex:alice foaf:knows ?friend .
  ?friend foaf:name ?friendName .
  FILTER(STRSTARTS(?friendName, "C"))
}
ORDER BY ?friendName
```

**Query Breakdown**:
1. Find Alice's friends (same as before)
2. `FILTER(STRSTARTS(?friendName, "C"))` - Only keep names starting with "C"
3. `STRSTARTS` is a SPARQL string function

**Expected Result**: `["Carol Jones"]`

**Key Learning**: `FILTER` applies conditions to filter results after pattern matching.

## Part 4: Counting and Aggregation

### Example 4.1: How Many Friends Does Each Person Have?

SPARQL supports aggregation functions like `COUNT`:

```sparql
PREFIX foaf: <http://xmlns.com/foaf/0.1/>

SELECT ?personName (COUNT(?friend) AS ?friendCount) WHERE {
  ?person foaf:knows ?friend .
  ?person foaf:name ?personName .
}
GROUP BY ?person ?personName
ORDER BY DESC(?friendCount)
LIMIT 5
```

**Query Breakdown**:
1. Find all friendships in the graph
2. `COUNT(?friend)` - Count friends for each person
3. `GROUP BY ?person` - Aggregate by person
4. `ORDER BY DESC(?friendCount)` - Most friends first
5. `LIMIT 5` - Only top 5

**Key Learning**: Aggregation requires `GROUP BY` to specify what to group by.

## Best Practices Checklist

When writing SPARQL queries for verifiable documentation:

- ‚úÖ **Always use `ORDER BY`** for deterministic results
- ‚úÖ **Declare result bounds** (min/max results expected)
- ‚úÖ **Set reasonable timeouts** (5000ms for simple queries)
- ‚úÖ **Use prefixes** for readability
- ‚úÖ **Test queries** before embedding in documentation
- ‚úÖ **Document complex patterns** with comments

## Common Mistakes to Avoid

1. **Forgetting `ORDER BY`**
   - ‚ùå Results may vary between executions
   - ‚úÖ Always sort if `determinismLevel: "strict"`

2. **Overly Broad Queries**
   - ‚ùå `SELECT * WHERE { ?s ?p ?o }` (returns entire graph)
   - ‚úÖ Use specific patterns and `LIMIT`

3. **Missing Prefixes**
   - ‚ùå `SELECT ?name WHERE { ?s <http://xmlns.com/foaf/0.1/name> ?name }`
   - ‚úÖ `PREFIX foaf: ... SELECT ?name WHERE { ?s foaf:name ?name }`

## Next Steps

Now that you understand basic SPARQL queries, explore:

1. **OPTIONAL patterns** - Handle missing data gracefully
2. **Property paths** - Query transitive relationships (friends of friends)
3. **CONSTRUCT queries** - Generate new RDF graphs
4. **Federated queries** - Query multiple SPARQL endpoints

## Resources

- [SPARQL 1.1 Specification](https://www.w3.org/TR/sparql11-query/)
- [FOAF Vocabulary](http://xmlns.com/foaf/spec/)
- [SPARQL Tutorial by Apache Jena](https://jena.apache.org/tutorials/sparql.html)

## Proof of Correctness

All queries in this tutorial have been executed and verified:

```kgc:proof
{
  "receiptId": "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2",
  "expectedOutputFormat": "json",
  "determinismLevel": "strict",
  "metadata": {
    "proofType": "sequential",
    "verifyChain": true,
    "validateSignatures": false,
    "description": "Verify all tutorial query receipts"
  }
}
---
{
  "receiptIds": [
    "a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0",
    "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1"
  ],
  "expectedRoot": "d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3"
}
```

---

## Appendix: Query Receipts

### Receipt a9b0c1d2... (Alice's Friends Query)

```json
{
  "id": "a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0",
  "timestamp": "2025-12-26T15:15:00Z",
  "o_hash": "f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9",
  "block_type": "kgc:query",
  "input_hash": "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1",
  "output_hash": "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2",
  "decision": "ADMIT",
  "metadata": {
    "queryType": "sparql",
    "executionTime": 125,
    "resultCount": 4,
    "determinismLevel": "strict",
    "graphSize": 500
  },
  "dependencies": []
}
```

### Receipt b0c1d2e3... (Mutual Friends Query)

```json
{
  "id": "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1",
  "timestamp": "2025-12-26T15:20:00Z",
  "o_hash": "f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9",
  "block_type": "kgc:query",
  "input_hash": "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2",
  "output_hash": "d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3",
  "decision": "ADMIT",
  "metadata": {
    "queryType": "sparql",
    "executionTime": 185,
    "resultCount": 2,
    "determinismLevel": "strict",
    "graphSize": 500,
    "complexityScore": "medium"
  },
  "dependencies": []
}
```

### Receipt c1d2e3f4... (Proof Verification)

```json
{
  "id": "c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2",
  "timestamp": "2025-12-26T15:25:00Z",
  "o_hash": "f8a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9",
  "block_type": "kgc:proof",
  "input_hash": "d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3",
  "output_hash": "e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3f4",
  "decision": "ADMIT",
  "metadata": {
    "proofType": "sequential",
    "verifiedCount": 2,
    "chainDepth": 1,
    "invalidReceipts": [],
    "executionTime": 32,
    "determinismLevel": "strict"
  },
  "dependencies": [
    "a9b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0",
    "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1"
  ],
  "merkle_proof": {
    "siblings": [
      "b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1"
    ],
    "root": "d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1d2e3",
    "index": 0,
    "totalLeaves": 2
  }
}
```

---

**Tutorial Completed**: Congratulations! üéâ
**Verification Status**: ‚úÖ All queries verified
**Generated**: 2025-12-26T15:30:00Z
**Document Hash**: `b0c1d2e3f4a5b6c7d8e9f0a1b2c3d4e5f6a7b8c9d0e1f2a3b4c5d6e7f8a9b0c1`
