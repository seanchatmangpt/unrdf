# Order Book Divergence - Market μ Operator Example
# Chatman Equation: A = μ(O)
# Demonstrates how bid-ask spread divergence creates arbitrage opportunities

[metadata]
name = "Order Book Divergence"
description = "Market inefficiency detection through closure operator on order book snapshots"
domain = "market-microstructure"
equation = "Opportunities = μ(OrderBookSnapshots)"

# Observations (O): Raw market data
[observations]
timestamp = "2026-01-18T08:00:00Z"
market_pair = "BTC/USD"

[[observations.snapshots]]
exchange = "ExchangeA"
bid_price = 45000.00
bid_volume = 2.5
ask_price = 45010.00
ask_volume = 1.8
spread_bps = 22.2

[[observations.snapshots]]
exchange = "ExchangeB"
bid_price = 45020.00
bid_volume = 3.2
ask_price = 45030.00
ask_volume = 2.1
spread_bps = 22.2

[[observations.snapshots]]
exchange = "ExchangeC"
bid_price = 44990.00
bid_volume = 1.9
ask_price = 45000.00
ask_volume = 2.7
spread_bps = 22.2

# Closure Operator (μ): Transformation rules
[closure_operator]
name = "arbitrage_detector"
type = "market_divergence"
idempotent = true
deterministic = true

# Rule 1: Cross-exchange arbitrage detection
[[closure_operator.rules]]
name = "cross_exchange_arbitrage"
condition = "max(bid_prices) > min(ask_prices)"
action = "create_arbitrage_opportunity"

[closure_operator.rules.parameters]
min_profit_bps = 10.0
max_execution_latency_ms = 50
slippage_tolerance_bps = 5.0

# Rule 2: Spread normalization
[[closure_operator.rules]]
name = "normalize_spreads"
condition = "spread_bps > market_avg_spread_bps"
action = "flag_wide_spread"

[closure_operator.rules.parameters]
lookback_periods = 100
std_dev_threshold = 2.0

# Rule 3: Volume-weighted opportunity scoring
[[closure_operator.rules]]
name = "volume_weighted_scoring"
condition = "arbitrage_opportunity_exists"
action = "calculate_expected_profit"

[closure_operator.rules.parameters]
volume_impact_model = "linear"
fee_tier = "maker_taker"

# Artifacts (A): Predicted outcomes from μ(O)
[artifacts]
total_opportunities = 1
convergence_guaranteed = true
execution_deterministic = true

[[artifacts.opportunities]]
id = "arb-001"
type = "cross_exchange"
buy_exchange = "ExchangeC"
buy_price = 45000.00
sell_exchange = "ExchangeB"
sell_price = 45020.00
gross_profit_bps = 44.4
net_profit_bps = 34.4
max_volume = 1.9
confidence = 0.95

[[artifacts.opportunities.execution_plan]]
step = 1
action = "buy"
exchange = "ExchangeC"
price = 45000.00
volume = 1.9

[[artifacts.opportunities.execution_plan]]
step = 2
action = "sell"
exchange = "ExchangeB"
price = 45020.00
volume = 1.9

[[artifacts.opportunities.execution_plan]]
step = 3
action = "settle"
expected_profit_usd = 38.00
expected_latency_ms = 45

# Verification: Prove A = μ(O)
[verification]
method = "deterministic_replay"
idempotence_test = "μ(μ(O)) = μ(O)"
composability_test = "μ(O₁ ∪ O₂) ⊇ μ(O₁) ∪ μ(O₂)"

[verification.assertions]
opportunity_count_deterministic = true
profit_calculation_reproducible = true
execution_order_invariant = false  # Order matters for latency

[verification.invariants]
max_bid = 45020.00
min_ask = 45000.00
arbitrage_exists = true
profit_positive = true

# Test that running μ twice yields same result
[verification.idempotence]
first_run_hash = "sha256:a3f2c8d9..."
second_run_hash = "sha256:a3f2c8d9..."
hashes_match = true

# Test that μ is deterministic for same input
[verification.determinism]
run_count = 100
unique_outputs = 1
determinism_score = 1.0
