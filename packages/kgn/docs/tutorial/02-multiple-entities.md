# Tutorial 2: Working with Multiple Entities

In this tutorial, you'll learn how to work with multiple RDF entities in templates and generate structured output.

## What You'll Build

You'll create a template that generates a TypeScript file defining multiple entities from an RDF vocabulary.

## The Template

Create `vocabulary.njk`:

```nunjucks
---
name: "TypeScript Vocabulary Generator"
description: "Generate TypeScript types from RDF vocabulary"
prefixes:
  rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
  rdfs: "http://www.w3.org/2000/01/rdf-schema#"
  ex: "http://example.org/vocab#"
classes:
  - uri: "ex:Person"
    label: "Person"
    comment: "A human being"
    properties:
      - "ex:name"
      - "ex:email"
      - "ex:age"
  - uri: "ex:Organization"
    label: "Organization"
    comment: "A structured group of people"
    properties:
      - "ex:name"
      - "ex:founded"
      - "ex:employees"
properties:
  - uri: "ex:name"
    label: "name"
    range: "string"
  - uri: "ex:email"
    label: "email"
    range: "string"
  - uri: "ex:age"
    label: "age"
    range: "number"
  - uri: "ex:founded"
    label: "founded"
    range: "Date"
  - uri: "ex:employees"
    label: "employees"
    range: "number"
---
/**
 * Generated from RDF Vocabulary
 * URI: {{ prefixes.ex }}
 *
 * @generated by @unrdf/kgn
 */

{% for cls in classes %}
/**
 * {{ cls.comment }}
 * RDF Type: {{ cls.uri | expand(prefixes) }}
 */
export interface {{ cls.label }} {
  uri: string;
  type: "{{ cls.uri }}";
{% for propUri in cls.properties %}
{%- set prop = properties | selectattr("uri", "equalto", propUri) | first %}
  /** RDF Property: {{ prop.uri | expand(prefixes) }} */
  {{ prop.label }}: {{ prop.range }};
{% endfor %}
}
{% endfor %}

/**
 * RDF Prefix mappings
 */
export const PREFIXES = {
{% for prefix, uri in prefixes %}
  {{ prefix }}: {{ uri | rdfLiteral }},
{% endfor %}
};

/**
 * Expand CURIE to full URI
 */
export function expandURI(curie: string): string {
  const [prefix, localName] = curie.split(':', 2);
  if (!prefix || !localName) return curie;
  const namespace = PREFIXES[prefix as keyof typeof PREFIXES];
  return namespace ? namespace + localName : curie;
}
```

## Render the Template

```javascript
import { FrontmatterParser } from '@unrdf/kgn';
import { expand, rdfLiteral } from '@unrdf/kgn/filters';
import nunjucks from 'nunjucks';
import { readFileSync, writeFileSync } from 'fs';

// Setup
const env = new nunjucks.Environment(null, { autoescape: false });
env.addFilter('expand', expand);
env.addFilter('rdfLiteral', rdfLiteral);

// Add custom filter for selectattr (Jinja2-style)
env.addFilter('selectattr', function(arr, attr, op, value) {
  if (op === 'equalto') {
    return arr.filter(item => item[attr] === value);
  }
  return arr;
});

// Parse and render
const parser = new FrontmatterParser();
const template = readFileSync('vocabulary.njk', 'utf-8');
const parsed = parser.parse(template);
const output = env.renderString(parsed.content, parsed.frontmatter);

// Write output
writeFileSync('vocabulary.ts', output);
console.log('âœ… Generated vocabulary.ts');
```

## Expected Output

Running the script generates `vocabulary.ts`:

```typescript
/**
 * Generated from RDF Vocabulary
 * URI: http://example.org/vocab#
 *
 * @generated by @unrdf/kgn
 */

/**
 * A human being
 * RDF Type: http://example.org/vocab#Person
 */
export interface Person {
  uri: string;
  type: "ex:Person";
  /** RDF Property: http://example.org/vocab#name */
  name: string;
  /** RDF Property: http://example.org/vocab#email */
  email: string;
  /** RDF Property: http://example.org/vocab#age */
  age: number;
}

/**
 * A structured group of people
 * RDF Type: http://example.org/vocab#Organization
 */
export interface Organization {
  uri: string;
  type: "ex:Organization";
  /** RDF Property: http://example.org/vocab#name */
  name: string;
  /** RDF Property: http://example.org/vocab#founded */
  founded: Date;
  /** RDF Property: http://example.org/vocab#employees */
  employees: number;
}

/**
 * RDF Prefix mappings
 */
export const PREFIXES = {
  rdf: "http://www.w3.org/1999/02/22-rdf-syntax-ns#",
  rdfs: "http://www.w3.org/2000/01/rdf-schema#",
  ex: "http://example.org/vocab#",
};

/**
 * Expand CURIE to full URI
 */
export function expandURI(curie: string): string {
  const [prefix, localName] = curie.split(':', 2);
  if (!prefix || !localName) return curie;
  const namespace = PREFIXES[prefix as keyof typeof PREFIXES];
  return namespace ? namespace + localName : curie;
}
```

## Key Techniques

### 1. Iterating Over Arrays

Use `{% for %}` loops to process multiple entities:

```nunjucks
{% for cls in classes %}
  {{ cls.label }}
{% endfor %}
```

### 2. Filtering Arrays

Use custom filters to find related data:

```nunjucks
{%- set prop = properties | selectattr("uri", "equalto", propUri) | first %}
```

### 3. Nested Structures

Frontmatter supports nested objects and arrays:

```yaml
classes:
  - uri: "ex:Person"
    properties:
      - "ex:name"
      - "ex:email"
```

### 4. Dynamic Property Lookup

Access properties dynamically:

```nunjucks
{{ prop.range }}  {# Access from matched property #}
```

## Exercises

Try these modifications to practice:

1. **Add more classes**: Add an `ex:Product` class with properties
2. **Add constraints**: Include `required: true` in properties and generate optional properties with `?`
3. **Generate validators**: Create Zod schemas instead of TypeScript interfaces
4. **Add descriptions**: Use `rdfs:comment` to generate JSDoc comments

## Next Steps

- [Tutorial 3: Using All RDF Filters](./03-rdf-filters.md)
- [How-To: Generate SHACL Shapes](../how-to/generate-shacl-shapes.md)
- [Reference: Filter API](../reference/filters.md)
