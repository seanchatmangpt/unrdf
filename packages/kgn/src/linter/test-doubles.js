/**
 * KGEN Deterministic Test Doubles - London BDD Style
 *
 * Mission: Provide deterministic alternatives for nondeterministic APIs
 * Style: London School TDD - Test Doubles, Mocks, Stubs, Fakes
 *
 * These test doubles ensure that all tests produce consistent, deterministic results
 * by replacing nondeterministic dependencies with predictable alternatives.
 *
 * Generated by: Determinism Sentinel Agent
 * Authority: ZERO TOLERANCE for nondeterminism
 */

import { createHash } from 'crypto';
import { EventEmitter as _EventEmitter } from 'events';

/**
 * TEMPORAL TEST DOUBLES
 * Replace all time-based nondeterministic functions
 */

/**
 *
 */
export class DeterministicDate extends Date {
  static FIXED_TIMESTAMP = '2025-01-01T00:00:00.000Z';
  static FIXED_TIME_MS = new Date(DeterministicDate.FIXED_TIMESTAMP).getTime();

  /**
   *
   */
  constructor(...args) {
    if (args.length === 0) {
      // No arguments = current time -> use fixed time
      super(DeterministicDate.FIXED_TIMESTAMP);
    } else if (args.length === 1 && typeof args[0] === 'undefined') {
      // undefined argument -> use fixed time
      super(DeterministicDate.FIXED_TIMESTAMP);
    } else {
      // Specific time provided -> use it (deterministic)
      super(...args);
    }
  }

  /**
   *
   */
  static now() {
    return DeterministicDate.FIXED_TIME_MS;
  }

  /**
   *
   */
  static deterministic() {
    return DeterministicDate.FIXED_TIME_MS;
  }
}

/**
 *
 */
export class MockMath {
  static seed = 0.12345; // Fixed seed for deterministic "random"

  /**
   *
   */
  static random() {
    // Linear congruential generator - deterministic pseudorandom
    MockMath.seed = (MockMath.seed * 9301 + 49297) % 233280;
    return MockMath.seed / 233280;
  }

  /**
   *
   */
  static resetSeed() {
    MockMath.seed = 0.12345;
  }

  /**
   *
   */
  static setSeed(newSeed) {
    MockMath.seed = newSeed;
  }

  // Proxy all other Math methods
  static floor = Math.floor;
  static ceil = Math.ceil;
  static round = Math.round;
  static abs = Math.abs;
  static max = Math.max;
  static min = Math.min;
}

/**
 * DETERMINISTIC ID GENERATOR
 * Replace UUID and random ID generation with content-based deterministic IDs
 */

/**
 *
 */
export class DeterministicIdGenerator {
  /**
   *
   */
  constructor(config = {}) {
    this.config = {
      defaultSalt: 'kgen-deterministic',
      hashAlgorithm: 'sha256',
      idLength: 8,
      ...config
    };
    this.counter = 0;
  }

  /**
   *
   */
  generateId(content, salt = null) {
    const actualSalt = salt || this.config.defaultSalt;
    const hash = createHash(this.config.hashAlgorithm);

    // Ensure deterministic serialization of content
    const serializedContent = typeof content === 'object'
      ? JSON.stringify(content, Object.keys(content).sort())
      : String(content);

    hash.update(serializedContent);
    hash.update(actualSalt);
    hash.update(String(this.counter++)); // Add counter for uniqueness

    return hash.digest('hex').substring(0, this.config.idLength);
  }

  /**
   *
   */
  generateUUID(content, salt = null) {
    const hash = this.generateId(content, salt);
    // Format as UUID v4 structure (but deterministic)
    return `${hash.substring(0, 8)}-${hash.substring(8, 12)}-4${hash.substring(12, 15)}-8${hash.substring(15, 18)}-${hash.substring(18, 30)}000000`.substring(0, 36);
  }

  /**
   *
   */
  reset() {
    this.counter = 0;
  }
}

/**
 * ENVIRONMENT TEST DOUBLES
 * Replace process.env and system information with deterministic alternatives
 */

/**
 *
 */
export class MockProcessEnv {
  static FIXED_ENV = {
    NODE_ENV: 'test',
    BASE_URL: 'https://test.example.com',
    API_KEY: 'test-api-key-deterministic',
    DATABASE_URL: 'sqlite://test.db',
    REDIS_URL: 'redis://localhost:6379/0',
    PORT: '3000',
    HOST: '0.0.0.0'
  };

  /**
   *
   */
  static get(key) {
    return MockProcessEnv.FIXED_ENV[key];
  }

  /**
   *
   */
  static set(key, value) {
    MockProcessEnv.FIXED_ENV[key] = value;
  }

  /**
   *
   */
  static reset() {
    MockProcessEnv.FIXED_ENV = { ...MockProcessEnv.FIXED_ENV };
  }

  /**
   *
   */
  static toObject() {
    return { ...MockProcessEnv.FIXED_ENV };
  }
}

/**
 *
 */
export class MockOS {
  static FIXED_INFO = {
    hostname: 'test-hostname',
    platform: 'linux',
    arch: 'x64',
    version: '1.0.0-test',
    tmpdir: '/tmp/test',
    userInfo: {
      username: 'test-user',
      uid: 1000,
      gid: 1000,
      shell: '/bin/bash',
      homedir: '/home/test-user'
    }
  };

  /**
   *
   */
  static hostname() {
    return MockOS.FIXED_INFO.hostname;
  }

  /**
   *
   */
  static platform() {
    return MockOS.FIXED_INFO.platform;
  }

  /**
   *
   */
  static arch() {
    return MockOS.FIXED_INFO.arch;
  }

  /**
   *
   */
  static version() {
    return MockOS.FIXED_INFO.version;
  }

  /**
   *
   */
  static tmpdir() {
    return MockOS.FIXED_INFO.tmpdir;
  }

  /**
   *
   */
  static userInfo() {
    return { ...MockOS.FIXED_INFO.userInfo };
  }
}

/**
 * I/O TEST DOUBLES
 * Replace filesystem operations with deterministic alternatives
 */

/**
 *
 */
export class MockFS {
  static sortFiles = true;
  static fixedFiles = new Map();

  /**
   *
   */
  static async readdir(path, _options = {}) {
    // Simulate async operation
    await new Promise(resolve => setTimeout(resolve, 0));

    const files = MockFS.fixedFiles.get(path) || [
      'file-a.js',
      'file-b.js',
      'file-c.js'
    ];

    return MockFS.sortFiles ? files.sort() : files;
  }

  /**
   *
   */
  static async readFile(path, _encoding = 'utf8') {
    await new Promise(resolve => setTimeout(resolve, 0));

    const content = MockFS.fixedFiles.get(`content:${path}`) ||
      `// Mock file content for ${path}\nexport default 'deterministic content';`;

    return content;
  }

  /**
   *
   */
  static setFixedFiles(path, files) {
    MockFS.fixedFiles.set(path, files);
  }

  /**
   *
   */
  static setFixedContent(path, content) {
    MockFS.fixedFiles.set(`content:${path}`, content);
  }

  /**
   *
   */
  static reset() {
    MockFS.fixedFiles.clear();
    MockFS.sortFiles = true;
  }
}

/**
 *
 */
export class MockGlob {
  static patterns = new Map();

  /**
   *
   */
  static async glob(pattern, _options = {}) {
    await new Promise(resolve => setTimeout(resolve, 0));

    const matches = MockGlob.patterns.get(pattern) || [
      `match1-${pattern}`,
      `match2-${pattern}`,
      `match3-${pattern}`
    ];

    return matches.sort(); // Always sorted for determinism
  }

  /**
   *
   */
  static setFixedMatches(pattern, matches) {
    MockGlob.patterns.set(pattern, matches);
  }

  /**
   *
   */
  static reset() {
    MockGlob.patterns.clear();
  }
}

/**
 * NETWORK TEST DOUBLES
 * Replace network operations with deterministic responses
 */

/**
 *
 */
export class MockFetch {
  static responses = new Map();
  static defaultResponse = {
    ok: true,
    status: 200,
    statusText: 'OK',
    json: async () => ({ message: 'deterministic response' }),
    text: async () => 'deterministic text response'
  };

  /**
   *
   */
  static async fetch(url, options = {}) {
    await new Promise(resolve => setTimeout(resolve, 10)); // Simulate network delay

    const key = `${options.method || 'GET'} ${url}`;
    const response = MockFetch.responses.get(key) || MockFetch.defaultResponse;

    return {
      ...response,
      url,
      options: { ...options }
    };
  }

  /**
   *
   */
  static setResponse(method, url, response) {
    const key = `${method} ${url}`;
    MockFetch.responses.set(key, response);
  }

  /**
   *
   */
  static reset() {
    MockFetch.responses.clear();
  }
}

/**
 * COMPREHENSIVE TEST ENVIRONMENT SETUP
 * Replace all nondeterministic globals with deterministic alternatives
 */

/**
 *
 */
export class DeterministicTestEnvironment {
  /**
   *
   */
  constructor() {
    this.originalGlobals = {};
    this.idGenerator = new DeterministicIdGenerator();
    this.isActive = false;
  }

  /**
   *
   */
  activate() {
    if (this.isActive) return;

    // Store originals
    this.originalGlobals = {
      Date: global.Date,
      Math: global.Math,
      process: global.process,
      require: global.require
    };

    // Replace with deterministic versions
    global.Date = DeterministicDate;
    global.Math = new Proxy(Math, {
      get: (target, prop) => {
        if (prop === 'random') return MockMath.random;
        return target[prop];
      }
    });

    // Mock process.env access
    if (global.process) {
      const originalEnv = global.process.env;
      global.process.env = new Proxy(originalEnv, {
        get: (target, prop) => {
          return MockProcessEnv.get(prop) || target[prop];
        }
      });
    }

    this.isActive = true;
  }

  /**
   *
   */
  deactivate() {
    if (!this.isActive) return;

    // Restore originals
    Object.assign(global, this.originalGlobals);
    this.isActive = false;
  }

  /**
   *
   */
  reset() {
    MockMath.resetSeed();
    MockProcessEnv.reset();
    MockFS.reset();
    MockGlob.reset();
    MockFetch.reset();
    this.idGenerator.reset();
  }

  /**
   *
   */
  generateDeterministicData(schema) {
    const data = {};

    for (const [key, type] of Object.entries(schema)) {
      switch (type) {
        case 'id':
          data[key] = this.idGenerator.generateId(key);
          break;
        case 'uuid':
          data[key] = this.idGenerator.generateUUID(key);
          break;
        case 'timestamp':
          data[key] = DeterministicDate.FIXED_TIMESTAMP;
          break;
        case 'number':
          data[key] = MockMath.random() * 1000;
          break;
        case 'string':
          data[key] = `deterministic-${key}-${this.idGenerator.generateId(key)}`;
          break;
        default:
          data[key] = `${type}-${key}`;
      }
    }

    return data;
  }
}

/**
 * BDD-STYLE TEST HELPERS
 * Behavior-driven development helpers for deterministic testing
 */

/**
 *
 */
export class BDDTestHelpers {
  /**
   *
   */
  static createDeterministicFixture(name, schema) {
    const env = new DeterministicTestEnvironment();
    env.activate();

    const fixture = env.generateDeterministicData(schema);

    env.deactivate();

    return fixture;
  }

  /**
   *
   */
  static async verifyDeterministicBehavior(testFunction, iterations = 3) {
    const results = [];
    const env = new DeterministicTestEnvironment();

    for (let i = 0; i < iterations; i++) {
      env.activate();
      env.reset(); // Reset to same initial state

      const result = await testFunction();
      results.push(JSON.stringify(result, Object.keys(result).sort()));

      env.deactivate();
    }

    // All results should be identical
    const firstResult = results[0];
    const allIdentical = results.every(result => result === firstResult);

    if (!allIdentical) {
      throw new Error(`Nondeterministic behavior detected. Results: ${results.join(' | ')}`);
    }

    return JSON.parse(firstResult);
  }

  /**
   *
   */
  static createMockContext(overrides = {}) {
    return {
      metadata: {
        buildTime: DeterministicDate.FIXED_TIMESTAMP,
        targetPlatform: 'test-platform',
        ...overrides.metadata
      },
      config: {
        environment: 'test',
        targetHost: 'test-host',
        baseUrl: 'https://test.example.com',
        ...overrides.config
      },
      ...overrides
    };
  }
}

/**
 * EXPORT ALL TEST DOUBLES
 */

export const DeterministicTestDoubles = {
  // Temporal
  Date: DeterministicDate,
  Math: MockMath,

  // Environment
  ProcessEnv: MockProcessEnv,
  OS: MockOS,

  // I/O
  FS: MockFS,
  Glob: MockGlob,

  // Network
  Fetch: MockFetch,

  // Utilities
  IdGenerator: DeterministicIdGenerator,
  TestEnvironment: DeterministicTestEnvironment,
  BDDHelpers: BDDTestHelpers
};

export default DeterministicTestDoubles;