/**
 * KGEN Template Base Class - Foundation for all template types
 * 
 * Provides core functionality for template inheritance, composition, and validation
 * All template generators should extend this base class for consistency
 */

import crypto from 'crypto';
import { KGenTemplateEngine } from '../core/kgen-engine.js';
import { TemplateInheritanceEngine } from '../inheritance/index.js';

/**
 *
 */
export class KGenTemplateBase {
  /**
   *
   */
  constructor(options = {}) {
    this.options = {
      strictMode: options.strictMode !== false,
      deterministicMode: options.deterministicMode !== false,
      staticBuildTime: options.staticBuildTime || '2024-01-01T00:00:00.000Z',
      enableInheritance: options.enableInheritance !== false,
      enableValidation: options.enableValidation !== false,
      templateDir: options.templateDir || './templates',
      ...options
    };

    // Core engines
    this.engine = new KGenTemplateEngine(this.options);
    this.inheritanceEngine = new TemplateInheritanceEngine(this.options);
    
    // Template metadata
    this.metadata = {
      name: options.name || this.constructor.name,
      version: options.version || '1.0.0',
      description: options.description || 'KGEN Template',
      author: options.author || 'KGEN Generator',
      created: this.options.staticBuildTime,
      modified: this.options.staticBuildTime,
      namespace: options.namespace || 'kgen',
      category: options.category || 'base',
      tags: options.tags || [],
      dependencies: options.dependencies || [],
      extends: options.extends || null
    };

    // Template registry for inheritance
    this.templates = new Map();
    this.blocks = new Map();
    this.macros = new Map();
    
    // Validation rules
    this.validationRules = new Map();
    
    // Initialize base templates
    this.initializeBaseTemplates();
  }

  /**
   * Initialize base templates and blocks
   */
  initializeBaseTemplates() {
    // Base layout template
    this.registerTemplate('base.layout', `{%- block doctype -%}
<!DOCTYPE html>
{%- endblock -%}
{%- block html_attrs -%}
<html lang="{{ lang | default('en') }}">
{%- endblock -%}
{%- block head -%}
<head>
  {%- block meta -%}
  <meta charset="{{ charset | default('UTF-8') }}">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  {%- endblock -%}
  {%- block title -%}
  <title>{{ title | default('KGEN Generated') }}</title>
  {%- endblock -%}
  {%- block styles -%}
  {%- endblock -%}
</head>
{%- endblock -%}
{%- block body -%}
<body>
  {%- block content -%}
  <!-- Content goes here -->
  {%- endblock -%}
  {%- block scripts -%}
  {%- endblock -%}
</body>
{%- endblock -%}
</html>`);

    // Base component template
    this.registerTemplate('base.component', `{%- set componentName = name | default('Component') -%}
{%- set componentId = componentName | lower | replace(' ', '-') -%}
{%- block wrapper -%}
<div id="{{ componentId }}" class="{{ cssClass | default('kgen-component') }}">
  {%- block header -%}
  {%- if title -%}
  <header class="component-header">
    <h3>{{ title }}</h3>
  </header>
  {%- endif -%}
  {%- endblock -%}
  
  {%- block content -%}
  <div class="component-content">
    {{ content | default('<!-- Component content -->') }}
  </div>
  {%- endblock -%}
  
  {%- block footer -%}
  {%- if showFooter -%}
  <footer class="component-footer">
    {{ footerContent | default('') }}
  </footer>
  {%- endif -%}
  {%- endblock -%}
</div>
{%- endblock -%}`);

    // Base module template
    this.registerTemplate('base.module', `{%- set moduleName = name | default('Module') -%}
/**
 * {{ moduleName }} - Generated by KGEN
 * 
 * {%- if description %}
 * {{ description }}
 * {%- endif %}
 * 
 * @generated {{ __kgen.renderTime }}
 */

{%- block imports -%}
{%- for import in imports | default([]) %}
import {{ import.name }}{{ import.from ? ' from ' + import.from : '' }};
{%- endfor -%}
{%- endblock -%}

{%- block constants -%}
{%- for constant in constants | default([]) %}
const {{ constant.name }} = {{ constant.value | json }};
{%- endfor -%}
{%- endblock -%}

{%- block main -%}
export class {{ moduleName }} {
  constructor(options = {}) {
    this.options = { ...options };
  }
  
  {%- block methods -%}
  {%- for method in methods | default([]) %}
  
  {{ method.name }}({{ method.params | default('') }}) {
    {{ method.body | default('// Method implementation') }}
  }
  {%- endfor -%}
  {%- endblock -%}
}
{%- endblock -%}

{%- block exports -%}
export default {{ moduleName }};
{%- endblock -%}`);

    // Register base macros
    this.registerMacro('kgen_header', `{%- macro kgen_header(title, level=1) -%}
<h{{ level }}>{{ title }}</h{{ level }}>
{%- endmacro -%}`);

    this.registerMacro('kgen_timestamp', `{%- macro kgen_timestamp(format='iso') -%}
{%- if format == 'iso' -%}
{{ __kgen.renderTime }}
{%- else -%}
{{ __kgen.renderTime | formatDate(format) }}
{%- endif -%}
{%- endmacro -%}`);

    this.registerMacro('kgen_hash', `{%- macro kgen_hash(content) -%}
{{ content | hash | shortHash(8) }}
{%- endmacro -%}`);
  }

  /**
   * Register a template with the base class
   */
  registerTemplate(name, content, metadata = {}) {
    this.templates.set(name, {
      content,
      metadata: {
        name,
        registered: this.options.staticBuildTime,
        ...metadata
      }
    });
  }

  /**
   * Register a block for inheritance
   */
  registerBlock(name, content, metadata = {}) {
    this.blocks.set(name, {
      content,
      metadata: {
        name,
        registered: this.options.staticBuildTime,
        ...metadata
      }
    });
  }

  /**
   * Register a macro for reuse
   */
  registerMacro(name, content, metadata = {}) {
    this.macros.set(name, {
      content,
      metadata: {
        name,
        registered: this.options.staticBuildTime,
        ...metadata
      }
    });
  }

  /**
   * Register validation rule
   */
  registerValidationRule(name, rule) {
    this.validationRules.set(name, rule);
  }

  /**
   * Generate template from registered template
   */
  async generateFromTemplate(templateName, context = {}, _options = {}) {
    if (!this.templates.has(templateName)) {
      throw new Error(`Template '${templateName}' not found`);
    }

    const template = this.templates.get(templateName);
    const mergedContext = {
      ...context,
      __template: {
        name: templateName,
        metadata: template.metadata
      }
    };

    return await this.engine.execute(template.content, mergedContext);
  }

  /**
   * Generate with inheritance processing
   */
  async generateWithInheritance(templatePath, context = {}, options = {}) {
    if (!this.options.enableInheritance) {
      return await this.engine.execute(templatePath, context);
    }

    const result = await this.inheritanceEngine.processTemplate(templatePath, context, options);
    
    if (!result.compiled || !result.compiled.content) {
      throw new Error(`Failed to process inheritance for ${templatePath}`);
    }

    return {
      success: true,
      content: result.compiled.content,
      metadata: result.metadata,
      dependencies: result.dependencies,
      hash: result.hash
    };
  }

  /**
   * Validate generated content
   */
  async validateContent(content, rules = []) {
    if (!this.options.enableValidation) {
      return { valid: true, errors: [] };
    }

    const errors = [];
    const rulesToApply = rules.length > 0 ? rules : Array.from(this.validationRules.keys());

    for (const ruleName of rulesToApply) {
      const rule = this.validationRules.get(ruleName);
      if (rule) {
        try {
          const result = await rule(content);
          if (!result.valid) {
            errors.push({
              rule: ruleName,
              message: result.message,
              line: result.line,
              column: result.column
            });
          }
        } catch (error) {
          errors.push({
            rule: ruleName,
            message: `Validation rule failed: ${error.message}`
          });
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors,
      rulesApplied: rulesToApply.length
    };
  }

  /**
   * Get template metadata
   */
  getMetadata() {
    return {
      ...this.metadata,
      templates: Array.from(this.templates.keys()),
      blocks: Array.from(this.blocks.keys()),
      macros: Array.from(this.macros.keys()),
      validationRules: Array.from(this.validationRules.keys())
    };
  }

  /**
   * Generate deterministic hash for template
   */
  generateTemplateHash(content, context = {}) {
    const hashData = {
      content,
      context: Object.keys(context).sort(),
      metadata: this.metadata,
      templates: Array.from(this.templates.keys()).sort(),
      timestamp: this.options.staticBuildTime
    };
    
    return crypto.createHash('sha256')
      .update(JSON.stringify(hashData), 'utf8')
      .digest('hex');
  }

  /**
   * Clone template base with new options
   */
  clone(newOptions = {}) {
    const cloned = new this.constructor({
      ...this.options,
      ...newOptions
    });
    
    // Copy registered templates
    for (const [name, template] of this.templates) {
      cloned.templates.set(name, { ...template });
    }
    
    for (const [name, block] of this.blocks) {
      cloned.blocks.set(name, { ...block });
    }
    
    for (const [name, macro] of this.macros) {
      cloned.macros.set(name, { ...macro });
    }
    
    for (const [name, rule] of this.validationRules) {
      cloned.validationRules.set(name, rule);
    }
    
    return cloned;
  }

  /**
   * Get template statistics
   */
  getStats() {
    return {
      templates: this.templates.size,
      blocks: this.blocks.size,
      macros: this.macros.size,
      validationRules: this.validationRules.size,
      options: this.options,
      metadata: this.metadata
    };
  }
}

export default KGenTemplateBase;