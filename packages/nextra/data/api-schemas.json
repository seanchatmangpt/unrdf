{
  "@unrdf/core": [
    {
      "name": "DiffTripleSchema",
      "type": "object",
      "jsdoc": "@file RDF graph and ontology diff utilities for UNRDF.\n  @module diff\n \n\nimport { z } from 'zod';\n\n\n  @typedef {import('n3').Quad} Quad\n  @typedef {import('n3').Store} Store\n \n\n\n  Minimal RDF/JS store-like interface.\n  N3.Store conforms to this.\n \n  @typedef {Object} RdfStoreLike\n  @property {function(...any): Quad[]} getQuads\n \n\n\n  A simple triple representation used for diffs.\n \n  @typedef {Object} DiffTriple\n  @property {string} subject\n  @property {string} predicate\n  @property {string} object\n \n\n\n  Triple-level graph diff.\n \n  @typedef {Object} GraphDiff\n  @property {DiffTriple[]} added\n  @property {DiffTriple[]} removed\n \n\n\n  Ontology-level change description.\n \n  @typedef {Object} OntologyChange\n  @property {string} kind          - Application-level change kind, e.g. 'FeatureAdded', 'RoleRemoved'\n  @property {string} [entity]      - IRI or identifier of the entity/feature\n  @property {string} [role]        - Role name, e.g. 'hasService', 'hasTest'\n  @property {any} [details]        - Optional structured details for UIs / logs\n \n\n\n  Combined graph + ontology diff.\n \n  @typedef {Object} OntologyDiff\n  @property {GraphDiff} triples\n  @property {OntologyChange[]} changes\n \n\n\n  Ontology lens: maps low-level triple changes to ontology-level changes.\n \n  @callback OntologyLensFn\n  @param {DiffTriple} triple\n  @param {'added' | 'removed'} direction\n  @returns {OntologyChange | null}\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const DiffTripleSchema = z.object({\n  subject: z.string(),\n  predicate: z.string(),\n  object: z.string(),\n});",
      "sourceFile": "/packages/core/src/diff.mjs",
      "line": 69
    },
    {
      "name": "GraphDiffSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const GraphDiffSchema = z.object({\n  added: z.array(DiffTripleSchema),\n  removed: z.array(DiffTripleSchema),\n});",
      "sourceFile": "/packages/core/src/diff.mjs",
      "line": 75
    },
    {
      "name": "OntologyDiffSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const OntologyDiffSchema = z.object({\n  triples: GraphDiffSchema,\n  changes: z.array(OntologyChangeSchema),\n});",
      "sourceFile": "/packages/core/src/diff.mjs",
      "line": 88
    },
    {
      "name": "DeltaLikeSchema",
      "type": "object",
      "jsdoc": "@file RDF graph and ontology diff utilities for UNRDF.\n  @module diff\n \n\nimport { z } from 'zod';\n\n\n  @typedef {import('n3').Quad} Quad\n  @typedef {import('n3').Store} Store\n \n\n\n  Minimal RDF/JS store-like interface.\n  N3.Store conforms to this.\n \n  @typedef {Object} RdfStoreLike\n  @property {function(...any): Quad[]} getQuads\n \n\n\n  A simple triple representation used for diffs.\n \n  @typedef {Object} DiffTriple\n  @property {string} subject\n  @property {string} predicate\n  @property {string} object\n \n\n\n  Triple-level graph diff.\n \n  @typedef {Object} GraphDiff\n  @property {DiffTriple[]} added\n  @property {DiffTriple[]} removed\n \n\n\n  Ontology-level change description.\n \n  @typedef {Object} OntologyChange\n  @property {string} kind          - Application-level change kind, e.g. 'FeatureAdded', 'RoleRemoved'\n  @property {string} [entity]      - IRI or identifier of the entity/feature\n  @property {string} [role]        - Role name, e.g. 'hasService', 'hasTest'\n  @property {any} [details]        - Optional structured details for UIs / logs\n \n\n\n  Combined graph + ontology diff.\n \n  @typedef {Object} OntologyDiff\n  @property {GraphDiff} triples\n  @property {OntologyChange[]} changes\n \n\n\n  Ontology lens: maps low-level triple changes to ontology-level changes.\n \n  @callback OntologyLensFn\n  @param {DiffTriple} triple\n  @param {'added' | 'removed'} direction\n  @returns {OntologyChange | null}\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ ========================================================================= \n\nexport const DiffTripleSchema = z.object({\n  subject: z.string(),\n  predicate: z.string(),\n  object: z.string(),\n});\n\nexport const GraphDiffSchema = z.object({\n  added: z.array(DiffTripleSchema),\n  removed: z.array(DiffTripleSchema),\n});\n\nexport const OntologyChangeSchema = z\n  .object({\n    kind: z.string(),\n    entity: z.string().optional(),\n    role: z.string().optional(),\n  })\n  .passthrough();\n\nexport const OntologyDiffSchema = z.object({\n  triples: GraphDiffSchema,\n  changes: z.array(OntologyChangeSchema),\n});\n\n\n  Local Quad-like schema for deltas.\n  This intentionally mirrors N3 / RDF-JS shape without importing your global schemas.\n \nconst QuadLikeSchema = z.object({\n  subject: z.object({ value: z.string() }),\n  predicate: z.object({ value: z.string() }),\n  object: z.object({ value: z.string() }),\n  graph: z.object({ value: z.string() }).optional(),\n});\n\n\n  Local Delta schema (additions/removals of quads).\n  You can swap this with your global DeltaSchema if desired.",
      "definition": "export const DeltaLikeSchema = z.object({\n  additions: z.array(QuadLikeSchema),\n  removals: z.array(QuadLikeSchema),\n});",
      "sourceFile": "/packages/core/src/diff.mjs",
      "line": 108
    },
    {
      "name": "QuadSchema",
      "type": "object",
      "jsdoc": "@file Validation utilities module\n  @module @unrdf/core/validation\n \n\nimport { z } from 'zod';\n\n\n  Quad schema for validation",
      "definition": "export const QuadSchema = z.object({\n  subject: z.object({ value: z.string() }),\n  predicate: z.object({ value: z.string() }),\n  object: z.object({ value: z.string() }),\n  graph: z.object({ value: z.s",
      "sourceFile": "/packages/core/src/validation/index.mjs",
      "line": 11
    },
    {
      "name": "StoreSchema",
      "type": "object",
      "jsdoc": "@file Validation utilities module\n  @module @unrdf/core/validation\n \n\nimport { z } from 'zod';\n\n\n  Quad schema for validation\n \nexport const QuadSchema = z.object({\n  subject: z.object({ value: z.string() }),\n  predicate: z.object({ value: z.string() }),\n  object: z.object({ value: z.string() }),\n  graph: z.object({ value: z.string() }).optional(),\n});\n\n\n  Store schema for validation",
      "definition": "export const StoreSchema = z.object({\n  getQuads: z.function(),\n  addQuad: z.function().optional(),\n  removeQuad: z.function().optional(),\n  countQuads: z.function().optional(),\n});",
      "sourceFile": "/packages/core/src/validation/index.mjs",
      "line": 21
    },
    {
      "name": "IRISchema",
      "type": "string",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs",
      "definition": "export const IRISchema = z.string().url();",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 18
    },
    {
      "name": "LiteralSchema",
      "type": "object",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs\n \nexport const IRISchema = z.string().url();\n\n\n  Zod schema for validating RDF literals",
      "definition": "export const LiteralSchema = z.object({\n  termType: z.literal('Literal'),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 23
    },
    {
      "name": "NamedNodeSchema",
      "type": "object",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs\n \nexport const IRISchema = z.string().url();\n\n\n  Zod schema for validating RDF literals\n \nexport const LiteralSchema = z.object({\n  termType: z.literal('Literal'),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});\n\n\n  Zod schema for validating RDF named nodes",
      "definition": "export const NamedNodeSchema = z.object({\n  termType: z.literal('NamedNode'),\n  value: z.string().url(),\n});",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 33
    },
    {
      "name": "BlankNodeSchema",
      "type": "object",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs\n \nexport const IRISchema = z.string().url();\n\n\n  Zod schema for validating RDF literals\n \nexport const LiteralSchema = z.object({\n  termType: z.literal('Literal'),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});\n\n\n  Zod schema for validating RDF named nodes\n \nexport const NamedNodeSchema = z.object({\n  termType: z.literal('NamedNode'),\n  value: z.string().url(),\n});\n\n\n  Zod schema for validating RDF blank nodes",
      "definition": "export const BlankNodeSchema = z.object({\n  termType: z.literal('BlankNode'),\n  value: z.string(),\n});",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 41
    },
    {
      "name": "TermSchema",
      "type": "union",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs\n \nexport const IRISchema = z.string().url();\n\n\n  Zod schema for validating RDF literals\n \nexport const LiteralSchema = z.object({\n  termType: z.literal('Literal'),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});\n\n\n  Zod schema for validating RDF named nodes\n \nexport const NamedNodeSchema = z.object({\n  termType: z.literal('NamedNode'),\n  value: z.string().url(),\n});\n\n\n  Zod schema for validating RDF blank nodes\n \nexport const BlankNodeSchema = z.object({\n  termType: z.literal('BlankNode'),\n  value: z.string(),\n});\n\n\n  Zod schema for validating RDF terms",
      "definition": "export const TermSchema = z.union([LiteralSchema, NamedNodeSchema, BlankNodeSchema]);",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 49
    },
    {
      "name": "QuadSchema",
      "type": "object",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs\n \nexport const IRISchema = z.string().url();\n\n\n  Zod schema for validating RDF literals\n \nexport const LiteralSchema = z.object({\n  termType: z.literal('Literal'),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});\n\n\n  Zod schema for validating RDF named nodes\n \nexport const NamedNodeSchema = z.object({\n  termType: z.literal('NamedNode'),\n  value: z.string().url(),\n});\n\n\n  Zod schema for validating RDF blank nodes\n \nexport const BlankNodeSchema = z.object({\n  termType: z.literal('BlankNode'),\n  value: z.string(),\n});\n\n\n  Zod schema for validating RDF terms\n \nexport const TermSchema = z.union([LiteralSchema, NamedNodeSchema, BlankNodeSchema]);\n\n\n  Zod schema for validating RDF quads",
      "definition": "export const QuadSchema = z.object({\n  subject: TermSchema,\n  predicate: NamedNodeSchema,\n  object: TermSchema,\n  graph: TermSchema.optional(),\n});",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 54
    },
    {
      "name": "QuadJSONSchema",
      "type": "object",
      "jsdoc": "@fileoverview Validation utilities - RDF validation helpers\n \n  These utilities cover the 80/20 dark matter of RDF validation\n  that every project ends up reimplementing.\n \n  @version 1.0.0\n  @author GitVan Team\n  @license MIT\n \n\nimport { z } from 'zod';\nimport { asNamedNode } from './term-utils.mjs';\n\n\n  Zod schema for validating RDF IRIs\n \nexport const IRISchema = z.string().url();\n\n\n  Zod schema for validating RDF literals\n \nexport const LiteralSchema = z.object({\n  termType: z.literal('Literal'),\n  value: z.string(),\n  language: z.string().optional(),\n  datatype: z.object({ value: z.string() }).optional(),\n});\n\n\n  Zod schema for validating RDF named nodes\n \nexport const NamedNodeSchema = z.object({\n  termType: z.literal('NamedNode'),\n  value: z.string().url(),\n});\n\n\n  Zod schema for validating RDF blank nodes\n \nexport const BlankNodeSchema = z.object({\n  termType: z.literal('BlankNode'),\n  value: z.string(),\n});\n\n\n  Zod schema for validating RDF terms\n \nexport const TermSchema = z.union([LiteralSchema, NamedNodeSchema, BlankNodeSchema]);\n\n\n  Zod schema for validating RDF quads\n \nexport const QuadSchema = z.object({\n  subject: TermSchema,\n  predicate: NamedNodeSchema,\n  object: TermSchema,\n  graph: TermSchema.optional(),\n});\n\n\n  Zod schema for validating quad JSON representation",
      "definition": "export const QuadJSONSchema = z.object({\n  subject: z.string().url(),\n  predicate: z.string().url(),\n  object: z.string(),\n  graph: z.string().url().nullable().optional(),\n});",
      "sourceFile": "/packages/core/src/utils/validation-utils.mjs",
      "line": 64
    }
  ],
  "@unrdf/domain": [
    {
      "name": "PaperFamilySchema",
      "type": "enum",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}",
      "definition": "export const PaperFamilySchema = z.enum(/** @type {[string, ...string[]]} */ (PAPER_FAMILY_NAMES));",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 18
    },
    {
      "name": "ThesisTypeSchema",
      "type": "enum",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}",
      "definition": "export const ThesisTypeSchema = z.enum(/** @type {[string, ...string[]]} */ (THESIS_TYPE_NAMES));",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 24
    },
    {
      "name": "OutputFormatSchema",
      "type": "enum",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}",
      "definition": "export const OutputFormatSchema = z.enum(\n  /** @type {[string, ...string[]]} */ (OUTPUT_FORMAT_NAMES)\n);",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 30
    },
    {
      "name": "ShellTypeSchema",
      "type": "enum",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}\n \nexport const OutputFormatSchema = z.enum(\n   @type {[string, ...string[]]}  (OUTPUT_FORMAT_NAMES)\n);\n\n\n  Shell type schema\n  @type {import('zod').ZodEnum<['bash', 'zsh', 'fish', 'powershell']>}",
      "definition": "export const ShellTypeSchema = z.enum(/** @type {[string, ...string[]]} */ (SHELL_TYPE_NAMES));",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 38
    },
    {
      "name": "SectionSchema",
      "type": "object",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}\n \nexport const OutputFormatSchema = z.enum(\n   @type {[string, ...string[]]}  (OUTPUT_FORMAT_NAMES)\n);\n\n\n  Shell type schema\n  @type {import('zod').ZodEnum<['bash', 'zsh', 'fish', 'powershell']>}\n \nexport const ShellTypeSchema = z.enum( @type {[string, ...string[]]}  (SHELL_TYPE_NAMES));\n\n\n  Section schema for paper/thesis sections",
      "definition": "export const SectionSchema = z.object({\n  name: z.string().min(1),\n  content: z.string().optional(),\n  order: z.number().int().nonnegative().optional(),\n});",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 43
    },
    {
      "name": "PaperSchema",
      "type": "object",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}\n \nexport const OutputFormatSchema = z.enum(\n   @type {[string, ...string[]]}  (OUTPUT_FORMAT_NAMES)\n);\n\n\n  Shell type schema\n  @type {import('zod').ZodEnum<['bash', 'zsh', 'fish', 'powershell']>}\n \nexport const ShellTypeSchema = z.enum( @type {[string, ...string[]]}  (SHELL_TYPE_NAMES));\n\n\n  Section schema for paper/thesis sections\n \nexport const SectionSchema = z.object({\n  name: z.string().min(1),\n  content: z.string().optional(),\n  order: z.number().int().nonnegative().optional(),\n});\n\n\n  Paper schema for validation",
      "definition": "export const PaperSchema = z.object({\n  family: PaperFamilySchema,\n  title: z.string().optional(),\n  abstract: z.string().optional(),\n  sections: z.array(z.string()).optional(),\n  metadata: z.record(z",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 52
    },
    {
      "name": "ScheduleItemSchema",
      "type": "object",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}\n \nexport const OutputFormatSchema = z.enum(\n   @type {[string, ...string[]]}  (OUTPUT_FORMAT_NAMES)\n);\n\n\n  Shell type schema\n  @type {import('zod').ZodEnum<['bash', 'zsh', 'fish', 'powershell']>}\n \nexport const ShellTypeSchema = z.enum( @type {[string, ...string[]]}  (SHELL_TYPE_NAMES));\n\n\n  Section schema for paper/thesis sections\n \nexport const SectionSchema = z.object({\n  name: z.string().min(1),\n  content: z.string().optional(),\n  order: z.number().int().nonnegative().optional(),\n});\n\n\n  Paper schema for validation\n \nexport const PaperSchema = z.object({\n  family: PaperFamilySchema,\n  title: z.string().optional(),\n  abstract: z.string().optional(),\n  sections: z.array(z.string()).optional(),\n  metadata: z.record(z.unknown()).optional(),\n  createdAt: z.string().datetime().optional(),\n  updatedAt: z.string().datetime().optional(),\n});\n\n\n  Schedule item schema for thesis timeline",
      "definition": "export const ScheduleItemSchema = z.object({\n  milestone: z.string().min(1),\n  dueDate: z.string(),\n  completed: z.boolean().default(false),\n  notes: z.string().optional(),\n});",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 65
    },
    {
      "name": "ThesisSchema",
      "type": "object",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}\n \nexport const OutputFormatSchema = z.enum(\n   @type {[string, ...string[]]}  (OUTPUT_FORMAT_NAMES)\n);\n\n\n  Shell type schema\n  @type {import('zod').ZodEnum<['bash', 'zsh', 'fish', 'powershell']>}\n \nexport const ShellTypeSchema = z.enum( @type {[string, ...string[]]}  (SHELL_TYPE_NAMES));\n\n\n  Section schema for paper/thesis sections\n \nexport const SectionSchema = z.object({\n  name: z.string().min(1),\n  content: z.string().optional(),\n  order: z.number().int().nonnegative().optional(),\n});\n\n\n  Paper schema for validation\n \nexport const PaperSchema = z.object({\n  family: PaperFamilySchema,\n  title: z.string().optional(),\n  abstract: z.string().optional(),\n  sections: z.array(z.string()).optional(),\n  metadata: z.record(z.unknown()).optional(),\n  createdAt: z.string().datetime().optional(),\n  updatedAt: z.string().datetime().optional(),\n});\n\n\n  Schedule item schema for thesis timeline\n \nexport const ScheduleItemSchema = z.object({\n  milestone: z.string().min(1),\n  dueDate: z.string(),\n  completed: z.boolean().default(false),\n  notes: z.string().optional(),\n});\n\n\n  Thesis schema for validation",
      "definition": "export const ThesisSchema = z.object({\n  type: ThesisTypeSchema,\n  title: z.string().optional(),\n  schedule: z.array(ScheduleItemSchema).optional(),\n  defenseDate: z.string().optional(),\n  sections: z",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 75
    },
    {
      "name": "ConfigSchema",
      "type": "object",
      "jsdoc": "Zod schemas for domain type validation\n  @module domain/types\n \n\nimport { z } from 'zod';\nimport {\n  PAPER_FAMILY_NAMES,\n  THESIS_TYPE_NAMES,\n  OUTPUT_FORMAT_NAMES,\n  SHELL_TYPE_NAMES,\n} from './constants.mjs';\n\n\n  Paper family schema\n  @type {import('zod').ZodEnum<['IMRaD', 'Argument', 'Contribution', 'DSR', 'Monograph', 'Narrative']>}\n \nexport const PaperFamilySchema = z.enum( @type {[string, ...string[]]}  (PAPER_FAMILY_NAMES));\n\n\n  Thesis type schema\n  @type {import('zod').ZodEnum<['Masters', 'PhD', 'Postdoctoral', 'MBA', 'Professional']>}\n \nexport const ThesisTypeSchema = z.enum( @type {[string, ...string[]]}  (THESIS_TYPE_NAMES));\n\n\n  Output format schema\n  @type {import('zod').ZodEnum<['json', 'json-pretty', 'yaml', 'table']>}\n \nexport const OutputFormatSchema = z.enum(\n   @type {[string, ...string[]]}  (OUTPUT_FORMAT_NAMES)\n);\n\n\n  Shell type schema\n  @type {import('zod').ZodEnum<['bash', 'zsh', 'fish', 'powershell']>}\n \nexport const ShellTypeSchema = z.enum( @type {[string, ...string[]]}  (SHELL_TYPE_NAMES));\n\n\n  Section schema for paper/thesis sections\n \nexport const SectionSchema = z.object({\n  name: z.string().min(1),\n  content: z.string().optional(),\n  order: z.number().int().nonnegative().optional(),\n});\n\n\n  Paper schema for validation\n \nexport const PaperSchema = z.object({\n  family: PaperFamilySchema,\n  title: z.string().optional(),\n  abstract: z.string().optional(),\n  sections: z.array(z.string()).optional(),\n  metadata: z.record(z.unknown()).optional(),\n  createdAt: z.string().datetime().optional(),\n  updatedAt: z.string().datetime().optional(),\n});\n\n\n  Schedule item schema for thesis timeline\n \nexport const ScheduleItemSchema = z.object({\n  milestone: z.string().min(1),\n  dueDate: z.string(),\n  completed: z.boolean().default(false),\n  notes: z.string().optional(),\n});\n\n\n  Thesis schema for validation\n \nexport const ThesisSchema = z.object({\n  type: ThesisTypeSchema,\n  title: z.string().optional(),\n  schedule: z.array(ScheduleItemSchema).optional(),\n  defenseDate: z.string().optional(),\n  sections: z.array(z.string()).optional(),\n  committee: z.array(z.string()).optional(),\n  metadata: z.record(z.unknown()).optional(),\n  createdAt: z.string().datetime().optional(),\n  updatedAt: z.string().datetime().optional(),\n});\n\n\n  Config schema for configuration values",
      "definition": "export const ConfigSchema = z.object({\n  outputFormat: OutputFormatSchema.default('json'),\n  shell: ShellTypeSchema.optional(),\n  verbose: z.boolean().default(false),\n  color: z.boolean().default(true",
      "sourceFile": "/packages/domain/src/types.mjs",
      "line": 90
    }
  ],
  "@unrdf/federation": [
    {
      "name": "PeerConfigSchema",
      "type": "object",
      "jsdoc": "@file Peer Manager - Registration and health tracking for federation peers\n  @module federation/peer-manager\n \n\nimport { z } from 'zod';\n\n\n  @typedef {Object} PeerInfo\n  @property {string} id - Unique peer identifier\n  @property {string} endpoint - HTTP endpoint URL for the peer\n  @property {number} registeredAt - Timestamp when peer was registered\n  @property {number} lastSeen - Timestamp of last successful health check\n  @property {'healthy' | 'degraded' | 'unreachable'} status - Current health status\n  @property {Object} [metadata] - Optional peer metadata\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const PeerConfigSchema = z.object({\n  id: z.string().min(1, 'Peer ID must not be empty'),\n  endpoint: z.string().url('Peer endpoint must be a valid URL'),\n  metadata: z.record(z.any()).optional",
      "sourceFile": "/packages/federation/src/federation/peer-manager.mjs",
      "line": 22
    },
    {
      "name": "QueryConfigSchema",
      "type": "object",
      "jsdoc": "@file Distributed Query Engine - Execute SPARQL queries across federated peers\n  @module federation/distributed-query\n \n\nimport { z } from 'zod';\n\n\n  @typedef {Object} QueryResult\n  @property {boolean} success - Whether the query succeeded\n  @property {any} data - Query result data\n  @property {string} [error] - Error message if query failed\n  @property {number} duration - Query execution time in milliseconds\n  @property {string} peerId - Peer that executed the query\n \n\n\n  @typedef {Object} AggregatedResult\n  @property {boolean} success - Whether aggregation succeeded\n  @property {any[]} results - Combined results from all peers\n  @property {QueryResult[]} peerResults - Individual peer results\n  @property {number} totalDuration - Total execution time\n  @property {number} successCount - Number of successful queries\n  @property {number} failureCount - Number of failed queries\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const QueryConfigSchema = z.object({\n  sparql: z.string().min(1, 'SPARQL query must not be empty'),\n  timeout: z.number().positive().optional().default(30000),\n  format: z.enum(['json', 'xml', ",
      "sourceFile": "/packages/federation/src/federation/distributed-query.mjs",
      "line": 31
    },
    {
      "name": "QueryResultSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const QueryResultSchema = z.object({\n  success: z.boolean(),\n  data: z.any(),\n  error: z.string().optional(),\n  duration: z.number(),\n  peerId: z.string(),\n});",
      "sourceFile": "/packages/federation/src/federation/distributed-query.mjs",
      "line": 37
    },
    {
      "name": "CoordinatorConfigSchema",
      "type": "object",
      "jsdoc": "@file Federation Coordinator - Orchestrate distributed queries across peers\n  @module federation/coordinator\n \n\nimport { z } from 'zod';\nimport { createPeerManager } from './peer-manager.mjs';\nimport {\n  executeDistributedQuery,\n  executeFederatedQuery,\n  routeQuery,\n} from './distributed-query.mjs';\n\n\n  @typedef {Object} CoordinatorConfig\n  @property {Array<{id: string, endpoint: string, metadata?: Object}>} [peers] - Initial peers\n  @property {'broadcast' | 'selective' | 'first-available'} [strategy='broadcast'] - Query routing strategy\n  @property {number} [timeout=30000] - Default query timeout in milliseconds\n  @property {number} [healthCheckInterval=60000] - Health check interval in milliseconds\n \n\n\n  @typedef {Object} FederationCoordinator\n  @property {function(string, string, Object=): Promise} addPeer - Add a peer to the federation\n  @property {function(string): boolean} removePeer - Remove a peer from the federation\n  @property {function(string): Object | null} getPeer - Get peer information\n  @property {function(Object=): Array} listPeers - List all peers\n  @property {function(string, Object=): Promise} query - Execute a federated query\n  @property {function(string, string, Object=): Promise} queryPeer - Query a specific peer\n  @property {function(): Promise} healthCheck - Run health checks on all peers\n  @property {function(): void} startHealthChecks - Start periodic health checks\n  @property {function(): void} stopHealthChecks - Stop periodic health checks\n  @property {function(): Object} getStats - Get federation statistics\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const CoordinatorConfigSchema = z.object({\n  peers: z\n    .array(\n      z.object({\n        id: z.string(),\n        endpoint: z.string().url(),\n        metadata: z.record(z.any()).optional(),\n  ",
      "sourceFile": "/packages/federation/src/federation/coordinator.mjs",
      "line": 40
    }
  ],
  "@unrdf/hooks": [
    {
      "name": "SPCDataPointSchema",
      "type": "object",
      "jsdoc": "@file Lean Six Sigma Quality Metrics for Knowledge Hooks\n  @module hooks/quality-metrics\n \n  @description\n  Statistical process control and DMAIC workflow support for quality hooks:\n  - quality-gate: Enforce quality checkpoints (Control)\n  - defect-detection: Statistical outlier detection (Measure)\n  - continuous-improvement: Periodic optimization (Improve)\n  - spc-control: Statistical process control charts (Control)\n  - capability-analysis: Cp/Cpk metrics (Analyze)\n  - root-cause: 5 Whys automation (Analyze)\n  - kaizen-event: Improvement opportunity (Improve)\n  - audit-trail: Compliance logging (Define)\n \n\nimport { z } from 'zod';\n\n\n  @typedef {Object} QualityMetric\n  @property {string} name - Metric name\n  @property {number} value - Current value\n  @property {number} target - Target value\n  @property {number} ucl - Upper control limit\n  @property {number} lcl - Lower control limit\n  @property {string} unit - Unit of measure\n \n\n\n  @typedef {Object} DefectRecord\n  @property {string} id - Defect ID\n  @property {string} type - Defect type\n  @property {Date} timestamp - Detection time\n  @property {string} source - Source of defect\n  @property {string} severity - critical, major, minor\n  @property {object} context - Additional context\n \n\n\n  Quality gate configuration schema\n  POKA-YOKE: Validates operator-threshold compatibility at parse time\n \nexport const QualityGateSchema = z\n  .object({\n    name: z.string().min(1, 'Gate name is required'),\n    metric: z.string().min(1, 'Metric name is required'),\n    operator: z.enum(['gt', 'gte', 'lt', 'lte', 'eq', 'neq', 'between']),\n    threshold: z.number().or(z.array(z.number())),\n    severity: z.enum(['critical', 'major', 'minor']).default('major'),\n    action: z.enum(['block', 'warn', 'log']).default('block'),\n  })\n  .refine(\n    data => {\n      // POKA-YOKE: Operator-threshold mismatch guard (RPN 140 → 0)\n      if (data.operator === 'between') {\n        return Array.isArray(data.threshold) && data.threshold.length === 2;\n      }\n      return typeof data.threshold === 'number';\n    },\n    {\n      message:\n        \"Operator 'between' requires threshold as [min, max] array; other operators require a single number. \" +\n        \"Example: { operator: 'between', threshold: [10, 90] } or { operator: 'gt', threshold: 50 }\",\n    }\n  )\n  .refine(\n    data => {\n      // POKA-YOKE: Validate 'between' threshold order\n      if (data.operator === 'between' && Array.isArray(data.threshold)) {\n        return data.threshold[0] <= data.threshold[1];\n      }\n      return true;\n    },\n    {\n      message: \"For 'between' operator, threshold[0] (min) must be <= threshold[1] (max)\",\n    }\n  );\n\n\n  Statistical Process Control (SPC) data point",
      "definition": "export const SPCDataPointSchema = z.object({\n  timestamp: z.date().or(z.string().transform(s => new Date(s))),\n  value: z.number(),\n  subgroup: z.string().optional(),\n});",
      "sourceFile": "/packages/hooks/src/hooks/quality-metrics.mjs",
      "line": 82
    },
    {
      "name": "ScheduleConfigSchema",
      "type": "object",
      "jsdoc": "@file Hook Scheduler for Cron and Interval Triggers\n  @module hooks/hook-scheduler\n \n  @description\n  Event-driven scheduler for cron/time-based hook triggers:\n  - on-schedule: Cron-like scheduled execution\n  - on-interval: Periodic execution at fixed intervals\n  - on-idle: Execute during idle periods\n  - on-startup: Execute once at system startup\n \n\nimport { z } from 'zod';\n\n\n  @typedef {Object} ScheduledHook\n  @property {string} id - Unique scheduler entry ID\n  @property {import('./define-hook.mjs').Hook} hook - The hook to execute\n  @property {string} schedule - Cron expression or interval spec\n  @property {number} [interval] - Interval in milliseconds\n  @property {boolean} enabled - Whether the schedule is active\n  @property {Date} [lastRun] - Last execution timestamp\n  @property {Date} [nextRun] - Next scheduled execution\n  @property {number} runCount - Total execution count\n \n\n\n  Schedule configuration schema\n  POKA-YOKE: Interval bounds prevent CPU thrashing (RPN 168 → 0)",
      "definition": "export const ScheduleConfigSchema = z.object({\n  id: z.string().min(1),\n  hookId: z.string().min(1),\n  type: z.enum(['cron', 'interval', 'idle', 'startup']),\n  expression: z.string().optional(), // Cr",
      "sourceFile": "/packages/hooks/src/hooks/hook-scheduler.mjs",
      "line": 31
    },
    {
      "name": "HookRegistrySchema",
      "type": "object",
      "jsdoc": "@file Hook registry and management utilities for UNRDF Knowledge Hooks.\n  @module hooks/hook-management\n \n\nimport { z } from 'zod';\nimport { HookSchema } from './define-hook.mjs';\n\n\n  @typedef {import('./define-hook.mjs').Hook} Hook\n  @typedef {import('./define-hook.mjs').HookTrigger} HookTrigger\n \n\n\n  Hook registry for managing registered hooks.\n  @typedef {Object} HookRegistry\n  @property {Map<string, Hook>} hooks - Map of hook name to hook\n  @property {Map<HookTrigger, Set<string>>} triggerIndex - Index of trigger to hook names\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const HookRegistrySchema = z.object({\n  hooks: z.instanceof(Map),\n  triggerIndex: z.instanceof(Map),\n});",
      "sourceFile": "/packages/hooks/src/hooks/hook-management.mjs",
      "line": 25
    },
    {
      "name": "HookResultSchema",
      "type": "object",
      "jsdoc": "@file Hook execution utilities for UNRDF Knowledge Hooks.\n  @module hooks/hook-executor\n \n\nimport { z } from 'zod';\nimport { HookSchema, hasValidation, hasTransformation } from './define-hook.mjs';\n\n\n  @typedef {import('./define-hook.mjs').Hook} Hook\n  @typedef {import('n3').Quad} Quad\n \n\n\n  Hook execution result.\n  @typedef {Object} HookResult\n  @property {boolean} valid - Whether validation passed\n  @property {Quad} [quad] - Transformed quad (if transformation applied)\n  @property {string} [error] - Error message if validation failed\n  @property {string} hookName - Name of hook that executed\n \n\n\n  Hook chain execution result.\n  @typedef {Object} ChainResult\n  @property {boolean} valid - Whether all validations passed\n  @property {Quad} quad - Final transformed quad\n  @property {HookResult[]} results - Individual hook results\n  @property {string} [error] - Error message if any validation failed\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const HookResultSchema = z.object({\n  valid: z.boolean(),\n  quad: z.any().optional(),\n  error: z.string().optional(),\n  hookName: z.string(),\n});",
      "sourceFile": "/packages/hooks/src/hooks/hook-executor.mjs",
      "line": 36
    },
    {
      "name": "ChainResultSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const ChainResultSchema = z.object({\n  valid: z.boolean(),\n  quad: z.any(),\n  results: z.array(HookResultSchema),\n  error: z.string().optional(),\n});",
      "sourceFile": "/packages/hooks/src/hooks/hook-executor.mjs",
      "line": 43
    },
    {
      "name": "HookTriggerSchema",
      "type": "enum",
      "jsdoc": "@file Hook definition utilities for UNRDF Knowledge Hooks.\n  @module hooks/define-hook\n \n\nimport { z } from 'zod';\n\n\n  @typedef {import('n3').Quad} Quad\n \n\n\n  Hook trigger types.\n  @typedef {'before-add' | 'after-add' | 'before-query' | 'after-query' | 'before-remove' | 'after-remove'} HookTrigger\n \n\n\n  Validation function for hooks.\n  @callback ValidateFn\n  @param {Quad} quad - The quad to validate\n  @returns {boolean} - True if validation passes, false otherwise\n \n\n\n  Transformation function for hooks.\n  @callback TransformFn\n  @param {Quad} quad - The quad to transform\n  @returns {Quad} - The transformed quad\n \n\n\n  Hook definition configuration.\n  @typedef {Object} HookConfig\n  @property {string} name - Hook identifier\n  @property {HookTrigger} trigger - When to execute the hook\n  @property {ValidateFn} [validate] - Optional validation function\n  @property {TransformFn} [transform] - Optional transformation function\n  @property {Record<string, any>} [metadata] - Optional metadata\n \n\n\n  Defined hook with runtime state.\n  @typedef {Object} Hook\n  @property {string} name - Hook identifier\n  @property {HookTrigger} trigger - When to execute the hook\n  @property {ValidateFn} [validate] - Optional validation function\n  @property {TransformFn} [transform] - Optional transformation function\n  @property {Record<string, any>} [metadata] - Optional metadata\n \n\n/ ========================================================================= \n/ Zod Schemas                                                              \n/ =========================================================================",
      "definition": "export const HookTriggerSchema = z.enum([\n  // Core CRUD (6)\n  'before-add',\n  'after-add',\n  'before-query',\n  'after-query',\n  'before-remove',\n  'after-remove',\n  // Transaction Hooks (4)\n  'before",
      "sourceFile": "/packages/hooks/src/hooks/define-hook.mjs",
      "line": 55
    },
    {
      "name": "HookConfigSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const HookConfigSchema = z.object({\n  name: z.string().min(1, 'Hook name is required'),\n  trigger: HookTriggerSchema,\n  // Note: No return type enforcement - runtime POKA-YOKE guard handles non",
      "sourceFile": "/packages/hooks/src/hooks/define-hook.mjs",
      "line": 97
    },
    {
      "name": "HookSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const HookSchema = z.object({\n  name: z.string(),\n  trigger: HookTriggerSchema,\n  validate: z.function().optional(),\n  transform: z.function().optional(),\n  metadata: z.record(z.any()).optional",
      "sourceFile": "/packages/hooks/src/hooks/define-hook.mjs",
      "line": 106
    }
  ],
  "@unrdf/knowledge-engine": [
    {
      "name": "HookMetaSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata",
      "definition": "export const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 15
    },
    {
      "name": "FileRefSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references",
      "definition": "export const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .stri",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 39
    },
    {
      "name": "SparqlAskConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience",
      "definition": "export const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 58
    },
    {
      "name": "SparqlSelectConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience",
      "definition": "export const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeo",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 75
    },
    {
      "name": "ShaclConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience",
      "definition": "export const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 94
    },
    {
      "name": "DeltaConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions",
      "definition": "export const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    th",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 111
    },
    {
      "name": "ThresholdConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions",
      "definition": "export const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.numbe",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 130
    },
    {
      "name": "CountConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions",
      "definition": "export const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: ",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 149
    },
    {
      "name": "WindowConditionSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions",
      "definition": "export const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positi",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 167
    },
    {
      "name": "DeterminismSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration",
      "definition": "export const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 199
    },
    {
      "name": "ReceiptSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration",
      "definition": "export const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turt",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 208
    },
    {
      "name": "HookContextSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context",
      "definition": "export const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionI",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 220
    },
    {
      "name": "HookEventSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events",
      "definition": "export const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be ",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 231
    },
    {
      "name": "HookResultSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results",
      "definition": "export const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['befo",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 244
    },
    {
      "name": "HookChannelSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration",
      "definition": "export const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 267
    },
    {
      "name": "KnowledgeHookSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition",
      "definition": "export const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after:",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 275
    },
    {
      "name": "TransactionDeltaSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta",
      "definition": "export const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 292
    },
    {
      "name": "TransactionReceiptSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt",
      "definition": "export const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: ",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 303
    },
    {
      "name": "ObservabilityConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration",
      "definition": "export const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 336
    },
    {
      "name": "PerformanceMetricsSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics",
      "definition": "export const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 365
    },
    {
      "name": "ManagerConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration",
      "definition": "export const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  ",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 397
    },
    {
      "name": "FileResolverConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration",
      "definition": "export const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(360000",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 423
    },
    {
      "name": "ConditionEvaluatorConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration",
      "definition": "export const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 442
    },
    {
      "name": "HookExecutorConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration",
      "definition": "export const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.nu",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 454
    },
    {
      "name": "DeltaSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)",
      "definition": "export const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 729
    },
    {
      "name": "TransactionHookSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)",
      "definition": "export const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 737
    },
    {
      "name": "TransactionHookResultSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)",
      "definition": "export const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 747
    },
    {
      "name": "HashSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)",
      "definition": "export const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 757
    },
    {
      "name": "TransactionOptionsSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)",
      "definition": "export const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 782
    },
    {
      "name": "ManagerOptionsSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)",
      "definition": "export const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n ",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 791
    },
    {
      "name": "QueryPlanSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)",
      "definition": "export const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.arra",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 806
    },
    {
      "name": "IndexSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)",
      "definition": "export const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.nu",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 832
    },
    {
      "name": "DeltaAwareContextSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)",
      "definition": "export const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affecte",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 846
    },
    {
      "name": "AgentProposalSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)",
      "definition": "export const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: ",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 860
    },
    {
      "name": "ResolutionStrategySchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)",
      "definition": "export const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().i",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 879
    },
    {
      "name": "ResolutionResultSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)",
      "definition": "export const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any())",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 890
    },
    {
      "name": "SandboxConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)",
      "definition": "export const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .n",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 917
    },
    {
      "name": "SandboxContextSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)",
      "definition": "export const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEve",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 938
    },
    {
      "name": "SandboxResultSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)\n \nexport const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEvent', 'log', 'assert']),\n});\n\n\n  Schema for sandbox execution result (from effect-sandbox.mjs)",
      "definition": "export const SandboxResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative(),\n  memoryUsed: z.number().nonne",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 949
    },
    {
      "name": "LockchainEntrySchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)\n \nexport const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEvent', 'log', 'assert']),\n});\n\n\n  Schema for sandbox execution result (from effect-sandbox.mjs)\n \nexport const SandboxResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative(),\n  memoryUsed: z.number().nonnegative().optional(),\n  cpuUsed: z.number().nonnegative().optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n  events: z.array(z.any()).optional(),\n});\n\n\n  Schema for lockchain entries (from lockchain-writer.mjs)",
      "definition": "export const LockchainEntrySchema = z.object({\n  id: z.string().uuid(),\n  timestamp: z.number(),\n  receipt: z.any(), // Transaction receipt\n  signature: z.object({\n    algorithm: z.string(),\n    value",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 972
    },
    {
      "name": "LockchainConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)\n \nexport const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEvent', 'log', 'assert']),\n});\n\n\n  Schema for sandbox execution result (from effect-sandbox.mjs)\n \nexport const SandboxResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative(),\n  memoryUsed: z.number().nonnegative().optional(),\n  cpuUsed: z.number().nonnegative().optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n  events: z.array(z.any()).optional(),\n});\n\n\n  Schema for lockchain entries (from lockchain-writer.mjs)\n \nexport const LockchainEntrySchema = z.object({\n  id: z.string().uuid(),\n  timestamp: z.number(),\n  receipt: z.any(), // Transaction receipt\n  signature: z.object({\n    algorithm: z.string(),\n    value: z.string(),\n    publicKey: z.string().optional(),\n  }),\n  previousHash: z.string().optional().nullable(),\n  merkleRoot: z.string().optional(),\n  gitCommit: z.string().optional(),\n  gitRef: z.string().optional(),\n});\n\n\n  Schema for lockchain configuration (from lockchain-writer.mjs)",
      "definition": "export const LockchainConfigSchema = z.object({\n  gitRepo: z.string().default(process.cwd()),\n  refName: z.string().default('refs/notes/lockchain'),\n  signingKey: z.string().optional(),\n  algorithm: z",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 990
    },
    {
      "name": "PolicyPackMetaSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)\n \nexport const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEvent', 'log', 'assert']),\n});\n\n\n  Schema for sandbox execution result (from effect-sandbox.mjs)\n \nexport const SandboxResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative(),\n  memoryUsed: z.number().nonnegative().optional(),\n  cpuUsed: z.number().nonnegative().optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n  events: z.array(z.any()).optional(),\n});\n\n\n  Schema for lockchain entries (from lockchain-writer.mjs)\n \nexport const LockchainEntrySchema = z.object({\n  id: z.string().uuid(),\n  timestamp: z.number(),\n  receipt: z.any(), // Transaction receipt\n  signature: z.object({\n    algorithm: z.string(),\n    value: z.string(),\n    publicKey: z.string().optional(),\n  }),\n  previousHash: z.string().optional().nullable(),\n  merkleRoot: z.string().optional(),\n  gitCommit: z.string().optional(),\n  gitRef: z.string().optional(),\n});\n\n\n  Schema for lockchain configuration (from lockchain-writer.mjs)\n \nexport const LockchainConfigSchema = z.object({\n  gitRepo: z.string().default(process.cwd()),\n  refName: z.string().default('refs/notes/lockchain'),\n  signingKey: z.string().optional(),\n  algorithm: z.enum(['ed25519', 'ecdsa', 'rsa']).default('ed25519'),\n  batchSize: z.number().int().positive().default(10),\n  enableMerkle: z.boolean().default(true),\n  enableGitAnchoring: z.boolean().default(true),\n  storagePath: z.string().optional(),\n});\n\n\n  Schema for policy pack metadata (from policy-pack.mjs)",
      "definition": "export const PolicyPackMetaSchema = z.object({\n  name: z.string().min(1).max(100),\n  version: z.string().regex(/^\\d+\\.\\d+\\.\\d+$/),\n  description: z.string().min(1).max(500).optional(),\n  author: z.str",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 1004
    },
    {
      "name": "PolicyPackConfigSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)\n \nexport const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEvent', 'log', 'assert']),\n});\n\n\n  Schema for sandbox execution result (from effect-sandbox.mjs)\n \nexport const SandboxResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative(),\n  memoryUsed: z.number().nonnegative().optional(),\n  cpuUsed: z.number().nonnegative().optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n  events: z.array(z.any()).optional(),\n});\n\n\n  Schema for lockchain entries (from lockchain-writer.mjs)\n \nexport const LockchainEntrySchema = z.object({\n  id: z.string().uuid(),\n  timestamp: z.number(),\n  receipt: z.any(), // Transaction receipt\n  signature: z.object({\n    algorithm: z.string(),\n    value: z.string(),\n    publicKey: z.string().optional(),\n  }),\n  previousHash: z.string().optional().nullable(),\n  merkleRoot: z.string().optional(),\n  gitCommit: z.string().optional(),\n  gitRef: z.string().optional(),\n});\n\n\n  Schema for lockchain configuration (from lockchain-writer.mjs)\n \nexport const LockchainConfigSchema = z.object({\n  gitRepo: z.string().default(process.cwd()),\n  refName: z.string().default('refs/notes/lockchain'),\n  signingKey: z.string().optional(),\n  algorithm: z.enum(['ed25519', 'ecdsa', 'rsa']).default('ed25519'),\n  batchSize: z.number().int().positive().default(10),\n  enableMerkle: z.boolean().default(true),\n  enableGitAnchoring: z.boolean().default(true),\n  storagePath: z.string().optional(),\n});\n\n\n  Schema for policy pack metadata (from policy-pack.mjs)\n \nexport const PolicyPackMetaSchema = z.object({\n  name: z.string().min(1).max(100),\n  version: z.string().regex(/^\\d+\\.\\d+\\.\\d+$/),\n  description: z.string().min(1).max(500).optional(),\n  author: z.string().min(1).max(100).optional(),\n  license: z.string().min(1).max(100).optional(),\n  homepage: z.string().url().optional(),\n  repository: z.string().url().optional(),\n  keywords: z.array(z.string().min(1).max(50)).max(20).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  dependencies: z.array(z.string()).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for policy pack configuration (from policy-pack.mjs)",
      "definition": "export const PolicyPackConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  manifestPath: z.string().default('./policy-pack.json'),\n  hooksPath: z.string().default('./hook",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 1022
    },
    {
      "name": "PolicyPackManifestSchema",
      "type": "object",
      "jsdoc": "@file Zod schemas for knowledge hook validation\n  @module schemas\n \n  @description\n  Comprehensive Zod schemas for validating all knowledge hook components\n  including hook definitions, conditions, events, and execution results.\n \n\nimport { z } from 'zod';\n\n\n  Schema for hook metadata\n \nexport const HookMetaSchema = z.object({\n  name: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(\n      /^[a-zA-Z0-9:_-]+$/,\n      'Name must contain only alphanumeric characters, colons, hyphens, and underscores'\n    ),\n  description: z.string().min(1).max(500).optional(),\n  version: z\n    .string()\n    .regex(/^\\d+\\.\\d+\\.\\d+$/, 'Version must be semantic version format')\n    .optional(),\n  author: z.string().min(1).max(100).optional(),\n  tags: z.array(z.string().min(1).max(50)).max(10).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for content-addressed file references\n \nexport const FileRefSchema = z.object({\n  uri: z\n    .string()\n    .url({ message: 'Must be a valid URI' })\n    .or(z.string().regex(/^file:\\/\\/.+/, 'Must be a valid file URI')),\n  sha256: z\n    .string()\n    .length(64)\n    .regex(/^[a-f0-9]+$/, 'Must be a valid SHA-256 hash')\n    .optional(),\n  mediaType: z.string().min(1).max(100).optional(),\n  size: z.number().int().positive().optional(),\n  lastModified: z.coerce.date().optional(),\n});\n\n\n  Schema for SPARQL ASK conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlAskConditionSchema = z.object({\n  kind: z.literal('sparql-ask'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SPARQL SELECT conditions\n  Supports EITHER file reference (ref) OR inline query (query) for convenience\n \nexport const SparqlSelectConditionSchema = z.object({\n  kind: z.literal('sparql-select'),\n  ref: FileRefSchema.optional(),\n  query: z.string().min(1).optional(),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      limit: z.number().int().positive().max(10000).optional(),\n      offset: z.number().int().nonnegative().optional(),\n      strict: z.boolean().optional(),\n      variables: z.record(z.string()).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for SHACL validation conditions\n  Supports EITHER file reference (ref) OR inline shapes (shapes) for convenience\n \nexport const ShaclConditionSchema = z.object({\n  kind: z.literal('shacl'),\n  ref: FileRefSchema.optional(),\n  shapes: z.string().min(1).optional(), // Inline Turtle shapes for convenience\n  options: z\n    .object({\n      strict: z.boolean().optional(),\n      includeDetails: z.boolean().optional(),\n      maxViolations: z.number().int().positive().max(1000).optional(),\n      shapesGraph: z.string().url({ message: 'Must be a valid URL' }).optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for DELTA predicate conditions\n \nexport const DeltaConditionSchema = z.object({\n  kind: z.literal('delta'),\n  spec: z.object({\n    change: z.enum(['any', 'increase', 'decrease', 'modify']),\n    key: z.array(z.string()).min(1),\n    threshold: z.number().min(0).max(1).optional(),\n    baseline: z.string().optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for THRESHOLD predicate conditions\n \nexport const ThresholdConditionSchema = z.object({\n  kind: z.literal('threshold'),\n  spec: z.object({\n    var: z.string().min(1),\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number(),\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']).optional(),\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for COUNT predicate conditions\n \nexport const CountConditionSchema = z.object({\n  kind: z.literal('count'),\n  spec: z.object({\n    op: z.enum(['>', '>=', '<', '<=', '==', '!=']),\n    value: z.number().int().nonnegative(),\n    query: z.string().optional(), // SPARQL query for counting\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Schema for WINDOW predicate conditions\n \nexport const WindowConditionSchema = z.object({\n  kind: z.literal('window'),\n  spec: z.object({\n    size: z.number().int().positive(), // Window size in milliseconds\n    slide: z.number().int().positive().optional(), // Slide interval\n    aggregate: z.enum(['sum', 'avg', 'min', 'max', 'count']),\n    query: z.string().optional(), // SPARQL query for windowing\n  }),\n  options: z\n    .object({\n      timeout: z.number().int().positive().max(30000).optional(),\n      strict: z.boolean().optional(),\n    })\n    .optional(),\n});\n\n\n  Union schema for all condition types\n \nexport const ConditionSchema = z.discriminatedUnion('kind', [\n  SparqlAskConditionSchema,\n  SparqlSelectConditionSchema,\n  ShaclConditionSchema,\n  DeltaConditionSchema,\n  ThresholdConditionSchema,\n  CountConditionSchema,\n  WindowConditionSchema,\n]);\n\n\n  Schema for determinism configuration\n \nexport const DeterminismSchema = z.object({\n  seed: z.number().int().nonnegative().max(2147483647).default(42),\n  algorithm: z.enum(['lcg', 'xorshift', 'mersenne']).default('lcg'),\n  salt: z.string().min(1).max(100).optional(),\n});\n\n\n  Schema for receipt configuration\n \nexport const ReceiptSchema = z.object({\n  anchor: z\n    .enum(['none', 'blockchain', 'merkle', 'timestamp', 'hash', 'git-notes'])\n    .default('none'),\n  format: z.enum(['json', 'jsonld', 'rdf', 'turtle']).default('json'),\n  includeProof: z.boolean().default(false),\n  ttl: z.number().int().positive().max(86400).optional(), // Time to live in seconds\n});\n\n\n  Schema for hook execution context\n \nexport const HookContextSchema = z.object({\n  graph: z.any(), // RDF Store instance - validated at runtime\n  env: z.record(z.any()).optional(),\n  metadata: z.record(z.any()).optional(),\n  transactionId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for hook events\n \nexport const HookEventSchema = z.object({\n  name: z.string().min(1).max(100),\n  payload: z.any(), // Flexible payload structure\n  context: HookContextSchema,\n  id: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n  timestamp: z.coerce.date().optional(),\n  source: z.string().min(1).max(100).optional(),\n  correlationId: z.string().uuid({ message: 'Must be a valid UUID' }).optional(),\n});\n\n\n  Schema for hook execution results\n \nexport const HookResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative().optional(),\n  phase: z.enum(['before', 'run', 'after', 'completed', 'failed']).optional(),\n  cancelled: z.boolean().default(false),\n  metadata: z.record(z.any()).optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n});\n\n\n  Schema for hook channel configuration\n \nexport const HookChannelSchema = z.object({\n  graphs: z.array(z.string()).optional(),\n  view: z.enum(['before', 'after', 'delta']).optional(),\n});\n\n\n  Schema for complete knowledge hook definition\n \nexport const KnowledgeHookSchema = z.object({\n  meta: HookMetaSchema,\n  channel: HookChannelSchema.optional(),\n  when: ConditionSchema,\n  run: z.function(),\n  before: z.function().optional(),\n  after: z.function().optional(),\n  determinism: DeterminismSchema.optional(),\n  receipt: ReceiptSchema.optional(),\n  timeout: z.number().int().positive().max(300000).optional(), // 5 minutes max\n  retries: z.number().int().nonnegative().max(5).optional(),\n  priority: z.number().int().min(0).max(100).default(50).optional(),\n});\n\n\n  Schema for transaction delta\n \nexport const TransactionDeltaSchema = z.object({\n  additions: z.array(z.any()).default([]), // RDF Quad array\n  removals: z.array(z.any()).default([]), // RDF Quad array\n  metadata: z.record(z.any()).optional(),\n  id: z.string().optional(),\n  timestamp: z.coerce.date().optional(),\n});\n\n\n  Schema for transaction receipt\n \nexport const TransactionReceiptSchema = z.object({\n  committed: z.boolean(),\n  delta: TransactionDeltaSchema,\n  hookResults: z\n    .array(\n      z.object({\n        hookId: z.string(),\n        result: z.boolean(),\n        error: z.string().optional(),\n        duration: z.number().nonnegative().optional(),\n      })\n    )\n    .default([]),\n  beforeHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  afterHash: z\n    .object({\n      sha3: z.string(),\n      blake3: z.string(),\n    })\n    .optional(),\n  timestamp: z.coerce.date(),\n  duration: z.number().nonnegative(),\n  knowledgeHookResults: z.number().int().nonnegative().default(0),\n});\n\n\n  Schema for OpenTelemetry configuration\n \nexport const ObservabilityConfigSchema = z.object({\n  enableTracing: z.boolean().default(true),\n  enableMetrics: z.boolean().default(true),\n  enableLogging: z.boolean().default(true),\n  serviceName: z\n    .string()\n    .min(1)\n    .max(100)\n    .regex(/^[a-zA-Z0-9._-]+$/)\n    .default('unrdf-kgc'),\n  serviceVersion: z.string().min(1).max(50).default('1.0.0'),\n  endpoint: z.string().url().optional(),\n  headers: z.record(z.string()).optional(),\n  resourceAttributes: z.record(z.string()).optional(),\n  samplingRatio: z.number().min(0).max(1).default(1.0),\n  maxQueueSize: z.number().int().positive().default(2048),\n  maxExportBatchSize: z.number().int().positive().default(512),\n  exportTimeoutMillis: z.number().int().positive().default(30000),\n  scheduledDelayMillis: z.number().int().positive().default(5000),\n  // Optional: advertise the maximum cache size used by the runtime for metrics\n  cacheMaxSize: z.number().int().nonnegative().optional(),\n  // Smoothing to reduce false-positive alerts from low samples/spikes\n  minSamples: z.number().int().positive().default(20),\n  ewmaAlpha: z.number().min(0).max(1).default(0.3),\n});\n\n\n  Schema for performance metrics\n \nexport const PerformanceMetricsSchema = z.object({\n  transactionLatency: z.object({\n    p50: z.number().nonnegative(),\n    p95: z.number().nonnegative(),\n    p99: z.number().nonnegative(),\n    max: z.number().nonnegative(),\n  }),\n  hookExecutionRate: z.number().nonnegative(), // hooks per minute\n  errorRate: z.number().min(0).max(1),\n  memoryUsage: z.object({\n    rss: z.number().nonnegative(),\n    heapUsed: z.number().nonnegative(),\n    heapTotal: z.number().nonnegative(),\n    external: z.number().nonnegative(),\n  }),\n  cacheStats: z.object({\n    hitRate: z.number().min(0).max(1),\n    size: z.number().nonnegative(),\n    maxSize: z.number().nonnegative(),\n  }),\n  backpressure: z.object({\n    queueDepth: z.number().nonnegative(),\n    watermarks: z.object({\n      high: z.number().nonnegative(),\n      low: z.number().nonnegative(),\n    }),\n  }),\n});\n\n\n  Schema for manager configuration\n \nexport const ManagerConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n  observability: ObservabilityConfigSchema.optional(),\n  performance: z\n    .object({\n      enableProfiling: z.boolean().default(false),\n      maxConcurrency: z.number().int().positive().default(10),\n      afterHashOnly: z.boolean().default(false), // KGC PRD fast path\n      enableCache: z.boolean().default(true),\n      timeoutMs: z.number().int().positive().default(2000), // KGC PRD: p99 ≤ 2ms\n      maxHooks: z.number().int().positive().default(10000), // KGC PRD: 10k exec/min\n    })\n    .optional(),\n});\n\n\n  Schema for file resolver configuration\n \nexport const FileResolverConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  maxFileSize: z.number().int().positive().max(10485760).default(1048576), // 1MB default\n  allowedMediaTypes: z\n    .array(z.string())\n    .default([\n      'application/sparql-query',\n      'text/turtle',\n      'application/rdf+xml',\n      'application/ld+json',\n    ]),\n  timeout: z.number().int().positive().max(30000).default(5000),\n});\n\n\n  Schema for condition evaluator configuration\n \nexport const ConditionEvaluatorConfigSchema = z.object({\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000),\n  timeout: z.number().int().positive().max(30000).default(10000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  strict: z.boolean().default(false),\n});\n\n\n  Schema for hook executor configuration\n \nexport const HookExecutorConfigSchema = z.object({\n  timeout: z.number().int().positive().max(300000).default(30000),\n  maxConcurrent: z.number().int().positive().max(100).default(10),\n  retries: z.number().int().nonnegative().max(3).default(1),\n  enableMetrics: z.boolean().default(true),\n  strict: z.boolean().default(false),\n  enableAssertions: z.boolean().default(true),\n});\n\n\n  Validation functions\n \n\n\n  Validate a knowledge hook definition\n  @param {any} hook - The hook definition to validate\n  @returns {Object} Validation result\n \nexport function validateKnowledgeHook(hook) {\n  try {\n    const validated = KnowledgeHookSchema.parse(hook);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a hook event\n  @param {any} event - The event to validate\n  @returns {Object} Validation result\n \nexport function validateHookEvent(event) {\n  try {\n    const validated = HookEventSchema.parse(event);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate a condition\n  @param {any} condition - The condition to validate\n  @returns {Object} Validation result\n \nexport function validateCondition(condition) {\n  try {\n    const validated = ConditionSchema.parse(condition);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors: (error.issues || error.errors || []).map(err => ({\n          path: err.path?.join('.') || 'unknown',\n          message: err.message || 'Unknown error',\n          code: err.code || 'unknown',\n          received: err.received,\n          expected: err.expected,\n        })),\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate manager configuration\n  @param {any} config - The configuration to validate\n  @returns {Object} Validation result\n \nexport function validateManagerConfig(config) {\n  try {\n    const validated = ManagerConfigSchema.parse(config);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Validate transaction delta\n  @param {any} delta - The delta to validate\n  @returns {Object} Validation result\n \nexport function validateTransactionDelta(delta) {\n  try {\n    const validated = TransactionDeltaSchema.parse(delta);\n    return { success: true, data: validated, errors: [] };\n  } catch (error) {\n    if (error instanceof z.ZodError) {\n      return {\n        success: false,\n        data: null,\n        errors:\n          error.errors?.map(err => ({\n            path: err.path?.join('.') || 'unknown',\n            message: err.message || 'Unknown error',\n            code: err.code || 'unknown',\n          })) || [],\n      };\n    }\n    throw error;\n  }\n}\n\n\n  Type-safe hook definition creator\n  @param {any} definition - The hook definition\n  @returns {Object} Validated and frozen hook definition\n \nexport function createKnowledgeHook(definition) {\n  try {\n    const validation = validateKnowledgeHook(definition);\n\n    if (!validation.success) {\n      console.error('Validation errors:', validation.errors);\n      console.error('Definition:', definition);\n      const errorMessages =\n        validation.errors\n          ?.map(err => {\n            let msg = `${err.path}: ${err.message}`;\n            if (err.received !== undefined) {\n              msg += ` (received: ${JSON.stringify(err.received)})`;\n            }\n            if (err.expected !== undefined) {\n              msg += ` (expected: ${err.expected})`;\n            }\n            return msg;\n          })\n          .join(', ') || 'Unknown validation error';\n      throw new TypeError(`Invalid knowledge hook definition: ${errorMessages}`);\n    }\n\n    // Apply defaults and freeze\n    const normalized = {\n      ...validation.data,\n      determinism: { seed: 42, ...validation.data.determinism },\n      receipt: { anchor: 'none', ...validation.data.receipt },\n      priority: validation.data.priority ?? 50,\n    };\n\n    return Object.freeze(normalized);\n  } catch (error) {\n    if (error instanceof TypeError) {\n      throw error;\n    }\n    console.error('Unexpected error in createKnowledgeHook:', error);\n    throw new TypeError(`Invalid knowledge hook definition: ${error.message}`);\n  }\n}\n\n\n  Type-safe event creator\n  @param {any} event - The event definition\n  @returns {Object} Validated event\n \nexport function createHookEvent(event) {\n  const validation = validateHookEvent(event);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid hook event: ${errorMessages}`);\n  }\n\n  // Apply defaults\n  const normalized = {\n    ...validation.data,\n    id: validation.data.id ?? crypto.randomUUID(),\n    timestamp: validation.data.timestamp ?? new Date().toISOString(),\n  };\n\n  return normalized;\n}\n\n\n  Type-safe condition creator\n  @param {any} condition - The condition definition\n  @returns {Object} Validated condition\n \nexport function createCondition(condition) {\n  const validation = validateCondition(condition);\n\n  if (!validation.success) {\n    const errorMessages =\n      validation.errors\n        ?.map(err => {\n          let msg = `${err.path}: ${err.message}`;\n          if (err.received !== undefined) {\n            msg += ` (received: ${JSON.stringify(err.received)})`;\n          }\n          if (err.expected !== undefined) {\n            msg += ` (expected: ${err.expected})`;\n          }\n          return msg;\n        })\n        .join(', ') || 'Unknown validation error';\n    throw new TypeError(`Invalid condition: ${errorMessages}`);\n  }\n\n  return validation.data;\n}\n\n// ========================================\n// Consolidated Schemas from Other Files\n// ========================================\n\n\n  Schema for RDF quads (from transaction.mjs)\n \nexport const QuadSchema = z\n  .object({\n    subject: z.any(), // RDF/JS Term\n    predicate: z.any(), // RDF/JS Term\n    object: z.any(), // RDF/JS Term\n    graph: z.any().optional(), // RDF/JS Term\n    equals: z.function().optional(),\n  })\n  .passthrough(); // Allow additional properties for RDF/JS Quad objects\n\n\n  Schema for delta (from transaction.mjs)\n \nexport const DeltaSchema = z.object({\n  additions: z.array(QuadSchema),\n  removals: z.array(QuadSchema),\n});\n\n\n  Schema for transaction hooks (from transaction.mjs)\n \nexport const TransactionHookSchema = z.object({\n  id: z.string().min(1),\n  mode: z.enum(['pre', 'post']),\n  condition: z.function(),\n  effect: z.union([z.literal('veto'), z.function()]),\n});\n\n\n  Schema for hook results (from transaction.mjs)\n \nexport const TransactionHookResultSchema = z.object({\n  hookId: z.string(),\n  mode: z.enum(['pre', 'post']),\n  result: z.boolean(),\n  error: z.string().optional(),\n});\n\n\n  Schema for hash values (from transaction.mjs)\n \nexport const HashSchema = z.object({\n  sha3: z.string(),\n  blake3: z.string(),\n});\n\n\n  Schema for transaction receipt (from transaction.mjs)\n \nexport const TransactionReceiptSchemaNew = z.object({\n  id: z.string(),\n  delta: DeltaSchema,\n  committed: z.boolean(),\n  hookResults: z.array(TransactionHookResultSchema),\n  beforeHash: HashSchema,\n  afterHash: HashSchema,\n  timestamp: z.number(),\n  durationMs: z.number(),\n  actor: z.string().optional(),\n  hookErrors: z.array(z.string()),\n  error: z.string().optional(),\n});\n\n\n  Schema for transaction options (from transaction.mjs)\n \nexport const TransactionOptionsSchema = z.object({\n  skipHooks: z.boolean().default(false),\n  timeoutMs: z.number().positive().default(30000),\n  actor: z.string().optional(),\n});\n\n\n  Schema for manager options (from transaction.mjs)\n \nexport const ManagerOptionsSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  strictMode: z.boolean().default(false),\n  enableConditionEvaluation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(1000).default(100),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  enableCache: z.boolean().default(true),\n  cacheMaxAge: z.number().int().positive().max(3600000).default(300000), // 5 minutes\n  enableMetrics: z.boolean().default(true),\n  logLevel: z.enum(['error', 'warn', 'info', 'debug']).default('info'),\n});\n\n\n  Schema for query plans (from query-optimizer.mjs)\n \nexport const QueryPlanSchema = z.object({\n  id: z.string(),\n  query: z.string(),\n  type: z.enum(['sparql-ask', 'sparql-select', 'shacl']),\n  hash: z.string(),\n  plan: z.object({\n    operations: z.array(\n      z.object({\n        type: z.string(),\n        cost: z.number(),\n        selectivity: z.number(),\n        dependencies: z.array(z.string()).optional(),\n      })\n    ),\n    estimatedCost: z.number(),\n    estimatedRows: z.number(),\n    indexes: z.array(z.string()).optional(),\n  }),\n  createdAt: z.number(),\n  lastUsed: z.number(),\n  hitCount: z.number().default(0),\n});\n\n\n  Schema for index definitions (from query-optimizer.mjs)\n \nexport const IndexSchema = z.object({\n  id: z.string(),\n  name: z.string(),\n  type: z.enum(['predicate', 'subject', 'object', 'graph', 'composite']),\n  fields: z.array(z.string()),\n  selectivity: z.number().min(0).max(1),\n  size: z.number().nonnegative(),\n  createdAt: z.number(),\n  lastUpdated: z.number(),\n});\n\n\n  Schema for delta-aware evaluation context (from query-optimizer.mjs)\n \nexport const DeltaAwareContextSchema = z.object({\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n  }),\n  affectedSubjects: z.set(z.string()).optional(),\n  affectedPredicates: z.set(z.string()).optional(),\n  affectedObjects: z.set(z.string()).optional(),\n  affectedGraphs: z.set(z.string()).optional(),\n});\n\n\n  Schema for agent proposals (from resolution-layer.mjs)\n \nexport const AgentProposalSchema = z.object({\n  id: z.string().uuid(),\n  agentId: z.string().min(1),\n  delta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  priority: z.number().int().min(0).max(100).default(50),\n  timestamp: z.number(),\n  metadata: z.record(z.any()).optional(),\n  dependencies: z.array(z.string()).optional(),\n  conflicts: z.array(z.string()).optional(),\n});\n\n\n  Schema for resolution strategies (from resolution-layer.mjs)\n \nexport const ResolutionStrategySchema = z.object({\n  type: z.enum(['voting', 'merging', 'crdt', 'consensus', 'priority', 'random']),\n  parameters: z.record(z.any()).optional(),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  quorum: z.number().min(0).max(1).default(0.5),\n  maxRetries: z.number().int().nonnegative().max(10).default(3),\n});\n\n\n  Schema for resolution results (from resolution-layer.mjs)\n \nexport const ResolutionResultSchema = z.object({\n  id: z.string().uuid(),\n  strategy: z.string(),\n  proposals: z.array(AgentProposalSchema),\n  resolvedDelta: z.object({\n    additions: z.array(z.any()),\n    removals: z.array(z.any()),\n    metadata: z.record(z.any()).optional(),\n  }),\n  confidence: z.number().min(0).max(1),\n  consensus: z.boolean(),\n  conflicts: z\n    .array(\n      z.object({\n        type: z.enum(['addition', 'removal', 'metadata']),\n        proposals: z.array(z.string()),\n        resolution: z.string(),\n      })\n    )\n    .optional(),\n  timestamp: z.number(),\n  duration: z.number().nonnegative(),\n});\n\n\n  Schema for sandbox configuration (from effect-sandbox.mjs)\n \nexport const SandboxConfigSchema = z.object({\n  type: z.enum(['vm2', 'worker', 'isolate']).default('worker'),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  memoryLimit: z\n    .number()\n    .int()\n    .positive()\n    .max(1024  1024  1024)\n    .default(64  1024  1024), // 64MB\n  cpuLimit: z.number().int().positive().max(100).default(50), // 50% CPU\n  allowedModules: z.array(z.string()).default([]),\n  allowedGlobals: z.array(z.string()).default(['console', 'Date', 'Math', 'JSON']),\n  enableNetwork: z.boolean().default(false),\n  enableFileSystem: z.boolean().default(false),\n  enableProcess: z.boolean().default(false),\n  strictMode: z.boolean().default(true),\n});\n\n\n  Schema for sandbox execution context (from effect-sandbox.mjs)\n \nexport const SandboxContextSchema = z.object({\n  event: z.any(),\n  store: z.any(),\n  delta: z.any(),\n  metadata: z.record(z.any()).optional(),\n  allowedFunctions: z.array(z.string()).default(['emitEvent', 'log', 'assert']),\n});\n\n\n  Schema for sandbox execution result (from effect-sandbox.mjs)\n \nexport const SandboxResultSchema = z.object({\n  success: z.boolean(),\n  result: z.any().optional(),\n  error: z.string().optional(),\n  duration: z.number().nonnegative(),\n  memoryUsed: z.number().nonnegative().optional(),\n  cpuUsed: z.number().nonnegative().optional(),\n  assertions: z\n    .array(\n      z.object({\n        subject: z.string(),\n        predicate: z.string(),\n        object: z.string(),\n        graph: z.string().optional(),\n      })\n    )\n    .optional(),\n  events: z.array(z.any()).optional(),\n});\n\n\n  Schema for lockchain entries (from lockchain-writer.mjs)\n \nexport const LockchainEntrySchema = z.object({\n  id: z.string().uuid(),\n  timestamp: z.number(),\n  receipt: z.any(), // Transaction receipt\n  signature: z.object({\n    algorithm: z.string(),\n    value: z.string(),\n    publicKey: z.string().optional(),\n  }),\n  previousHash: z.string().optional().nullable(),\n  merkleRoot: z.string().optional(),\n  gitCommit: z.string().optional(),\n  gitRef: z.string().optional(),\n});\n\n\n  Schema for lockchain configuration (from lockchain-writer.mjs)\n \nexport const LockchainConfigSchema = z.object({\n  gitRepo: z.string().default(process.cwd()),\n  refName: z.string().default('refs/notes/lockchain'),\n  signingKey: z.string().optional(),\n  algorithm: z.enum(['ed25519', 'ecdsa', 'rsa']).default('ed25519'),\n  batchSize: z.number().int().positive().default(10),\n  enableMerkle: z.boolean().default(true),\n  enableGitAnchoring: z.boolean().default(true),\n  storagePath: z.string().optional(),\n});\n\n\n  Schema for policy pack metadata (from policy-pack.mjs)\n \nexport const PolicyPackMetaSchema = z.object({\n  name: z.string().min(1).max(100),\n  version: z.string().regex(/^\\d+\\.\\d+\\.\\d+$/),\n  description: z.string().min(1).max(500).optional(),\n  author: z.string().min(1).max(100).optional(),\n  license: z.string().min(1).max(100).optional(),\n  homepage: z.string().url().optional(),\n  repository: z.string().url().optional(),\n  keywords: z.array(z.string().min(1).max(50)).max(20).optional(),\n  ontology: z.array(z.string().min(1).max(50)).max(10).optional(),\n  dependencies: z.array(z.string()).optional(),\n  createdAt: z.coerce.date().optional(),\n  updatedAt: z.coerce.date().optional(),\n});\n\n\n  Schema for policy pack configuration (from policy-pack.mjs)\n \nexport const PolicyPackConfigSchema = z.object({\n  basePath: z.string().min(1).default(process.cwd()),\n  manifestPath: z.string().default('./policy-pack.json'),\n  hooksPath: z.string().default('./hooks'),\n  activateOnLoad: z.boolean().default(false),\n  enableValidation: z.boolean().default(true),\n  maxHooks: z.number().int().positive().max(100).default(50),\n  timeout: z.number().int().positive().max(300000).default(30000),\n  strictMode: z.boolean().default(false),\n});\n\n\n  Schema for policy pack manifest (from policy-pack.mjs)",
      "definition": "export const PolicyPackManifestSchema = z.object({\n  meta: PolicyPackMetaSchema,\n  hooks: z.array(\n    z.object({\n      file: z.string().min(1),\n      condition: z.object({\n        kind: z.enum(['spar",
      "sourceFile": "/packages/knowledge-engine/src/schemas.mjs",
      "line": 1036
    }
  ],
  "@unrdf/project-engine": [
    {
      "name": "XxxSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const XxxSchema = z.object({ ... })\n  const schemaPattern =\n    /(?:export\\s+)?(?:const|let)\\s+(\\w+)Schema\\s*=\\s*z\\.object\\(\\s*\\{([^}]+(?:\\{[^}]*\\}[^}]*)*)\\}\\s*\\)/g;",
      "sourceFile": "/packages/project-engine/src/type-auditor.mjs",
      "line": 136
    },
    {
      "name": "TemplateSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const TemplateSchema = z.object({\n  id: z.string(),\n  kind: z.string(),\n  outputPattern: z.string(),\n  variables: z.array(z.string()),\n  invariants: z.array(z.string()),\n  variantCount: z.numbe",
      "sourceFile": "/packages/project-engine/src/template-infer.mjs",
      "line": 31
    },
    {
      "name": "InferSummarySchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const InferSummarySchema = z.object({\n  templateCount: z.number(),\n  byKind: z.record(z.string(), z.number()),\n});",
      "sourceFile": "/packages/project-engine/src/template-infer.mjs",
      "line": 41
    },
    {
      "name": "XxxSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const XxxSchema = z.object({ ... })\n  const schemaPattern =\n    /(?:export\\s+)?(?:const|let)\\s+(\\w+)Schema\\s*=\\s*z\\.object\\(\\s*\\{([^}]+(?:\\{[^}]*\\}[^}]*)*)\\}\\s*\\)/g;",
      "sourceFile": "/packages/project-engine/src/domain-infer.mjs",
      "line": 205
    }
  ],
  "@unrdf/validation": [
    {
      "name": "ValidationResultSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const ValidationResultSchema = z.object({\n  feature: z.string(),\n  passed: z.boolean(),\n  score: z.number().min(0).max(100),\n  metrics: z.object({\n    latency: z.number(),\n    errorRate: z.numb",
      "sourceFile": "/packages/validation/src/otel-validator-core.mjs",
      "line": 30
    },
    {
      "name": "FeatureValidationConfigSchema",
      "type": "object",
      "jsdoc": "",
      "definition": "export const FeatureValidationConfigSchema = z.object({\n  expectedSpans: z.array(z.string()),\n  requiredAttributes: z.array(z.string()),\n  performanceThresholds: z.object({\n    maxLatency: z.number(),",
      "sourceFile": "/packages/validation/src/otel-validator-core.mjs",
      "line": 52
    }
  ]
}