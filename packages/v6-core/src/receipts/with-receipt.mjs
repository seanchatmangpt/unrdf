/**
 * KGC-4D Receipt Wrapper HOF (Higher-Order Function)
 *
 * Wraps any function to generate deterministic receipts with:
 * - BLAKE3 hash chain
 * - Merkle proof support
 * - Injected timestamps (no Date.now())
 * - Input/output hashing
 *
 * **P0-001 Implementation**
 *
 * @module @unrdf/v6-core/receipts/with-receipt
 */

import { createReceipt } from './index.mjs';
import { computeBlake3, deterministicSerialize } from './base-receipt.mjs';

/**
 * Wrap a function with deterministic receipt generation
 *
 * **Determinism Guarantee:**
 * - NO Date.now() or Math.random()
 * - All timestamps injected via context
 * - Hashes are deterministic (BLAKE3 with sorted keys)
 * - Same inputs → Same receipt (idempotent)
 *
 * @param {Function} fn - Function to wrap
 * @param {Object} context - Receipt context
 * @param {string} context.operation - Operation name (for receipt tracking)
 * @param {Function} [context.getTimestamp] - Timestamp provider (defaults to kgc-4d now())
 * @param {Object|null} [context.previousReceipt=null] - Previous receipt for chaining
 * @param {string} [context.caseId] - Workflow case ID (for execution receipts)
 * @param {string} [context.taskId] - Task ID (for execution receipts)
 * @returns {Function} Wrapped function that returns {result, receipt}
 *
 * @example
 * // Basic usage with injected timestamp
 * import { withReceipt } from '@unrdf/v6-core/receipts/with-receipt';
 *
 * const processData = withReceipt(
 *   (data) => data.map(x => x * 2),
 *   {
 *     operation: 'processData',
 *     getTimestamp: () => 1704110400000000000n // Fixed for determinism
 *   }
 * );
 *
 * const { result, receipt } = await processData([1, 2, 3]);
 * // result: [2, 4, 6]
 * // receipt: { id, hash, merkle_proof, timestamp_provided, ... }
 *
 * @example
 * // Chained receipts
 * const receipt1 = await processStep1();
 * const receipt2 = await processStep2WithReceipt({
 *   previousReceipt: receipt1.receipt
 * });
 */
export function withReceipt(fn, context = {}) {
  if (typeof fn !== 'function') {
    throw new Error('withReceipt requires a function as first argument');
  }

  const {
    operation = fn.name || 'anonymous',
    getTimestamp = null,
    previousReceipt = null,
    caseId = 'default-case',
    taskId = operation,
    getUUID = null, // Optional deterministic UUID generator
  } = context;

  return async function wrappedWithReceipt(...args) {
    // 1. Compute inputs hash (deterministic)
    const inputs_hash = await computeBlake3(deterministicSerialize(args));

    // 2. Execute function
    const startTime = performance.now();
    const result = await fn(...args);
    const endTime = performance.now();
    const duration = endTime - startTime;

    // 3. Compute outputs hash (deterministic)
    const outputs_hash = await computeBlake3(deterministicSerialize(result));

    // 4. Generate deterministic UUID if provider given
    // For deterministic testing, use hash of inputs as UUID seed
    let receiptId;
    if (getUUID) {
      receiptId = getUUID(inputs_hash);
    } else {
      // Generate deterministic UUID v4 from inputs_hash when getTimestamp is provided
      if (getTimestamp) {
        // Create valid UUID v4 from hash: xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx
        const hex = inputs_hash.substring(0, 32);
        receiptId = `${hex.substring(0, 8)}-${hex.substring(8, 12)}-4${hex.substring(13, 16)}-${
          ['8', '9', 'a', 'b'][parseInt(hex.substring(16, 17), 16) % 4]
        }${hex.substring(17, 20)}-${hex.substring(20, 32)}`;
      } else {
        receiptId = null; // Will be auto-generated by createReceipt
      }
    }

    // 5. Create execution receipt with injected timestamp
    const eventData = {
      eventType: 'TASK_COMPLETED',
      caseId,
      taskId,
      payload: {
        decision: 'COMPLETE',
        justification: {
          reasoning: `Executed ${operation} with inputs_hash=${inputs_hash}`,
        },
        context: {
          operation,
          inputs_hash,
          outputs_hash,
          duration,
          argsCount: args.length,
        },
      },
    };

    // Use injected timestamp if provided
    if (getTimestamp) {
      eventData._timestampProvider = getTimestamp;
    }

    // Use deterministic ID if computed
    if (receiptId) {
      eventData._deterministicId = receiptId;
    }

    const receipt = await createReceipt('execution', eventData, previousReceipt);

    // 5. Add P0-001 required fields to receipt metadata
    const enhancedReceipt = {
      ...receipt,
      // P0-001 required fields (in addition to base receipt fields)
      operation_name: operation,
      inputs_hash,
      outputs_hash,
      merkle_proof: null, // Will be set by MerkleTree.addLeaf() if needed
      timestamp_provided: getTimestamp ? 'injected' : 'kgc-4d',
    };

    return {
      result,
      receipt: enhancedReceipt,
    };
  };
}

/**
 * Create a receipt chain from multiple function calls
 *
 * @param {Array<{fn: Function, context: Object}>} steps - Array of functions with contexts
 * @returns {Promise<Array<{result: any, receipt: Object}>>} Results with chained receipts
 *
 * @example
 * const chain = await createReceiptChain([
 *   { fn: step1, context: { operation: 'step1' } },
 *   { fn: step2, context: { operation: 'step2' } },
 *   { fn: step3, context: { operation: 'step3' } },
 * ]);
 *
 * // chain[0].receipt.previousHash === null
 * // chain[1].receipt.previousHash === chain[0].receipt.receiptHash
 * // chain[2].receipt.previousHash === chain[1].receipt.receiptHash
 */
export async function createReceiptChain(steps) {
  const results = [];
  let previousReceipt = null;

  for (const { fn, context } of steps) {
    const wrapped = withReceipt(fn, { ...context, previousReceipt });
    const result = await wrapped();
    results.push(result);
    previousReceipt = result.receipt;
  }

  return results;
}

/**
 * Verify idempotency: same inputs → same receipt
 *
 * **Testing Determinism:**
 * Run the wrapped function twice with identical inputs and injected timestamp.
 * Receipt hashes MUST be identical.
 *
 * @param {Function} wrappedFn - Function wrapped with withReceipt
 * @param {Array} args - Arguments to test with
 * @returns {Promise<{idempotent: boolean, receipt1: Object, receipt2: Object}>}
 *
 * @example
 * const wrapped = withReceipt(
 *   (x) => x * 2,
 *   { operation: 'double', getTimestamp: () => 1704110400000000000n }
 * );
 *
 * const check = await verifyIdempotency(wrapped, [5]);
 * assert(check.idempotent === true);
 * assert(check.receipt1.receiptHash === check.receipt2.receiptHash);
 */
export async function verifyIdempotency(wrappedFn, args = []) {
  const run1 = await wrappedFn(...args);
  const run2 = await wrappedFn(...args);

  const idempotent =
    run1.receipt.receiptHash === run2.receipt.receiptHash &&
    run1.receipt.inputs_hash === run2.receipt.inputs_hash &&
    run1.receipt.outputs_hash === run2.receipt.outputs_hash;

  return {
    idempotent,
    receipt1: run1.receipt,
    receipt2: run2.receipt,
    hashMatch: run1.receipt.receiptHash === run2.receipt.receiptHash,
  };
}

export default withReceipt;
